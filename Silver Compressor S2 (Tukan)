desc:Silver Compressor S2 (Tukan)

slider1:-10<-40,20,0.1>-Threshold
slider2:0.6<0,1,0.01>-Ratio
slider3:.35<0,1,0.01>-Attack
slider4:0.5<0,1,0.01>-Release
slider5:0<0,6,.01>-Enhancer
slider6:0<-20,20,0.1>-Output
slider7:0<0,1,.01>-EXP
slider8:0<0,1,1>-Sidechain
slider10:0<0,1,1>-Auto
slider11:0<0,1,1>-Bypass
slider12:0<0,1,1>-12 Fast EXP
slider13:0<0,1,1>-Interactive
slider14:0<0,1,1>-SC HPF
slider15:0<0,1,1{Analog,Digital>-Knob Mode

import S2GFX/tk_lib.jsfx-inc
import S2GFX/cookdsp.jsfx-inc
import S2GFX/svf_filter.jsfx-inc


filename:0,S2GFX/HD_Back.png
filename:1,S2GFX/BlueKnob.png
filename:2,S2GFX/RedKnob.png
filename:3,S2GFX/SmallKnob.png
filename:4,S2GFX/button.png
filename:5,S2GFX/switch.png
filename:6,S2GFX/gled.png
filename:7,S2GFX/rled.png
filename:8,S2GFX/yled.png
filename:9,S2GFX/oled.png
filename:10,S2GFX/bled.png
filename:11,S2GFX/Autocom.png
filename:12,S2GFX/S2_logo.png
filename:13,S2GFX/Autocom.png
filename:14,S2GFX/Autocom.png
filename:15,S2GFX/geled.png
filename:16,S2GFX/yeled.png
filename:17,S2GFX/reled.png
filename:18,S2GFX/Autocom.png
filename:19,S2GFX/Amp_Plates.png


in_pin:Input L
in_pin:Input R

in_pin:External SC / L
in_pin:External SC / R

out_pin:Output L
out_pin:Output R
options:No_meter
options:gfx_hz=60
options:gmem=TukanCompressorSilverS2
//options:gfx_idle

@init
SILVER_COMPRESSOR_VERSION = 1.20;

gled = 15;
rled = 17;
yled = 16;
oled = 9;
bled = 10;
Knob = 13;
but = 14;


geled = 15;
yeled = 16;
reled = 17;
autocom = 18;
Amp_plates = 19;



ext_tail_size = -1;
ext_nodenorm = 1;
gfx_ext_retina = 1;
gfx_clear=0;
ext_noinit=1;
lastCap=1;
mouse_wheel=1;
is_recording = 0; is_playing = 0; is_stopped = 1;
while_playing = 1; while_recording = 1; while_stopped = 1;
Number_input = 0;
number_input_raw = 0;
number_input_use = 0;
komma = 0;
in_key = 0;
number_input_x = 0;
number_input_y=0;
number_input_slider = 0;
number_input_min=0;
number_input_max=0;
number_input_invalid = 0;
number_input_sign=1;


s2_numbers_of_sliders = 15;
s2_numbers_of_generics = 0;
group_generics =0; // fuer group_generics[bis zu 200]
sliders_old = group_generics + 16*200;
generics_old = sliders_old + 16*64;
 Mouse_Sensivity ();


    Notiz1_Knob.parameter_config           (7,      0,        0,     1,     20,   127,  120,  101,    1,       Autocom);
    Notiz2_Knob.parameter_config           (1,    -10,      -40,    20,     170+5,  127,  120,  101,    1,       Autocom);
    Notiz3_Knob.parameter_config           (2,    0.6,        0,     1,     295+5,  127,  120,  101,    1,       Autocom);
    Notiz4_Knob.parameter_config           (3,    0.35,        0,     1,     420+5,  127,  120,  101,    1,       Autocom);
    Notiz5_Knob.parameter_config           (4,    0.5,        0,     1,     545+5,  127,  120,  101,    1,       Autocom);
    Notiz6_Knob.parameter_config           (6,    0,        -20,  20,     680+5,  127,  120,  101,    1,       Autocom);
    Notiz7_Knob.parameter_config           (5,    0,        0,     6,     798,  127,  120,  101,    1,       Autocom);
    Bfastrel.slider = 12;
    BKnee.slider = 13;
    BHPF.slider = 14;
    BAuto.slider = 10;
    BBypass.slider = 11;
    BSidechain.slider = 8;
       




function band_set_filter(t, f, g, qval, slope)
 instance (enabled, type, frequency, gain, q, filter, color) (
  type = t; frequency = f; gain = g; q = qval;
  type == 0 ? filter.svf_eq(frequency, q, db_to_gain(gain)) :
    type == 1 ? filter.svf_hp(frequency, q, slope) :
      type == 2 ? filter.svf_hpb(frequency, slope) :
        type == 3 ? filter.svf_ls(frequency, q, db_to_gain(gain)) :
          type == 4 ? filter.svf_hs(frequency, q, db_to_gain(gain)) :
            type == 5 ? filter.svf_lp(frequency, q, slope) :
              type == 6 ? filter.svf_lpb(frequency, slope) :
                type == 7 ? filter.svf_bs(frequency, q) :
                  type == 8 ? filter.svf_bp2(frequency, q) :
                    type == 9 ? filter.svf_st(frequency, q, gain) :
                      type == 10 ? filter.svf_pultecls(frequency, q, gain) :
                        type == 11 ? filter.svf_ap(frequency, q) :
                          type == 12 ? filter.svf_analog_lowcut(frequency, q, gain) :
                            type == 13 ? filter.svf_analog_highcut(frequency, q, gain);
);

  MAX_FREQ = 44100 / 2.0;
  MIN_FREQ = 10;
  FREQ_LOG_MAX = log(MAX_FREQ / MIN_FREQ);

  MAX_Q = 4;
  MIN_Q = 0.10;
  Q_LOG_MAX = log(MAX_Q / MIN_Q);
  
/*
 * Convert slider % to frequency
 */
function per_to_freq(x, range) (
  MIN_FREQ * exp(FREQ_LOG_MAX * x / range);
);

/*
 * Convert frequency to slider %
 */
function freq_to_per(freq, range) (
  range * log(freq / MIN_FREQ) / FREQ_LOG_MAX;
);


function per_to_q(x, range) (
  MIN_Q * exp(Q_LOG_MAX * x / range);LFO
);

/*
 * Convert frequency to slider %
 */
function q_to_per(q, range) (
  range * log(q / MIN_Q) / Q_LOG_MAX;
);

function band_init()
  instance (enabled, type, frequency, gain, q, filter, color) ( 
  filter.svf_set_sample_rate(SAMPLE_RATE);
  filter.svf_bypass();
  //color.create_color(0,0,0);

  filter.a1 = filter.t_a1;
  filter.a2 = filter.t_a2;
  filter.a3 = filter.t_a3;

  filter.m0 = filter.t_m0;
  filter.m1 = filter.t_m1;
  filter.m2 = filter.t_m2;
  filter.iter_t = 1.0;
);
  
  
  
/*
 blueknob = 1;
 redknob = 2;
 smallknob = 3;
 button = 4;
 switch = 5;
 gled = 6; rled = 7; yled = 8; oled = 9; bled = 10;
 menu = 11;  
 logo = 12;

Comp_knobs_x = 70;
Comp_knobs_y = 220;
 //Parameter_config                (slider_  default_ minVal_ maxVal_ xIn_ yIn_ wIn   frames_ scaling_ file_)
       KThreshold.parameter_config     (1,       0,        -40,    0,   Comp_knobs_x,  Comp_knobs_y,  150, 200,    1,       blueknob);
       
       KHPF.parameter_config     (7,       10,        10,    350,   Comp_knobs_x + 7,  Comp_knobs_y + 120,  120, 200,    1,       smallknob);
       //KHyst.parameter_config     (2,       0,        -20,    0,   Comp_knobs_x + 130,  Comp_knobs_y + 15,  120, 200,    1,       smallknob);
       //KLookahead.parameter_config     (9,       10,        0,    30,   Comp_knobs_x + 225,  Comp_knobs_y + 15,  120, 200,    1,       smallknob);
       //KHPF.parameter_config     (3,       10,        10,    350,   Comp_knobs_x + 320,  Comp_knobs_y + 15,  120, 200,    1,       smallknob);

       KRatio.parameter_config     (2,       4,        1,    15,   Comp_knobs_x+125,  Comp_knobs_y,  150, 200,    1,       redknob);
       KKnee.parameter_config     (5,       0,        0,    100,   Comp_knobs_x + 125 + 7,  Comp_knobs_y + 120,  120, 200,    1,       smallknob);
 
       KAttack.parameter_config     (3,       4,        0.1,    50,   Comp_knobs_x + 125 +140,  Comp_knobs_y + 7,  120, 200,    1,       smallknob);

       KRelease.parameter_config     (4,       100,        10,    1000,   Comp_knobs_x + 125 + 140,  Comp_knobs_y + 120,  120, 200,    1,       smallknob);
       
       KOutput.parameter_config     (6,       0,        -24,    24,   Comp_knobs_x + 415,  Comp_knobs_y - 150,  150, 200,    1,       redknob);
       
       KDrywet.parameter_config     (9,       100,        0,    100,   Comp_knobs_x + 415 + 7,  Comp_knobs_y - 150 + 120,  120, 200,    1,       smallknob);

       Bsidechain.button_config(8, Comp_knobs_x + 460, Comp_knobs_y + 75);
       BTrick.button_config(10, Comp_knobs_x + 460, Comp_knobs_y + 115);
       BBypass.button_config(11, Comp_knobs_x + 460, Comp_knobs_y + 155);
       //Binverse.button_config(12, Comp_knobs_x + 48, Comp_knobs_y + 340);



histbuf=1000000;
histpos=0;
rmspos = 0;


//gfx_ext_retina == 0 ? gfx_ext_retina = 1;
gfx_clear=0;
gfx_ext_retina = 1;
ext_noinit=1;
ext_nodenorm=1;
cDenorm=10^-30;

recpos=0;
max_fft_size=32768;
fftsize=max_fft_size;
windowtype=-1;
fftidx=-1;

//histsize=max_fft_size + (max_fft_size*0.5 - 1);
//window=histsize;
//fftworkspace=window+(max_fft_size*0.5 + 1);
//integrate_buf = fftworkspace + max_fft_size*2;

histsize = 8*(srate);
hist_in_L = histbuf;;
hist_in_R = hist_in_L+histsize;
hist_out_L = hist_in_L+2*histsize;
hist_out_R = hist_in_L+3*histsize;
hist_GR = hist_in_L+4 * histsize;
histpos=0;
  
  







MBC1_yR = 0;
MBC1_yA = 0;
*/


function g1_computeGain(x)
(
(x < MBC1_Tlo) ? x = 0 :
(x > MBC1_Thi) ? x = MBC1_slope * (x - MBC1_Threshold) :
(MBC1_delta = x - MBC1_Tlo;
x = MBC1_delta * MBC1_delta * MBC1_knee_factor;);
);


function g2_computeGain(x)
(
(x < MBC2_Tlo) ? x = 0 :
(x > MBC2_Thi) ? x = MBC2_slope * (x - MBC2_Threshold) :
(MBC2_delta = x - MBC2_Tlo;
x = MBC2_delta * MBC2_delta * MBC2_knee_factor;);
);


function MBC1_computeGain(x)
(
(x < MBC1_Tlo) ? x = 0 :
(x > MBC1_Thi) ? x = MBC1_slope * (x - MBC1_Threshold) :
(MBC1_delta = x - MBC1_Tlo;
x = MBC1_delta * MBC1_delta * MBC1_knee_factor;);
);



function MBC1_smoothAverage(x, MBC1_aplhaA, MBC1_aplhaER)
(
MBC1_eps = 0.0000000001;


/*
///////////////////////////////////////////////////////////////////////////////////// Attack gering interactive mit Rel, Rel ist linear
    rel_capacitor ? ( // wenn nicht linear sein soll
        cur_gr_R = min(x,  MBC1_aplhaER * cur_gr_r);// + (1 - MBC1_aplhaER) * x); 
        //entweder ist es: X = GR ohne smoothing
        //oder wenn er releasen sollte, quasi der letzte X * 0.999... + 0.001 * X -> Damit er s-förmig released
    ):(
        release_dB = 10; //dB Release per second = static release rate
        cur_gr_R = min(x, cur_gr_r + release_dB/srate);
    );
    
    // Capacitor für linearen Betrieb = 0: für release start nicht linear, dann 1ms später linear
    cur_gr_R == x ? rel_capacitor = 1 : rel_capacitor = max(rel_capacitor - (1)/(srate/1000), 0);
    
    rel_capacitor ? (
        cur_gr >= x ? cur_gr = x + MBC1_aplhaA * (cur_gr - x);
        cur_gr < x  ? cur_gr = x + MBC1_aplhaER * (cur_gr - x);
    ):(
        cur_gr += release_dB/srate;
    );
    //letzte Strecke schnell gen 0 :)
    //wenn man das braucht, braucht man den Capacitor wieder...
    MBC1_yA = cur_gr;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
auto = 0;
MBC1_knee = 85;
auto == 0 ? (

///////////////////////////////////////////////////////////////////////////////////// Attack interactive mit Rel, Rel ist linear
    //rel_capacitor ? ( // wenn nicht linear sein soll
    //    cur_gr_R = min(x,  MBC1_aplhaER * cur_gr_r);// + (1 - MBC1_aplhaER) * x); 
        //entweder ist es: X = GR ohne smoothing
        //oder wenn er releasen sollte, quasi der letzte X * 0.999... + 0.001 * X -> Damit er s-förmig released
    //):(
        release_dB = 19; //dB Release per second = static release rate
        cur_gr_R = min(x, cur_gr_r + release_dB/srate);
    //);
    
    // Capacitor für linearen Betrieb = 0: für release start nicht linear, dann 1ms später linear
    //cur_gr_R == x ? rel_capacitor = 1 : rel_capacitor = max(rel_capacitor - (1)/(srate/1000), 0);
    
    //rel_capacitor ? (
        cur_gr >= x ? cur_gr = x + MBC1_aplhaA * (cur_gr - x);
    //    cur_gr < x  ? cur_gr = x + MBC1_aplhaER * (cur_gr - x);
    //):(
        cur_gr < x  ? cur_gr += release_dB/srate;
    //);
    //letzte Strecke schnell gen 0 :)
    //wenn man das braucht, braucht man den Capacitor wieder...
    MBC1_yA = cur_gr;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

): auto == 1 ? (
/*
///////////////////////////////////////////////////////////////////////////////////// Attack umgekehrt interactive mit Rel, Rel ist exponentioell
//Hier bedingt der Attack den Release - oben ist es umgekehrt
    cur_gr_r = min(x, MBC1_aplhaER * cur_gr_r + (1 - MBC1_aplhaER) * x);
    cur_gr_r >= x ? cur_gr = MBC1_aplhaA * cur_gr + (1 - MBC1_aplhaA) * cur_gr_r;
    cur_gr_r < x ? cur_gr = x + MBC1_aplhaER * (cur_gr - x);
    MBC1_yA = cur_gr;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/
    //rel_capacitor ? ( // wenn nicht linear sein soll
    //    cur_gr_R = min(x,  MBC1_aplhaER * cur_gr_r);// + (1 - MBC1_aplhaER) * x); 
        //entweder ist es: X = GR ohne smoothing
        //oder wenn er releasen sollte, quasi der letzte X * 0.999... + 0.001 * X -> Damit er s-förmig released
    //):(
        
        cur_gr_R = min(x, cur_gr_r *MBC1_aplhaER);//+ release_dB/srate);
    //);
    
    // Capacitor für linearen Betrieb = 0: für release start nicht linear, dann 1ms später linear
    cur_gr_r >= x ? (rel_capacitor = 1; cur_gr_cap = abs(cur_gr)) : rel_capacitor = max(rel_capacitor - (1000 / (cur_gr_cap*2000) )/(srate), 0.1);//;*capacitor_load,0);
    release_dB = rel_capacitor > 0.8 ? 200 : 30; //dB Release per second = static release rate
    //rel_capacitor ? (
    MBC1_release = min(193, cur_gr_cap*5) /1000;//slider4/(1000*rel_capacitor);
    //MBC1_release = slider4/(1000*rel_capacitor);
    MBC1_aplhaER =  exp(-1 / (0.095 * srate));
    MBC1_aplhaERa = exp(-1 / (0.095 * srate));
    capacitor_load = exp(-1 / (1 * srate));
    //MBC1_attack = (slider3*abs(cur_gr^1))/(1000);
    //MBC1_aplhaA = MBC1_attack>0 ? exp(-1 / (MBC1_attack * srate)) : 0;
    
    
        cur_gr >= x ? cur_gr = x + (MBC1_aplhaA) * (cur_gr - x);
        
        rel_capacitor < 0.999 ? (
          cur_gr < x  ? cur_gr = x + MBC1_aplhaER * (cur_gr - x);
          //cur_gr < x  ? cur_gr += (100*rel_capacitor)/srate;//release_dB/srate;
        ):(
          cur_gr < x  ? cur_gr = x + MBC1_aplhaERa * (cur_gr - x);
        );
    //):(
        //
    //);
    //letzte Strecke schnell gen 0 :)
    //wenn man das braucht, braucht man den Capacitor wieder...
    MBC1_yA = cur_gr;


); //auto ?


);




function sigma (input, sigma_steep) local (tmp_x) (  // turns 0 - 1 into a sigma from 0 - 1
    tmp_x = 1/sigma_steep; // Sigma 1/x -> je größer X, desto weniger linear
    tmp_factor = 0.5 / ((0.5 * (tanh(((0.5))/tmp_x))));
     ((0.5 * (tanh(((input-0.5))/tmp_x)))*tmp_factor + 0.5);
);




//////////////////////////////////////// NOTIZEN 421 /////////////////////////////////
/*
Release 
Slot 6 = 20 dB/s
Slot 9 = 3 dB/s
Slot 10= 2.2 dB/s
*/
plugin.enh.band_init();
plugin.hpf.band_init();
SMOOTHING_TIME_MS = 2;

function MDX_Parameters_update(Thr_, Rat_, At_, Rel_, Out_, Auto_, Byp_, SC_, DryWet_, Enh_, gate_, fastrel_, hpf_) (



//eq(freq, q, boost, type);
this.freq_enh = 4000;
this.q_enh = 0.4;
this.boost_enh = enh_/6;//-(enh_/6)*20;

//this.enh.band_set_filter(4, this.freq_enh, 0, this.q_enh, 0);
this.hpf = hpf_;
this.hpf.band_set_filter(3, 250, -8, 0.6, 0);
this.hpf.filter.svf_set_to_target();

this.startpos =  1;
rat_ <= .5 ? this.cal_rat = this.startpos + (rat_+0.5)^3.5 * (1.8);
this.startpos = 2.8;
rat_ > .5 ? this.cal_rat = this.startpos + ((rat_-.5)*2)^3.4 * (40);


this.fastrel = fastrel_;


this.drymix = DryWet_; // in Percent

this.lim_Threshold = limiter_thr_ - 0.1;
this.lim_attack = 3 / 1000;
this.lim_aplhaA = exp(-1 / (this.lim_attack * srate));
this.lim_release_dB = 23;
this.Lim_aplhaER = exp(-1 / (0.05 * srate));

this.MBC1_Threshold = Thr_; //in dB
this.MBC1_ratio = this.cal_rat; //in N
this.MBC1_Knee = 30;//10+((this.MBC1_Threshold+43)/51)*70;//this.MBC1_Threshold < -20 ? 10 : 10 + (((this.MBC1_Threshold+20)/20)^0.6) * 30;; 

this.interacttive = slider13 ? (
this.MBC1k_ratio = rat_ <= 0.5 ? 1+ 1.1*(rat_^1.5) : 1.39 + 0.8*(((rat_-0.5)*2)^0.8);//((rat_ / 42.6)^0.48)*1.2; //Range 1 - 2.2
this.MBC1k_Threshold = this.MBC1_Threshold -11;


this.MBC1k_slope = ((1 - this.MBC1k_ratio) / this.MBC1k_ratio);
this.MBC1k_Knee = 0;//10+((this.MBC1_Threshold+43)/51)*50;//this.MBC1_Threshold < -20 ? 10 : 10 + (((this.MBC1_Threshold+20)/20)^0.6) * 30;; 
this.MBC1k_knee_width = abs(this.MBC1k_Threshold*2*this.MBC1k_Knee*0.01);

this.MBC1k_Tlo = (this.MBC1k_Threshold - this.MBC1k_knee_width / 2);
this.MBC1k_Thi = (this.MBC1k_Threshold + this.MBC1k_knee_width / 2);
this.MBC1k_knee_factor = (this.MBC1k_slope / (this.MBC1k_knee_width * 2));

this.mbc1_threshold += 11;
// this.mbc1_threshold += ((rat_)^1) * 2;
this.mbc1_ratio = rat_ <= 0.5 ? 1 + (rat_^0.5)*1.25 :rat_ <= 0.8 ? 1.8839 - (((rat_-0.5)*2)^0.05)*0.5 : 1.39651 + (((rat_-0.8)*5))*0.2;
this.MBC1_Knee = 100 - rat_*50;//10+((this.MBC1_Threshold+43)/51)*50;//this.MBC1_Threshold < -20 ? 10 : 10 + (((this.MBC1_Threshold+20)/20)^0.6) * 30;; 
);

this.MBC1_slope = ((1 - this.MBC1_ratio) / this.MBC1_ratio);
this.MBC1_knee_width = abs(this.MBC1_Threshold*2*this.MBC1_Knee*0.01);



this.MBC1_attack = At_/1000; // in ms
this.MBC1_release = Rel_; //in ms
this.release_dB = 40;
this.Auto = auto_;
this.Auto ? (
  this.MBC1_attack = 70/1000; // in ms    /////////////////////////////////////////////////////////// PRÜFEN PRÜFEN PRÜFEN
  this.MBC1_release = 25/1000; //in ms
);
this.MBC1_aplhaA = this.MBC1_attack>0 ? exp(-1 / (this.MBC1_attack * srate)) : 0;
this.MBC1_aplhaA2 = this.MBC1_attack>0 ? exp(-1 / (this.MBC1_attack*(26/(this.MBC1_attack*1000)) * srate)) : 0;
this.MBC1_aplhaER = this.MBC1_release>0 ? exp(-1 / (this.MBC1_release * srate)) : 0;
this.MBC1_aplhaERa =  exp(-1 / (0.1361 * srate));

this.MBC1_Tlo = (this.MBC1_Threshold - this.MBC1_knee_width / 2);
this.MBC1_Thi = (this.MBC1_Threshold + this.MBC1_knee_width / 2);
this.MBC1_knee_factor = (this.MBC1_slope / (this.MBC1_knee_width * 2));

this.MBC1_output = 10^(Out_/20); // in dB
this.MBC1_output_dB = Out_; // in dB

this.sidechain = SC_;
this.bypass = Byp_;
);





function MDX_sample (SideChainL_, SideChainR_) (

    this.sidechain ? (
    this.KeyL = SideChainL_;
    this.KeyR = SideChainR_;    
    ):(
    this.KeyL = spl0; // SCL.HPF_do(spl0);
    this.KeyR = spl1;//SCR.HPF_do(spl1); 
    );
    
    
    
    
    this.hpf ? (
    this.keyL = this.hpf.filter.svf_svf0(this.keyL);
    this.keyR = this.hpf.filter.svf_svf1(this.keyR);
    );
    
    
    this.MBC1_xL = max(abs(this.keyL),abs(this.KeyR));
    this.MBC1_xL += 0.0000001;
    this.MBC1_xL === 0 ? (this.MBC1_xL = db2ratio(-120));

    this.x =  this.xk = ratio2db(this.MBC1_xL);



(this.x < this.MBC1_Tlo) ? this.x = 0 :
(this.x > this.MBC1_Thi) ? this.x = this.MBC1_slope * (this.x - this.MBC1_Threshold) :
(this.MBC1_delta = this.x - this.MBC1_Tlo;
this.x = this.MBC1_delta * this.MBC1_delta * this.MBC1_knee_factor;);


/*
this.xk = this.xk - this.x;
*/

this.interacttive ? (
(this.xk < this.MBC1k_Tlo) ? this.xk = 0 :
(this.xk > this.MBC1k_Thi) ? this.xk = this.MBC1k_slope * (this.xk - this.MBC1k_Threshold) :
(this.MBC1k_delta = this.xk - this.MBC1k_Tlo;
this.xk = this.MBC1k_delta * this.MBC1k_delta * this.MBC1k_knee_factor;);
):(
this.xk = 0;
);

this.x = this.xk + this.x;
/*
*/

/*
this.x > this.MBC1k_Threshold ? this.x = this.MBC1k_slope * this.x - this.MBC1k_Threshold : this.x = 0;
this.x = this.x - this.mbc1k_threshold;
*/

/*
(this.x < this.MBC1_Tlo) ? this.x = 0 :
(this.x > this.MBC1_Thi) ? this.x = this.MBC1_slope * (this.x - this.MBC1_Threshold) :
(this.MBC1_delta = this.x - this.MBC1_Tlo;
this.x = this.MBC1_delta * this.MBC1_delta * this.MBC1_knee_factor;);
*/


this.x ? this.rel_capacitor = 1;


this.auto == 0 ? (
this.MBC1_eps = 0.0000000001;
this.cur_gr_r = min(this.x, this.MBC1_aplhaER * this.cur_gr_R + (1 - this.MBC1_aplhaER) * this.x + this.MBC1_eps - this.MBC1_eps);
this.cur_gr > this.x /1.5 ? this.cur_gr = this.MBC1_aplhaA * this.cur_gr + (1 - this.MBC1_aplhaA) * this.cur_gr_R + this.MBC1_eps - this.MBC1_eps;
this.cur_gr <= this.x  /1.5 ? this.cur_gr = this.MBC1_aplhaA2 * this.cur_gr + (1 - this.MBC1_aplhaA2) * this.cur_gr_R + this.MBC1_eps - this.MBC1_eps;
    
): this.auto == 1 ? (
this.MBC1_eps = 0.0000000001;
this.cur_gr >= -0.001 && this.at_capacitor == 0 ? this.at_capacitor = 1;
this.at_capacitor = max(0, this.at_capacitor + 16 * this.x / srate);
this.cur_gr_r = min(this.x, this.MBC1_aplhaER * this.cur_gr_R + (1 - this.MBC1_aplhaER) * this.x + this.MBC1_eps - this.MBC1_eps);
!this.at_capacitor ? (
//this.cur_gr > this.x /1.5 ? 
//this.rel_capacitor ? 
this.cur_gr = this.MBC1_aplhaA * this.cur_gr + (1 - this.MBC1_aplhaA) * this.cur_gr_R + this.MBC1_eps - this.MBC1_eps;
//!this.rel_capacitor ? 
this.x == 0 ? this.cur_gr = min(this.cur_gr + (this.release_db / max(1,abs(0.1*this.cur_gr)))/srate, 0 );
//this.cur_gr <= this.x  /1.5 ? this.cur_gr = this.MBC1_aplhaA2 * this.cur_gr + (1 - this.MBC1_aplhaA2) * this.cur_gr_R + this.MBC1_eps - this.MBC1_eps;
);
); //auto ?

this.actual_cur_gr = this.cur_gr;


this.rel_capacitor = max(this.rel_capacitor - 100/srate,0);

this.MBC1_cL = db2ratio(this.cur_gr);

spl0_in = spl0;
spl1_in = spl1;

this.Bypass == 1 ? (
this.MBC1_cL = 1;
):(
spl0 = ((((100-this.drymix)/100)*spl0)+((this.drymix/100)*spl0 * this.MBC1_cL)) * this.MBC1_output;
spl1 = ((((100-this.drymix)/100)*spl1)+((this.drymix/100)*spl1 * this.MBC1_cL)) * this.MBC1_output;

this.boost_enh ? (
//this.Left_Enh.eq(this.freq_enh, this.q_enh, -this.cur_gr * this.boost_enh, 2);
//this.Right_Enh.eq(this.freq_enh, this.q_enh, -this.cur_gr * this.boost_enh, 2);
//    spl0 = this.left_enh.eq_do(spl0);
//    spl0 = this.right_enh.eq_do(spl0);

this.enh.band_set_filter(4, this.freq_enh, -this.cur_gr * this.boost_enh * 0.8, this.q_enh, 0);
//this.enh.filter.svf_tick();
this.enh.filter.svf_set_to_target();
spl0 = this.enh.filter.svf_svf0(spl0);
spl1 = this.enh.filter.svf_svf1(spl1);

);


);



/*


//this.x + this.MBC1_output_dB;
this.lim_x = lim_x_db =  ratio2db(max(abs(spl0+0.0000001),abs(spl1+0.0000001)));
this.lim_x < this.lim_threshold ? this.lim_x = 0 : 
this.lim_x > this.lim_threshold ? this.lim_x = -1*(this.lim_x - this.lim_threshold);

this.lim_x != 0 ? this.lim_active = 1 : this.lim_active = 0;
this.lim_active ? this.gfx_lim_active = 1 : this.gfx_lim_active = max(0, this.gfx_lim_active - 2/srate);
//this.lim_active ? this.lim_cur_gr = this.lim_x + this.lim_aplhaA * (this.lim_cur_gr - this.lim_x);



this.lim_active ? (

this.capacitor = 1;
this.lim_x = lim_x_db =  ratio2db(max(abs(spl0_in+0.0000001),abs(spl1_in+0.0000001)));
this.lim_x = -1*(this.lim_x - this.lim_threshold);
);

//TARGET:
//this.actual_x = this.x + this.MBC1_output_dB + this.lim_x; 
this.actual_x = this.lim_active ? this.lim_x : this.x; 

//this.actual_x = min(this.cur_gr, this.lim_x );

this.auto == 0 ? (
        //Wenn Compressor GR täte, dann release, sonst übernimt limiter release
        this.cur_gr >= 0 ? this.actual_release_db = this.lim_release_db : this.actual_release_db = this.release_db;
        
        this.actual_cur_gr_R = min(this.actual_x, this.actual_cur_gr_r + this.actual_release_dB/srate);
        !this.lim_active ? this.actual_cur_gr >= this.actual_x ? this.actual_cur_gr = this.actual_x + this.MBC1_aplhaA * (this.actual_cur_gr - this.actual_x);
        this.lim_active ? this.actual_cur_gr >= this.actual_x ? this.actual_cur_gr = this.actual_x + this.Lim_aplhaA * (this.actual_cur_gr - this.actual_x);
        //this.actual_cur_gr >= this.actual_x ? this.actual_cur_gr = this.actual_cur_gr + (1-this.Lim_aplhaA) * (this.actual_x);
        this.capacitor = max(0, this.capacitor - 50/srate);
        !this.capacitor ? this.actual_cur_gr < this.actual_x  ? this.actual_cur_gr += this.actual_release_dB/srate;
        //this.actual_cur_gr < this.actual_x ? this.actual_cur_gr = this.actual_x + (this.lim_aplhaER) * (this.actual_cur_gr - this.actual_x);
        this.actual_cur_gr = min(this.actual_cur_gr , 0);
): this.auto == 1 ? (
//        this.actual_cur_gr_R = min(this.actual_x, this.actual_cur_gr_r * this.MBC1_aplhaER);
        !this.lim_active ? this.actual_cur_gr >= this.actual_x ? this.actual_cur_gr = this.actual_x + this.MBC1_aplhaA * (this.actual_cur_gr - this.actual_x);
        this.lim_active ? this.actual_cur_gr >= this.actual_x ? this.actual_cur_gr = this.actual_x + this.lim_aplhaA * (this.actual_cur_gr - this.actual_x);
        this.cur_gr > 0 ? (
          this.actual_cur_gr += this.lim_release_dB/srate;
        ):(
          this.actual_cur_gr < this.actual_x  ? this.actual_cur_gr = this.actual_x + this.MBC1_aplhaER * (this.actual_cur_gr - this.actual_x);
        );
); //auto ?

//this.cur_gr = this.actual_cur_gr - this.MBC1_output_db;;
//this.actual_cur_gr = this.cur_gr;
//!this.lim_active ? this.MBC1_cL = db2ratio(this.actual_cur_gr) * this.MBC1_output : 

this.MBC1_cL = db2ratio(this.actual_cur_gr);
spl0_in = spl0_in * this.MBC1_output;
spl1_in = spl1_in * this.MBC1_output;

this.Bypass == 1 ? (
this.MBC1_cL = 1;
):(
katze = 0;
spl0 = ((((100-this.drymix)/100)*spl0_in)+((this.drymix/100)*spl0_in * this.MBC1_cL));
spl1 = ((((100-this.drymix)/100)*spl1_in)+((this.drymix/100)*spl1_in * this.MBC1_cL));


this.lim_active ? (
 this.clipper_a = 1.017;
 this.clipper_b = -0.025;
 this.amp_db = 8.6562;
 
 this.dB0 = this.amp_dB * log(abs(spl0))+0.0000001;// + boost_dB;
 this.dB1 = this.amp_dB * log(abs(spl1))+0.0000001;// + boost_dB;
 
  (this.dB0 > this.lim_threshold + 4.5) ? (
    this.over_dB = this.dB0 - (this.lim_threshold + 3);
    this.over_db_L = this.over_db;
    this.over_dB = this.clipper_a * this.over_dB + this.clipper_b * this.over_dB * this.over_dB;
    //dB0 = min(threshold_dB + over_dB, limit_dB);
    this.dB0 = (this.lim_threshold + 4.5) + over_dB;
  ):(this.over_db_L = 0);
  
  (this.dB1 > this.lim_threshold + 4.5) ? (
    this.over_dB = this.dB1 - (this.lim_threshold + 3);
    this.over_db_R = this.over_db;
    this.over_dB = this.clipper_a * this.over_dB + this.clipper_b * this.over_dB * this.over_dB;
    //dB1 = min(threshold_dB + over_dB, limit_dB);
    this.dB1 = (this.lim_threshold + 4.5) + this.over_dB;
  ):(this.over_db_R = 0);
  
  spl0 = exp(this.dB0 / this.amp_dB) * sign(spl0);
  spl1 = exp(this.dB1 / this.amp_dB) * sign(spl1);
);

  
);


*/
); // End Function DL24_Sample






function MDX_Gate_sample (SideChainL_ , SideChainR_) (
    
    this.sidechain ? (
    this.KeyL = SideChainL_;
    this.KeyR = SideChainR_;    
    ):(
    this.KeyL = spl0; // SCL.HPF_do(spl0);
    this.KeyR = spl1;//SCR.HPF_do(spl1); 
    );
    
    this.key = max(
                    max(abs(this.keyL),abs(this.KeyR))    ,
                    this.key * db2ratio(-(60/this.release_samples2))  ); 
    
    katze2 = (0.7 ^ (1+(1-this.exp_release)));
    
    this.Key >= this.g_threshold ? (this.gate_phase = 1);
    this.gate_phase == 1 ? (
    this.holding = 0;
    this.gate_gain = min(this.gate_gain + 1/this.attack_samples, 1);
    this.gate_gain >= 1 ? this.gate_phase = 2;
    );
    
    this.gate_phase == 2 ? (
      this.holding = 0;
      this.key < this.g_threshold ? (
        this.gate_phase = 3;
      );
    );
    
    this.gate_phase == 3 ? (
    this.key >= this.g_threshold ? (
      this.gate_phase = 2;
    );
    this.holding += 1;
    this.holding >= this.hold ? (this.gate_phase = 4);
    );
    
    
    this.gate_phase == 4 ? (
    this.holding = 0;
    this.gate_gain = max(this.gate_gain * db2ratio(-(60/this.release_samples)), 0);
    this.gate_gain <= db2ratio(-240) ? this.gate_phase = 0;
    );
    

    this.exp_det = this.key;
    this.exp_det += 0.000000000001;
    this.exp_env = this.exp_det >= this.exp_env ? this.exp_det : this.exp_det+this.exp_exp_envelope_decay*(this.exp_env-this.exp_det);
    this.transfer_exp_gain = this.exp_env < this.g_threshold ? pow(this.exp_env,this.transfer_A)*this.transfer_B:1;
    this.exp_gain = this.transfer_exp_gain > this.exp_gain ? this.transfer_exp_gain+this.exp_attack*(this.exp_gain-this.transfer_exp_gain) : this.transfer_exp_gain+this.exp_release*(this.exp_gain-this.transfer_exp_gain);
    
    this.exp_gain = max(this.exp_gain,0);
    
    this.result_gain = max(this.gate_gain, this.exp_gain);
    
    spl0 *= this.result_gain;
    spl1 *= this.result_gain;
); // end function gate



function MDX_Gate_parameters_update (Thr_, long_) (


  this.exp_exp_envelope_decay = exp(-1/(10/1000*srate));
  this.exp_attack = exp(-1/(15/1000*srate));
  this.exp_release = exp(-1/(50/1000*srate));
  this.exp_exp_envelope_decay = exp(-1/(10/1000*srate));


  //long_ == 0 ? this.hold = 250 *0.001*srate;
  //long_ == 1 ? this.hold = 550 *0.001*srate;
  this.hold = 0;
  this.expander_factor = 4;
  long_ == 0 ? this.attack_samples = 3 * 0.001*srate;
  long_ == 1 ? this.attack_samples = 1.5 * 0.001*srate;
  long_ == 0 ? this.release_samples = 1900 * 0.001*srate;
  long_ == 1 ? this.release_samples = 4500 * 0.001*srate;
  long_ == 0 ? this.release_samples2 = 190 * 0.001*srate;
  long_ == 1 ? this.release_samples2 = 600 * 0.001*srate;
  long_ == 0 ? this.g_threshold = db2ratio(Thr_);
  long_ == 1 ? this.g_threshold = db2ratio(Thr_-3);
  //gateThresh = slider1;
  //hysteresis = db2ratio(slider2);
  //gateHyst = slider2;
  this.transfer_A = (this.expander_factor)-1;
  this.transfer_B = pow(this.g_threshold,-this.transfer_A);

);




//this.sidechain // SC ON/OFF
//this.MBC1_Threshold
//this.Auto
//this.Bypass
//this.DryMix
//this.MBC1_Output
//Berechnen:
//this.release_dB

//Prüfen:
//Attack für Auto
// Reklease Auto ist MBC1_aplhaER =  exp(-1 / (0.095 * srate));


function DL24_Parameters_update(Thr_, Rat_, At_, Rel_, Out_, Auto_, Byp_, SC_, DryWet_, limit_, gate_, fastrel_, limiter_thr_) (


this.fastrel = fastrel_;


this.drymix = DryWet_; // in Percent

this.lim_Threshold = limiter_thr_ - 0.1;
this.lim_attack = 3 / 1000;
this.lim_aplhaA = exp(-1 / (this.lim_attack * srate));
this.lim_release_dB = 23;
this.Lim_aplhaER = exp(-1 / (0.05 * srate));

this.MBC1_Threshold = Thr_; //in dB
this.MBC1_ratio = Rat_; //in N
this.MBC1_slope = ((1 - this.MBC1_ratio) / this.MBC1_ratio);
this.MBC1_Knee = 85; 
this.MBC1_knee_width = abs(this.MBC1_Threshold*2*this.MBC1_Knee*0.01);

this.MBC1_attack = At_/1000; // in ms
this.MBC1_release = Rel_/1000; //in ms
this.release_dB = (1/Rel_) * 10;
this.Auto = auto_;
this.Auto ? (
  this.MBC1_attack = 10/1000; // in ms    /////////////////////////////////////////////////////////// PRÜFEN PRÜFEN PRÜFEN
  this.MBC1_release = 95/1000; //in ms
);
this.MBC1_aplhaA = this.MBC1_attack>0 ? exp(-1 / (this.MBC1_attack * srate)) : 0;
this.MBC1_aplhaER = this.MBC1_release>0 ? exp(-1 / (this.MBC1_release * srate)) : 0;

this.MBC1_Tlo = (this.MBC1_Threshold - this.MBC1_knee_width / 2);
this.MBC1_Thi = (this.MBC1_Threshold + this.MBC1_knee_width / 2);
this.MBC1_knee_factor = (this.MBC1_slope / (this.MBC1_knee_width * 2));

this.MBC1_output = 10^(Out_/20); // in dB
this.MBC1_output_dB = Out_; // in dB

this.sidechain = SC_;
this.bypass = Byp_;
);






function DL24_sample (SideChainL_, SideChainR_) (

    this.sidechain ? (
    this.KeyL = SideChainL;
    this.KeyR = SideChainR;    
    ):(
    this.KeyL = spl0; // SCL.HPF_do(spl0);
    this.KeyR = spl1;//SCR.HPF_do(spl1); 
    );
    this.MBC1_xL = max(abs(this.keyL),abs(this.KeyR));
    this.MBC1_xL += 0.0000001;
    this.MBC1_xL === 0 ? (this.MBC1_xL = db2ratio(-120));

    this.x = ratio2db(this.MBC1_xL);

    

(this.x < this.MBC1_Tlo) ? this.x = 0 :
(this.x > this.MBC1_Thi) ? this.x = this.MBC1_slope * (this.x - this.MBC1_Threshold) :
(this.MBC1_delta = this.x - this.MBC1_Tlo;
this.x = this.MBC1_delta * this.MBC1_delta * this.MBC1_knee_factor;);




this.auto == 0 ? (
        this.cur_gr_R = min(this.x, this.cur_gr_r + this.release_dB/srate);
        this.cur_gr >= this.x ? this.cur_gr = this.x + this.MBC1_aplhaA * (this.cur_gr - this.x);
        this.cur_gr < this.x  ? this.cur_gr += this.release_dB/srate;
): this.auto == 1 ? (
        this.cur_gr_R = min(this.x, this.cur_gr_r * this.MBC1_aplhaER);
        this.cur_gr >= this.x ? this.cur_gr = this.x + this.MBC1_aplhaA * (this.cur_gr - this.x);
        this.cur_gr < this.x  ? this.cur_gr = this.x + this.MBC1_aplhaER * (this.cur_gr - this.x);
); //auto ?

this.MBC1_cL = db2ratio(this.cur_gr);

spl0_in = spl0;
spl1_in = spl1;

this.Bypass == 1 ? (
this.MBC1_cL = 1;
):(
spl0 = ((((100-this.drymix)/100)*spl0)+((this.drymix/100)*spl0 * this.MBC1_cL)) * this.MBC1_output;
spl1 = ((((100-this.drymix)/100)*spl1)+((this.drymix/100)*spl1 * this.MBC1_cL)) * this.MBC1_output;
);




//this.x + this.MBC1_output_dB;
this.lim_x = lim_x_db =  ratio2db(max(abs(spl0+0.0000001),abs(spl1+0.0000001)));
this.lim_x < this.lim_threshold ? this.lim_x = 0 : 
this.lim_x > this.lim_threshold ? this.lim_x = -1*(this.lim_x - this.lim_threshold);

this.lim_x != 0 ? this.lim_active = 1 : this.lim_active = 0;
this.lim_active ? this.gfx_lim_active = 1 : this.gfx_lim_active = max(0, this.gfx_lim_active - 2/srate);
//this.lim_active ? this.lim_cur_gr = this.lim_x + this.lim_aplhaA * (this.lim_cur_gr - this.lim_x);



this.lim_active ? (

this.capacitor = 1;
this.lim_x = lim_x_db =  ratio2db(max(abs(spl0_in+0.0000001),abs(spl1_in+0.0000001)));
this.lim_x = -1*(this.lim_x - this.lim_threshold);
);

//TARGET:
//this.actual_x = this.x + this.MBC1_output_dB + this.lim_x; 
this.actual_x = this.lim_active ? this.lim_x : this.x; 

//this.actual_x = min(this.cur_gr, this.lim_x );

this.auto == 0 ? (
        //Wenn Compressor GR täte, dann release, sonst übernimt limiter release
        this.cur_gr >= 0 ? this.actual_release_db = this.lim_release_db : this.actual_release_db = this.release_db;
        
        this.actual_cur_gr_R = min(this.actual_x, this.actual_cur_gr_r + this.actual_release_dB/srate);
        !this.lim_active ? this.actual_cur_gr >= this.actual_x ? this.actual_cur_gr = this.actual_x + this.MBC1_aplhaA * (this.actual_cur_gr - this.actual_x);
        this.lim_active ? this.actual_cur_gr >= this.actual_x ? this.actual_cur_gr = this.actual_x + this.Lim_aplhaA * (this.actual_cur_gr - this.actual_x);
        //this.actual_cur_gr >= this.actual_x ? this.actual_cur_gr = this.actual_cur_gr + (1-this.Lim_aplhaA) * (this.actual_x);
        this.capacitor = max(0, this.capacitor - 50/srate);
        !this.capacitor ? this.actual_cur_gr < this.actual_x  ? this.actual_cur_gr += this.actual_release_dB/srate;
        //this.actual_cur_gr < this.actual_x ? this.actual_cur_gr = this.actual_x + (this.lim_aplhaER) * (this.actual_cur_gr - this.actual_x);
        this.actual_cur_gr = min(this.actual_cur_gr , 0);
): this.auto == 1 ? (
//        this.actual_cur_gr_R = min(this.actual_x, this.actual_cur_gr_r * this.MBC1_aplhaER);
        !this.lim_active ? this.actual_cur_gr >= this.actual_x ? this.actual_cur_gr = this.actual_x + this.MBC1_aplhaA * (this.actual_cur_gr - this.actual_x);
        this.lim_active ? this.actual_cur_gr >= this.actual_x ? this.actual_cur_gr = this.actual_x + this.lim_aplhaA * (this.actual_cur_gr - this.actual_x);
        this.cur_gr > 0 ? (
          this.actual_cur_gr += this.lim_release_dB/srate;
        ):(
          this.actual_cur_gr < this.actual_x  ? this.actual_cur_gr = this.actual_x + this.MBC1_aplhaER * (this.actual_cur_gr - this.actual_x);
        );
); //auto ?

//this.cur_gr = this.actual_cur_gr - this.MBC1_output_db;;
//this.actual_cur_gr = this.cur_gr;
//!this.lim_active ? this.MBC1_cL = db2ratio(this.actual_cur_gr) * this.MBC1_output : 

this.MBC1_cL = db2ratio(this.actual_cur_gr);
spl0_in = spl0_in * this.MBC1_output;
spl1_in = spl1_in * this.MBC1_output;

this.Bypass == 1 ? (
this.MBC1_cL = 1;
):(
katze = 0;
spl0 = ((((100-this.drymix)/100)*spl0_in)+((this.drymix/100)*spl0_in * this.MBC1_cL));
spl1 = ((((100-this.drymix)/100)*spl1_in)+((this.drymix/100)*spl1_in * this.MBC1_cL));


this.lim_active ? (
 this.clipper_a = 1.017;
 this.clipper_b = -0.025;
 this.amp_db = 8.6562;
 
 this.dB0 = this.amp_dB * log(abs(spl0))+0.0000001;// + boost_dB;
 this.dB1 = this.amp_dB * log(abs(spl1))+0.0000001;// + boost_dB;
 
  (this.dB0 > this.lim_threshold + 4.5) ? (
    this.over_dB = this.dB0 - (this.lim_threshold + 3);
    this.over_db_L = this.over_db;
    this.over_dB = this.clipper_a * this.over_dB + this.clipper_b * this.over_dB * this.over_dB;
    //dB0 = min(threshold_dB + over_dB, limit_dB);
    this.dB0 = (this.lim_threshold + 4.5) + over_dB;
  ):(this.over_db_L = 0);
  
  (this.dB1 > this.lim_threshold + 4.5) ? (
    this.over_dB = this.dB1 - (this.lim_threshold + 3);
    this.over_db_R = this.over_db;
    this.over_dB = this.clipper_a * this.over_dB + this.clipper_b * this.over_dB * this.over_dB;
    //dB1 = min(threshold_dB + over_dB, limit_dB);
    this.dB1 = (this.lim_threshold + 4.5) + this.over_dB;
  ):(this.over_db_R = 0);
  
  spl0 = exp(this.dB0 / this.amp_dB) * sign(spl0);
  spl1 = exp(this.dB1 / this.amp_dB) * sign(spl1);
);


  
);



); // End Function DL24_Sample






function DL24_Limiter_Parameters_update(Thr_, Byp_) (


this.drymix = 100; // in Percent

this.MBC1_Threshold = Thr_; //in dB
this.MBC1_ratio = 10000; //in N
this.MBC1_slope = ((1 - this.MBC1_ratio) / this.MBC1_ratio);
this.MBC1_Knee = 0; 
this.MBC1_knee_width = abs(this.MBC1_Threshold*2*this.MBC1_Knee*0.01);

this.MBC1_attack = 0.1/1000; // in ms
this.MBC1_release = 500/1000; //in ms
this.release_dB = 21;

this.MBC1_aplhaA = this.MBC1_attack>0 ? exp(-1 / (this.MBC1_attack * srate)) : 0;
this.MBC1_aplhaER = this.MBC1_release>0 ? exp(-1 / (this.MBC1_release * srate)) : 0;

this.MBC1_Tlo = (this.MBC1_Threshold - this.MBC1_knee_width / 2);
this.MBC1_Thi = (this.MBC1_Threshold + this.MBC1_knee_width / 2);
this.MBC1_knee_factor = (this.MBC1_slope / (this.MBC1_knee_width * 2));

this.MBC1_output = 1;//10^(Out_/20); // in dB

this.sidechain = 0;
this.bypass = Byp_;
);





/*
MBC1_gr_meter = 1;
MBC1_gr_meter_decay = exp(1/(0.3*srate));



MBC2_yR = 0;
MBC2_yA = 0;

function MBC2_computeGain(x)
(
(x < MBC2_Tlo) ? x = 0 :
(x > MBC2_Thi) ? x = MBC2_slope * (x - MBC2_Threshold) :
(MBC2_delta = x - MBC2_Tlo;
x = MBC2_delta * MBC2_delta * MBC2_knee_factor;);
);

function MBC2_smoothAverage(x, MBC2_aplhaA, MBC2_aplhaER)
(
MBC2_eps = 0.0000000001;
MBC2_yR = min(x, MBC2_aplhaER * MBC2_yR + (1 - MBC2_aplhaER) * x + MBC2_eps - MBC2_eps);
MBC2_yA = MBC2_aplhaA * MBC2_yA + (1 - MBC2_aplhaA) * MBC2_yR + MBC2_eps - MBC2_eps;
x = MBC2_yA;
);

MBC2_gr_meter = 1;
MBC2_gr_meter_decay = exp(1/(0.3*srate));

*/

//size = 6000;

parameters_update_on = 0;
function parameters_update () (
parameters_update_on = 1;


/*
old_w=0;


KThreshold.Parameter_Boundaries();
//KRatio.Parameter_Boundaries();
KAttack.Parameter_Boundaries();
//KRelease.Parameter_Boundaries();
KHPF.Parameter_Boundaries();
KKnee.Parameter_Boundaries();
KOutput.Parameter_Boundaries();
KDrywet.Parameter_Boundaries();

 group_generics[1] = SCOPE;
 group_generics[2] = in_SCOPE;
 group_generics[3] = out_SCOPE;
 group_generics[4] = gr_scope;

    group_parameters();
  Scope = group_generics[1];
 in_SCOPE = group_generics[2];
 out_SCOPE = group_generics[3];
 gr_scope = group_generics[4];  

  
mode = 0;
drymix = slider9;

MBC1_Threshold = slider1;
MBC1_knee_width = abs(slider1*2*slider5*0.01);
MBC1_Knee = slider5; 
MBC1_ratio = slider2;
MBC1_slope = ((1 - MBC1_ratio) / MBC1_ratio);

MBC1_attack = slider3/1000;
MBC1_release = slider4/1000;
MBC1_aplhaA = MBC1_attack>0 ? exp(-1 / (MBC1_attack * srate)) : 0;
MBC1_aplhaER = MBC1_release>0 ? exp(-1 / (MBC1_release * srate)) : 0;

MBC1_Tlo = (MBC1_Threshold - MBC1_knee_width / 2);
MBC1_Thi = (MBC1_Threshold + MBC1_knee_width / 2);
MBC1_knee_factor = (MBC1_slope / (MBC1_knee_width * 2));

MBC1_output = 10^(slider6/20);
MBC1_on = 1;

sidechain = slider8;
trick = slider10;
bypass = slider11;

rms_window = 50/1000*srate;

  scFreq = slider7;
  SCL.HPF_Config (scFreq);
  SCR.HPF_Config (scFreq);


emptyscope == 1 ? (
histpos = 0;
loop(histsize,
histbuf[histpos] = 0;
histbuf[histpos+histsize] = 0;
histbuf[histpos+histsize+histsize] = 0;
histbuf[histpos+histsize+histsize+histsize] = 0;
histpos += 1;
);
histpos = 0;
emptyscope = 0;
);
*/

Notiz1_Knob.parameter_boundaries();
Notiz2_Knob.parameter_boundaries();
Notiz3_Knob.parameter_boundaries();
Notiz4_Knob.parameter_boundaries();
Notiz5_Knob.parameter_boundaries();
Notiz6_Knob.parameter_boundaries();
Notiz7_Knob.parameter_boundaries();

group_parameters();



slider5 > 0.5 ? cal_Thr_lim = -15 + (slider5^0.585)*15;
slider5 <= 0.5 ? cal_Thr_lim = -15 + (slider5)*20;

cal_thr = -43+(((slider1+40)/60)^1.05)*55;//*60*(42.5/50);
my_rat = slider2;

Cal_at = 0.1 + (slider3)^2  * 37;
slider4 <= 0.5 ? Cal_rel = 0.01 + (slider4)^1.059  * 0.18;
slider4 > 0.5 ? Cal_rel = 0.096394 + ((slider4-0.5)*2)^1.259  * 0.77;


cal_out = slider6;

slider7 <= 0.4 ? cal_gate_thr = -82 +slider7*10 *10 :
slider7 <= 0.5 ? cal_gate_thr = -42 + ((slider7-0.4)*10 *6) :
slider7 <= 0.8 ? cal_gate_thr = -36 + ((slider7-0.5)*10 *5) :
cal_gate_thr = -21 + ((slider7-0.8)*10 *7);
slider7 ? gate_on = 1 : gate_on = 0;


slider15 ? (
cal_thr = slider1;
slider7 <= 0.5 ? cal_gate_thr = -80 + ((((slider7)*2)^0.8) *60) :
cal_gate_thr = -20 + ((slider7-0.5)*2 *30);
);

//Plugin.DL24_Parameters_update(cal_Thr, Cal_Rat, Cal_At, Cal_Rel, Cal_Out, slider10, slider11, slider8, 100, 0,0, slider12, cal_Thr_lim);
Plugin.MDX_Parameters_update(cal_Thr, my_Rat, Cal_At, Cal_Rel, Cal_Out, slider10, slider11, slider8, 100, slider5,0, slider12, slider14);

Plugin.MDX_Gate_parameters_update(cal_gate_thr, slider12);
//Plugin_Lim.DL24_Limiter_Parameters_update(cal_Thr_Lim, slider11);


caller = 0;
parameters_update_on = 0;
);



@slider
  parameters_update_on == 0 ? (
    parameters_update();
  ):(
    caller = 1;
  );









@serialize
file_var(0, while_playing);
file_var(0, while_recording);
file_var(0, while_stopped);
file_var(0, link_group);
file_var(0, SILVER_COMPRESSOR_VERSION);

seriloop = 0;
loop(64*16 + 27 + 16,
file_var(0, gmem[seriloop]);
seriloop += 1;
);

seriloop = 0;
loop(200*16,
file_var(0, group_generics[seriloop]);
seriloop += 1;
);













@sample



//histsize_out = sgfx_w;// * 10;
//histsize_block = histsize / histsize_out;



//Left_Meter_In.feed_Meter(spl0); //in_spl, Fallback in dB/s
//Right_Meter_In.feed_Meter(spl1);

gmem[16*64 + 10 + link_group] != 1 ? link_group = 0;
group_check_smpl();
caller == 1 ? (
  parameters_update_on == 0 ? (
    parameters_update();
  );
);


playstates();

process = 0;
while_playing ? is_playing ? process = 1;
while_recording ? is_recording ? process = 1;
while_stopped ? is_stopped ? process = 1;
Plugin.bypass ? process = 0;


process == 1 ? (

/*

mode == 2 ? (
vspl0 = (spl0+spl1)/2;
vspl1 = (spl0-spl1)/2;
spl0 = vspl0;
spl1 = vspl1;

vspl2 = (spl2+spl3)/2;
vspl3 = (spl2-spl3)/2;
spl2 = vspl2;
spl3 = vspl3;
);

hist_in_L[histpos] = max(abs(spl0),hist_in_L[histpos]);
hist_in_r[histpos] = max(abs(spl1),hist_in_R[histpos]);


g_max_u_L=abs(spl0);
ratio2db(g_max_u_L) > db_g_max_u_L ? (
db_g_max_u_L = ratio2db(g_max_u_L);
):(
db_g_max_u_L -= meter_fallback/srate; // db pro sec
);
db_g_max_u_L_hold = max(db_g_max_u_L_hold,db_g_max_u_L);

g_max_u_R=abs(spl1);
ratio2db(g_max_u_R) > db_g_max_u_R ? (
db_g_max_u_R = ratio2db(g_max_u_R);
):(
db_g_max_u_R -= meter_fallback/srate; // db pro sec
);
db_g_max_u_R_hold = max(db_g_max_u_R_hold,db_g_max_u_R);






///////////////// IN DIESER VERSION SPIELT NUR DIESE SCHLEIFE !!!



mode == 0 ? (
MBC1_inL = spl0;
MBC1_inR = spl1;

    sidechain ? (
    KeyL = SCL.HPF_do(spl2);
    KeyR = SCR.HPF_do(spl3);    
    ):(
    KeyL = SCL.HPF_do(spl0); // SCL.HPF_do(spl0);
    KeyR = SCR.HPF_do(spl1);//SCR.HPF_do(spl1); 
    );
    MBC1_xL = max(abs(keyL),abs(KeyR));
    MBC1_xL += 0.0000001;
    MBC1_xL === 0 ? (MBC1_xL = db2ratio(-120));


MBC1_xG = ratio2db(MBC1_xL);
MBC1_yG = MBC1_computeGain(MBC1_xG);
//MBC1_yG_min = min(MBC1_yG_min, MBC1_yG); MBC1_yG_min < -10 ? MBC1_yG_min = 0;
//MBC1_aplhaA = MBC1_attack>0 ? exp(-1 / ((max(abs(MBC1_yG)/10, .001)*MBC1_attack * srate))) : 0; // --------- 16. ist der speed-factor ;)
MBC1_cG = MBC1_smoothAverage(MBC1_yG, MBC1_aplhaA, MBC1_aplhaER);
MBC1_cL = db2ratio(MBC1_cG);

Bypass == 1 ? (
MBC1_cL = 1;
):(
trick == 0 ? (
spl0 = ((((100-drymix)/100)*spl0)+((drymix/100)*spl0 * MBC1_cL)) * MBC1_output;
spl1 = ((((100-drymix)/100)*spl1)+((drymix/100)*spl1 * MBC1_cL)) * MBC1_output;
):(
spl0 = ((((100-drymix)/100)*spl0)+(spl0+((drymix/100)*-spl0 * MBC1_cL))) * MBC1_output;
spl1 = ((((100-drymix)/100)*spl1)+(spl1+((drymix/100)*-spl1 * MBC1_cL))) * MBC1_output;
);
);


ext_gr_meter = ratio2db(MBC1_cL);

MBC1_gr = db2ratio(MBC1_cL);
MBC1_grv = ratio2db(MBC1_gr);
MBC1_grv < MBC1_gr_meter ? MBC1_gr_meter=MBC1_grv : (MBC1_gr_meter*=MBC1_gr_meter_decay; MBC1_gr_meter>1?MBC1_gr_meter=1; );
MBC1_grmin = min( min(MBC1_cG,MBC1_cG) , MBC1_grmin);
MBC1_on == 0 ? (MBC1_gr_meter=1);
//histbuf[histpos+histsize+histsize]=MBC1_cL;

h


///////////////// IN DIESER VERSION SPIELT NUR DIESE SCHLEIFE !!!


















):( // MODE = Nicht stereo
MBC1_inL = spl0;
MBC1_inR = spl0;

slider29 == 0 ? (
MBC1_xL = abs(MBC1_inL);
):(
MBC1_xL = abs(spl2);
);
MBC1_xL === 0 ? (MBC1_xL = db2ratio(-120));
MBC1_xG = ratio2db(MBC1_xL);
MBC1_yG = MBC1_computeGain(MBC1_xG);
MBC1_cG = MBC1_smoothAverage(MBC1_yG, MBC1_aplhaA, MBC1_aplhaER);
MBC1_cL = db2ratio(MBC1_cG);

MBC1_on == 1 ? (
spl0 = MBC1_inL * MBC1_cL;// * MBC1_output;
):(
spl0 = MBC1_inL;
);


MBC1_gr = db2ratio(MBC1_cL);
MBC1_grv = ratio2db(MBC1_gr);
MBC1_grv < MBC1_gr_meter ? MBC1_gr_meter=MBC1_grv : ( MBC1_gr_meter*=MBC1_gr_meter_decay; MBC1_gr_meter>1?MBC1_gr_meter=1; );
MBC1_grmin = min( min(MBC1_cG,MBC1_cG) , MBC1_grmin);
MBC1_on == 0 ? (MBC1_gr_meter=1);
histbuf[histpos+histsize+histsize]=MBC1_cL;


MBC2_inL = spl1;
MBC2_inR = spl1;

//MBC2_xL = max(abs(MBC2_inL),abs(MBC2_inR));
slider29 == 0 ? (
MBC2_xL = abs(MBC2_inL);
):(
MBC2_xL = abs(spl3);
);

MBC2_xL === 0 ? (MBC2_xL = db2ratio(-120));
MBC2_xG = ratio2db(MBC2_xL);
MBC2_yG = MBC2_computeGain(MBC2_xG);
MBC2_cG = MBC2_smoothAverage(MBC2_yG, MBC2_aplhaA, MBC2_aplhaER);
MBC2_cL = db2ratio(MBC2_cG);

MBC2_on == 1 ? (
spl1 = MBC2_inL * MBC2_cL;// * MBC2_output;
):(
spl1 = MBC2_inL;
);


MBC2_gr = db2ratio(MBC2_cL);
MBC2_grv = ratio2db(MBC2_gr);
MBC2_grv < MBC2_gr_meter ? MBC2_gr_meter=MBC2_grv : ( MBC2_gr_meter*=MBC2_gr_meter_decay; MBC2_gr_meter>1?MBC2_gr_meter=1; );
MBC2_grmin = min( min(MBC2_cG,MBC2_cG) , MBC2_grmin);
MBC2_on == 0 ? (MBC2_gr_meter=1);

histbuf[histpos+histsize+histsize+histsize]=MBC2_cL;


spl0 *= MBC1_output;
spl1 *= MBC2_output;
);




//histpos+=1;
//histpos >= histsize ? histpos=0;



mode == 2 ? (
vspl0 = spl0 + spl1;
vspl1 = spl0 - spl1;
spl0 = vspl0;
spl1 = vspl1;
);




g_max_u_L_out=abs(spl0);
ratio2db(g_max_u_L_out) > db_g_max_u_L_out ? (
db_g_max_u_L_out = ratio2db(g_max_u_L_out);
):(
db_g_max_u_L_out -= meter_fallback/srate; // db pro sec
);
db_g_max_u_L_hold_out = max(db_g_max_u_L_hold_out,db_g_max_u_L_out);

g_max_u_R_out=abs(spl1);
ratio2db(g_max_u_R_out) > db_g_max_u_R_out ? (
db_g_max_u_R_out = ratio2db(g_max_u_R_out);
):(
db_g_max_u_R_out -= meter_fallback/srate; // db pro sec
);
db_g_max_u_R_hold_out = max(db_g_max_u_R_hold_out,db_g_max_u_R_out);

*/
gate_on && !Plugin.bypass ? Plugin.MDX_Gate_sample(spl2, spl3);
Plugin.MDX_sample(spl2, spl3);

ext_gr_meter = plugin.cur_gr;
):( //Process ?
ext_gr_meter = 0;
);


iometer = max(-100,max(ratio2db(max(abs(spl0),abs(spl1))) ,  iometer - 100/srate));
//iometer = ins_out_meter;
slider15 == 0 ? ins_out_meter = iometer + 7 : ins_out_meter = iometer;

ins_GR_meter = min(0,min(plugin.actual_cur_gr  ,  ins_GR_meter + 100/srate));

/*
GR_Meter.feed_Meter_GR(MBC1_cL);

Left_Meter_Out.feed_Meter(spl0);
Right_Meter_Out.feed_Meter(spl1);

hist_out_L[histpos] = max(abs(spl0),hist_out_L[histpos]);
hist_out_r[histpos] = max(abs(spl1),hist_out_r[histpos]);
hist_GR[histpos] = min(MBC1_cL,hist_GR[histpos]);
block_pos += 1;
block_pos >= histsize_block ? (
histpos+=1;
block_pos = 0;
histpos >= histsize_out ? histpos=0;
hist_out_L[histpos] = hist_out_R[histpos] = hist_in_L[histpos] = hist_in_R[histpos] = 0;
hist_GR[histpos] = 1;
);
*/





















@gfx 929 245

 mouseHold = mouse_cap & 1;
 press_superkey = mouse_cap & 32;
 press_ctrl = mouse_cap & 4;
 press_shift = mouse_cap & 8;
 press_alt = mouse_cap & 16;
 superkey=ctrl=shift=alt=shift_alt=shift_ctrl=shift_superkey=ctrl_superkey = 0;
 press_superkey ? !press_ctrl ? !press_shift ? !press_alt ? superkey=press_superkey;
 !press_superkey ? press_ctrl ? !press_shift ? !press_alt ? ctrl=press_ctrl;
 !press_superkey ? !press_ctrl ? press_shift ? !press_alt ? shift=press_shift;
 !press_superkey ? !press_ctrl ? !press_shift ? press_alt ? alt=press_alt;
 !press_superkey ? !press_ctrl ? press_shift ? press_alt ? shift_alt=1;
 !press_superkey ? press_ctrl ? press_shift ? !press_alt ? shift_ctrl=1;
 press_superkey ? !press_ctrl ? press_shift ? !press_alt ? shift_superkey=1;
 press_superkey ? press_ctrl ? !press_shift ? !press_alt ? ctrl_superkey=1;
 
 mouseClick = mouseHold - lastCap;
 lastCap = mouseHold;
 
 function dot (winkel) (
 winkel *= -1;
               winkel /= 180;
               winkel += -0.5;
               _factor = 0.98;
               _factor2 = 1;
               gfx_x = this.xIn*zoom + (_factor2*this.size*zoom/4) - (_factor*this.size*zoom/4)*(cos(-$pi * winkel));//*-((S2_labelpos-1)*0.7775 -1.1)/4));
               gfx_y = this.yIn*zoom + (_factor2*this.size*zoom/4) - (_factor*this.size*zoom/4)*(sin(-$pi * winkel));//*-((S2_labelpos-1)*0.7775 -1.1)/4));
 gfx_circle(gfx_x,gfx_y,2*zoom,1);
 );

  function labelposition_2000 (S2_Labelpos, s2label_w, s2label_h) (
              S2_xpos = this.xIn*zoom + (1*this.size*zoom/4) - (1*this.size*zoom/4)*(cos(-$pi*-((S2_labelpos-1)*0.7775 -1.1)/4));
              s2_ypos = this.yIn*zoom + (1*this.size*zoom/4) - (1*this.size*zoom/4)*(sin(-$pi*-((S2_labelpos-1)*0.7775 -1.1)/4));
              gfx_measurestr("-", S2add_x, s2add_y);
              S2_labelpos < 5 ? (gfx_x = s2_xpos - S2label_w - 1.1*S2add_x; gfx_y = s2_ypos - s2label_h/2);
              S2_labelpos == 5 ? (gfx_x = s2_xpos - S2label_w/2; gfx_y = s2_ypos - s2label_h);
              S2_labelpos > 5 ? (gfx_x = s2_xpos + 1.1*S2add_x; gfx_y = s2_ypos - s2label_h/2);
             
              //S2_labelpos < 5 ? (gfx_x -= 0.1* 1.1*this.size*zoom/4): (gfx_x -= 0.05* 1.1*this.size*zoom/4);
        //gfx_x = s2_xpos; gfx_y = s2_ypos;
  );
  
  
  
  //gfx_x = 200; gfx_y = 3; lakeblue();
  //slider2 <= 0.5 ? readout = 1 + ((slider2*2)^1.3)*1.5;
  //slider2 > 0.5 ? readout = 2.5 + (((slider2-0.5)*2)^1.4)*12;
  
  //slider3 <= 0.5 ? readout = ((slider3+0.5)^11)*50;
  //slider3 > 0.5 ? readout = 50+(((slider3-0.5)*2)^0.95)*150;
  
  //readout = 0.05+(slider4^3.15)*3.95;
  //gfx_drawnumber(readout, 2);
  
  //gfx_x = 240; gfx_y = 3;
  //readout2 = (((readout-0.05)/3.95)^(1/3.15));
  //readout > 0.5 ? readout2 = ((((readout-2.5)/12)^(1/1.4))/2)+0.5;
  //readout2 == slider4 ? rgb(0,255,0);
  //gfx_drawnumber(readout2, 2);
  
  function MDX_number_input_show () (
    gfx_r=gfx_g=gfx_b=0;
    gfx_rect(zoom*number_input_x,number_input_y*zoom, 200*zoom, gfx_texth+5);
    gfx_r=0;gfx_g=1;gfx_b=0;
    gfx_rect(zoom*number_input_x,zoom*number_input_y, gfx_texth+5, gfx_texth+5);
    gfx_r=gfx_g=gfx_b=0.7;
    gfx_roundrect(zoom*number_input_x,zoom*number_input_y, 200*zoom, gfx_texth+5,0);
    gfx_x = zoom*number_input_x + gfx_texth+7; gfx_y = zoom*number_input_y + 2;
    gfx_drawnumber(number_input_use,NI_komma);
  
  
        mouseclick && !shift_alt ? 
      (
        g_collision(zoom*number_input_x,zoom*number_input_y, gfx_texth+5, gfx_texth+5) ?
        (
          valid = 0;
          
          //slider7 <= 0.5 ? cal_gate_thr = -80 + ((((slider7)*2)^0.8) *60) :
          //cal_gate_thr = -20 + ((slider7-0.5)*2 *30);
          
          MDX_NI == 1 ? (
          number_input_use <= -20 ? number_input_use = (((80+number_input_use)/60) ^(1/0.8))/2 :
          number_input_use > -20 ? number_input_use = ((20+number_input_use)/60)+0.5;
          );
          
          MDX_NI == 3 ? (
          number_input_use <= 2.5 ? number_input_use = (((number_input_use-1)/1.5)^(1/1.3)) / 2:
          number_input_use > 2.5 ? number_input_use = ((((number_input_use-2.5)/12)^(1/1.4))/2)+0.5;
          );
          
          MDX_NI == 4 ? (
          number_input_use <= 50 ? number_input_use = ((number_input_use/50)^(1/11))-0.5:
          number_input_use > 50 ? number_input_use = ((((number_input_use-50)/150)^(1/0.95))/2)+0.5;
          );
          
          MDX_NI == 5 ? (
          number_input_use = (((number_input_use-0.05)/3.95)^(1/3.15));
          );
          
          number_input_use >= number_input_min && number_input_use <= number_input_max ? valid = 1;
          valid ? (
          slider(number_input_slider) = number_input_use;
          caller = 1;
          ):(
          number_input_invalid = 90;
          );
          Number_input = 0;
          number_input_raw = 0;
          number_input_use = 0;
          NI_komma = 0;
          in_key = 0;
          //number_input_x = 0;
          //number_input_y=0;
        ):(
          Number_input = 0;
          number_input_raw = 0;
          number_input_use = 0;
          NI_komma = 0;
          in_key = 0;
          number_input_x = 0;
          number_input_y=0;
        );
      );
  
      in_key=gfx_getchar();
  
      in_key ? Aaa = in_key;
        in_key == 8 ? (
        number_input_raw = floor(number_input_raw/10);
        NI_komma = max(0,komma-1);
        NI_komma == 1 ? NI_komma = 0;
        );
  
      in_key == 45 ? number_input_sign*=-1;
  
      in_key == 46 ? NI_komma = 1;
      in_key > 47 ? (
      in_key < 58 ? (
          number_input_raw = (number_input_raw*10) + (in_key-48);
          NI_komma ? NI_komma += 1;
      );
      );
  
      NI_komma ? (number_input_use = number_input_raw / (10^(NI_komma-1))):(number_input_use = number_input_raw);
      number_input_use *= number_input_sign;
  
    );
    
    
gfx_ext_flags == 0 ? (

s2_zoom_X = gfx_w / 929;
s2_zoom_y = gfx_h / 245;
zoom = min(s2_zoom_x, s2_zoom_y);// * gfx_ext_retina;
zoom_off == 1 ? zoom = gfx_ext_retina;



GUI_y = 40*zoom;


gfx_setfont(1,"Arial",12*zoom,'b');









gfx_a = 1;

    
    gfx_x = 0; gfx_y = 40*zoom;
    gfx_blit(Amp_plates,0.83*zoom,0,0,0,1500,250);
    

    //alles -53 Y
    

    
    black();
    gfx_rect(Notiz1_knob.xin * zoom - 15*zoom, notiz1_knob.yin * zoom-40*zoom,139*zoom,150*zoom);
    gfx_rect(Notiz2_knob.xin * zoom - 27*zoom, notiz2_knob.yin * zoom-40*zoom,625*zoom,150*zoom);
    gfx_rect(Notiz7_knob.xin * zoom - 22*zoom, notiz7_knob.yin * zoom-40*zoom,149*zoom,150*zoom);
    //gfx_rect(Notiz7_knob.xin * zoom + 84*zoom, notiz7_knob.yin * zoom-40*zoom,139*zoom,150*zoom);
    gfx_rect(Notiz1_knob.xin * zoom - 15*zoom, notiz1_knob.yin * zoom-73*zoom,139*zoom,31*zoom);
    gfx_rect(Notiz2_knob.xin * zoom - 27*zoom, notiz2_knob.yin * zoom-73*zoom,625*zoom,31*zoom);
    gfx_rect(Notiz7_knob.xin * zoom - 22*zoom, notiz7_knob.yin * zoom-73*zoom,149*zoom,31*zoom);
    //gfx_rect(Notiz7_knob.xin * zoom + 84*zoom, notiz7_knob.yin * zoom-73*zoom,139*zoom,31*zoom);
    
    gfx_x = Notiz7_knob.xin * zoom + 60*zoom; gfx_y = notiz7_knob.yin * zoom + 29*zoom;
    gfx_blit(12,0.6*zoom,0);
    
    lightgrey();
    gfx_setfont(2,"Arial",11*zoom,'b');
    gfx_x = Notiz1_knob.xin * zoom - 15*zoom; gfx_y = notiz1_knob.yin * zoom-34*zoom;
    gfx_drawstr("EXPANDER / GATE", 0x01, gfx_x+139*zoom, gfx_y +20*zoom);
    gfx_x = Notiz2_knob.xin * zoom - 27*zoom; gfx_y = notiz1_knob.yin * zoom-34*zoom;
    gfx_drawstr("COMPRESSOR / LIMITER", 0x01, gfx_x+625*zoom, gfx_y +20*zoom);
    gfx_x = Notiz7_knob.xin * zoom - 22*zoom; gfx_y = notiz1_knob.yin * zoom-34*zoom;
    gfx_drawstr("ENHANCER", 0x01, gfx_x+105*zoom, gfx_y +20*zoom);
    
    Notiz1_Knob.knob();
    gfx_setfont(2,"Arial",11*zoom,'b');
    #klabel = "OFF  "; gfx_measurestr(#klabel, klw, klh); Notiz1_Knob.labelposition_scaled(0.1,klw, klh); lightgrey(); gfx_y += 8*zoom; gfx_drawstr(#klabel);
    //#klabel = "3 "; gfx_measurestr(#klabel, klw, klh);  Notiz1_Knob.labelposition_scaled(2.1,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "35 "; gfx_measurestr(#klabel, klw, klh);  Notiz1_Knob.labelposition_scaled(3.9,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "-20"; gfx_measurestr(#klabel, klw, klh);  Notiz1_Knob.labelposition_scaled(5,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "-10"; gfx_measurestr(#klabel, klw, klh);   Notiz1_Knob.labelposition_scaled(6.2,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "±0"; gfx_measurestr(#klabel, klw, klh);   Notiz1_Knob.labelposition_scaled(7.9,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = " +10"; gfx_measurestr(#klabel, klw, klh);  Notiz1_Knob.labelposition_scaled(10,klw, klh); lightgrey(); gfx_y += 8*zoom;  gfx_drawstr(#klabel);
    
    gfx_y = Notiz1_Knob.yIn*zoom + 75*zoom; gfx_x = Notiz1_Knob.xIn*zoom - 8 * zoom;
    gfx_drawstr("dB", 0x01, gfx_x+Notiz1_knob.size*zoom*0.5+16*zoom, gfx_y +20*zoom);
    gfx_y = Notiz1_Knob.yIn*zoom + 90*zoom; gfx_x = Notiz1_Knob.xIn*zoom - 8 * zoom;
    gfx_drawstr("THRESHOLD", 0x01, gfx_x+Notiz1_knob.size*zoom*0.5+16*zoom, gfx_y +20*zoom);
    gfx_y =Fastrelx= Notiz1_Knob.yIn*zoom + 35*zoom; gfx_x =fastrely= Notiz1_Knob.xIn*zoom + 60 * zoom;
    gfx_blit(yeled,0.5*zoom,0,0, slider(Bfastrel.slider) ? 128 : 0,128,128);
    gfx_x += 15*zoom; gfx_y = Notiz1_Knob.yIn*zoom + 80*zoom;
    gfx_setfont(2,"Arial",10*zoom,'b');
    gfx_drawstr("SL.REL");
    
    Notiz2_Knob.knob();
    gfx_setfont(2,"Arial",11*zoom,'b');
    #klabel = "-40  "; gfx_measurestr(#klabel, klw, klh); Notiz2_Knob.labelposition_scaled(0.1,klw, klh); lightgrey(); gfx_y += 8*zoom; gfx_drawstr(#klabel);
    #klabel = "-30 "; gfx_measurestr(#klabel, klw, klh);  Notiz2_Knob.labelposition_scaled(2.1,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "-20"; gfx_measurestr(#klabel, klw, klh);  Notiz2_Knob.labelposition_scaled(3.9,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "-10"; gfx_measurestr(#klabel, klw, klh);  Notiz2_Knob.labelposition_scaled(5,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "±0"; gfx_measurestr(#klabel, klw, klh);   Notiz2_Knob.labelposition_scaled(6.2,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "+10"; gfx_measurestr(#klabel, klw, klh);   Notiz2_Knob.labelposition_scaled(7.9,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = " +20"; gfx_measurestr(#klabel, klw, klh);  Notiz2_Knob.labelposition_scaled(10,klw, klh); lightgrey(); gfx_y += 8*zoom;  gfx_drawstr(#klabel);
    
    gfx_y = Notiz2_Knob.yIn*zoom + 75*zoom; gfx_x = Notiz2_Knob.xIn*zoom - 8 * zoom;
    gfx_drawstr("dB", 0x01, gfx_x+Notiz2_knob.size*zoom*0.5+16*zoom, gfx_y +20*zoom);
    gfx_y = Notiz2_Knob.yIn*zoom + 90*zoom; gfx_x = Notiz2_Knob.xIn*zoom - 8 * zoom;
    gfx_drawstr("THRESHOLD", 0x01, gfx_x+Notiz2_knob.size*zoom*0.5+16*zoom, gfx_y +20*zoom);

    
    gfx_y =sidechainy= Notiz2_Knob.yIn*zoom - 30*zoom; gfx_x =sidechainx= Notiz2_Knob.xIn*zoom + 63 * zoom;
    gfx_blit(geled,0.5*zoom,0,0,slider(BSidechain.slider) ? 128 : 0,128,128);
    gfx_x += 18*zoom; gfx_y = Notiz2_Knob.yIn*zoom + 13*zoom;
    gfx_setfont(2,"Arial",10*zoom,'b');
    gfx_drawstr("SC-IN");
    
    
    gfx_y =hpfy= Notiz2_Knob.yIn*zoom + 35*zoom; gfx_x =hpfx= Notiz2_Knob.xIn*zoom + 63 * zoom;
    gfx_blit(yeled,0.5*zoom,0,0,slider(BHPF.slider) ? 128 : 0,128,128);
    gfx_x += 15*zoom; gfx_y = Notiz1_Knob.yIn*zoom + 80*zoom;
    gfx_setfont(2,"Arial",10*zoom,'b');
    gfx_drawstr("SC HPF");
    
    
    Notiz3_Knob.knob();
    gfx_setfont(2,"Arial",11*zoom,'b');
    #klabel = "1  "; gfx_measurestr(#klabel, klw, klh); Notiz3_Knob.labelposition_scaled(0.1,klw, klh); lightgrey(); gfx_y += 8*zoom; gfx_drawstr(#klabel);
    #klabel = "1.5 "; gfx_measurestr(#klabel, klw, klh);  Notiz3_Knob.labelposition_scaled(2.1,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "2 "; gfx_measurestr(#klabel, klw, klh);  Notiz3_Knob.labelposition_scaled(3.9,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "2.5"; gfx_measurestr(#klabel, klw, klh);  Notiz3_Knob.labelposition_scaled(5,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "5"; gfx_measurestr(#klabel, klw, klh);   Notiz3_Knob.labelposition_scaled(6.2,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "8"; gfx_measurestr(#klabel, klw, klh);   Notiz3_Knob.labelposition_scaled(7.9,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = " oo"; gfx_measurestr(#klabel, klw, klh);  Notiz3_Knob.labelposition_scaled(10,klw, klh); lightgrey(); gfx_y += 8*zoom;  gfx_drawstr(#klabel);
    
    gfx_y = Notiz3_Knob.yIn*zoom + 75*zoom; gfx_x = Notiz3_Knob.xIn*zoom - 8 * zoom;
    gfx_drawstr("n:1", 0x01, gfx_x+Notiz3_knob.size*zoom*0.5+16*zoom, gfx_y +20*zoom);
    gfx_y = Notiz3_Knob.yIn*zoom + 90*zoom; gfx_x = Notiz3_Knob.xIn*zoom - 8 * zoom;
    gfx_drawstr("RATIO", 0x01, gfx_x+Notiz3_knob.size*zoom*0.5+16*zoom, gfx_y +20*zoom);
    
    gfx_y =kneey= Notiz3_Knob.yIn*zoom + 35*zoom; gfx_x =kneex= Notiz3_Knob.xIn*zoom + 63 * zoom;
    gfx_blit(geled,0.5*zoom,0,0,slider(Bknee.slider) ? 128 : 0,128,128);
    gfx_x += 18*zoom; gfx_y = Notiz3_Knob.yIn*zoom + 80*zoom;
    gfx_setfont(2,"Arial",10*zoom,'b');
    gfx_drawstr("KNEE");
    
    
    Notiz4_Knob.knob();
    gfx_setfont(2,"Arial",11*zoom,'b');
    #klabel = "0  "; gfx_measurestr(#klabel, klw, klh); Notiz4_Knob.labelposition_scaled(0.1,klw, klh); lightgrey(); gfx_y += 8*zoom; gfx_drawstr(#klabel);
    #klabel = "1 "; gfx_measurestr(#klabel, klw, klh);  Notiz4_Knob.labelposition_scaled(2.1,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "10 "; gfx_measurestr(#klabel, klw, klh);  Notiz4_Knob.labelposition_scaled(3.9,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "50"; gfx_measurestr(#klabel, klw, klh);  Notiz4_Knob.labelposition_scaled(5,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "100"; gfx_measurestr(#klabel, klw, klh);   Notiz4_Knob.labelposition_scaled(6.2,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    //#klabel = "5"; gfx_measurestr(#klabel, klw, klh);   Notiz4_Knob.labelposition_scaled(7.9,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = " 200"; gfx_measurestr(#klabel, klw, klh);  Notiz4_Knob.labelposition_scaled(10,klw, klh); lightgrey(); gfx_y += 8*zoom;  gfx_drawstr(#klabel);
    
    gfx_y = Notiz4_Knob.yIn*zoom + 75*zoom; gfx_x = Notiz4_Knob.xIn*zoom - 8 * zoom;
    gfx_drawstr("mSec", 0x01, gfx_x+Notiz4_knob.size*zoom*0.5+16*zoom, gfx_y +20*zoom);
    gfx_y = Notiz4_Knob.yIn*zoom + 90*zoom; gfx_x = Notiz4_Knob.xIn*zoom - 8 * zoom;
    gfx_drawstr("ATTACK", 0x01, gfx_x+Notiz4_knob.size*zoom*0.5+16*zoom, gfx_y +20*zoom);
    
    gfx_y =autoy= Notiz4_Knob.yIn*zoom + 35*zoom; gfx_x =autox= Notiz4_Knob.xIn*zoom + 63 * zoom;
    gfx_blit(yeled,0.5*zoom,0,0,slider(BAuto.slider) ? 128 : 0,128,128);
    gfx_x += 17*zoom; gfx_y = Notiz4_Knob.yIn*zoom + 80*zoom;
    gfx_setfont(2,"Arial",10*zoom,'b');
    gfx_drawstr("AUTO");
    
    
    Notiz5_Knob.knob();
    gfx_setfont(2,"Arial",11*zoom,'b');
    #klabel = ".05  "; gfx_measurestr(#klabel, klw, klh); Notiz5_Knob.labelposition_scaled(0.1,klw, klh); lightgrey(); gfx_y += 8*zoom; gfx_drawstr(#klabel);
    //#klabel = "3 "; gfx_measurestr(#klabel, klw, klh);  Notiz5_Knob.labelposition_scaled(2.1,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "0.3 "; gfx_measurestr(#klabel, klw, klh);  Notiz5_Knob.labelposition_scaled(3.9,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "0.5"; gfx_measurestr(#klabel, klw, klh);  Notiz5_Knob.labelposition_scaled(5,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "1"; gfx_measurestr(#klabel, klw, klh);   Notiz5_Knob.labelposition_scaled(6.2,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "2"; gfx_measurestr(#klabel, klw, klh);   Notiz5_Knob.labelposition_scaled(7.9,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = " 4"; gfx_measurestr(#klabel, klw, klh);  Notiz5_Knob.labelposition_scaled(10,klw, klh); lightgrey(); gfx_y += 8*zoom;  gfx_drawstr(#klabel);
    
    gfx_y = Notiz5_Knob.yIn*zoom + 75*zoom; gfx_x = Notiz5_Knob.xIn*zoom - 8 * zoom;
    gfx_drawstr("Sec", 0x01, gfx_x+Notiz5_knob.size*zoom*0.5+16*zoom, gfx_y +20*zoom);
    gfx_y = Notiz5_Knob.yIn*zoom + 90*zoom; gfx_x = Notiz5_Knob.xIn*zoom - 8 * zoom;
    gfx_drawstr("RELEASE", 0x01, gfx_x+Notiz5_knob.size*zoom*0.5+16*zoom, gfx_y +20*zoom);
    gfx_y = Notiz5_Knob.yIn*zoom + 35*zoom; gfx_x = Notiz5_Knob.xIn*zoom + 60 * zoom;
    
    Notiz6_Knob.knob();
    gfx_setfont(2,"Arial",11*zoom,'b');
    #klabel = "-20  "; gfx_measurestr(#klabel, klw, klh); Notiz6_Knob.labelposition_scaled(0.1,klw, klh); lightgrey(); gfx_y += 8*zoom; gfx_drawstr(#klabel);
    //#klabel = "3 "; gfx_measurestr(#klabel, klw, klh);  Notiz6_Knob.labelposition_scaled(2.1,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "-10 "; gfx_measurestr(#klabel, klw, klh);  Notiz6_Knob.labelposition_scaled(2.9,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "±0"; gfx_measurestr(#klabel, klw, klh);  Notiz6_Knob.labelposition_scaled(5,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "+10"; gfx_measurestr(#klabel, klw, klh);   Notiz6_Knob.labelposition_scaled(7.25,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    //#klabel = "5"; gfx_measurestr(#klabel, klw, klh);   Notiz6_Knob.labelposition_scaled(7.9,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = " +20"; gfx_measurestr(#klabel, klw, klh);  Notiz6_Knob.labelposition_scaled(10,klw, klh); lightgrey(); gfx_y += 8*zoom;  gfx_drawstr(#klabel);
    
    gfx_y = Notiz6_Knob.yIn*zoom + 75*zoom; gfx_x = Notiz6_Knob.xIn*zoom - 8 * zoom;
    gfx_drawstr("dB", 0x01, gfx_x+Notiz6_knob.size*zoom*0.5+16*zoom, gfx_y +20*zoom);
    gfx_y = Notiz6_Knob.yIn*zoom + 90*zoom; gfx_x = Notiz6_Knob.xIn*zoom - 8 * zoom;
    gfx_drawstr("OUTPUT", 0x01, gfx_x+Notiz6_knob.size*zoom*0.5+16*zoom, gfx_y +20*zoom);
    
    Notiz7_Knob.knob();
    gfx_setfont(2,"Arial",11*zoom,'b');
    #klabel = "OFF  "; gfx_measurestr(#klabel, klw, klh); Notiz7_Knob.labelposition_scaled(0.1,klw, klh); lightgrey(); gfx_y += 8*zoom; gfx_drawstr(#klabel);
    //#klabel = "3 "; gfx_measurestr(#klabel, klw, klh);  Notiz7_Knob.labelposition_scaled(2.1,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "2 "; gfx_measurestr(#klabel, klw, klh);  Notiz7_Knob.labelposition_scaled(3.9,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "3"; gfx_measurestr(#klabel, klw, klh);  Notiz7_Knob.labelposition_scaled(5,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = "4"; gfx_measurestr(#klabel, klw, klh);   Notiz7_Knob.labelposition_scaled(6.2,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    //#klabel = "5"; gfx_measurestr(#klabel, klw, klh);   Notiz7_Knob.labelposition_scaled(7.9,klw, klh); lightgrey(); gfx_drawstr(#klabel);
    #klabel = " 6"; gfx_measurestr(#klabel, klw, klh);  Notiz7_Knob.labelposition_scaled(10,klw, klh); lightgrey(); gfx_y += 8*zoom;  gfx_drawstr(#klabel);
    
    gfx_y = Notiz7_Knob.yIn*zoom + 90*zoom; gfx_x = Notiz7_Knob.xIn*zoom - 8 * zoom;
    gfx_drawstr("PROCESS", 0x01, gfx_x+Notiz7_knob.size*zoom*0.5+16*zoom, gfx_y +20*zoom);
    gfx_y = Notiz7_Knob.yIn*zoom + 35*zoom; gfx_x = Notiz7_Knob.xIn*zoom + 60 * zoom;
    
    gfx_y =bypassy= Notiz5_Knob.yIn*zoom + 35*zoom; gfx_x =bypassx= Notiz5_Knob.xIn*zoom + 65 * zoom;
    gfx_blit(geled,0.5*zoom,0,0,!slider(BBypass.slider) ? 128 : 0,128,128);
    gfx_x += 25*zoom; gfx_y = Notiz5_Knob.yIn*zoom + 80*zoom;
    gfx_setfont(2,"Arial",10*zoom,'b');
    gfx_drawstr("ON");
    
    
    
    /*
    gfx_roundrect(Notiz1_Knob.xIn*zoom + 73*zoom, notiz1_knob.yIn * zoom + 60*zoom, 37*zoom, 15*zoom,0);
    gfx_roundrect(Notiz2_Knob.xIn*zoom + 73*zoom, notiz2_knob.yIn * zoom - 5*zoom, 37*zoom, 15*zoom,0);
    gfx_roundrect(Notiz2_Knob.xIn*zoom + 73*zoom, notiz2_knob.yIn * zoom + 60*zoom, 37*zoom, 15*zoom,0);
    gfx_roundrect(Notiz4_Knob.xIn*zoom + 73*zoom, notiz4_knob.yIn * zoom + 60*zoom, 37*zoom, 15*zoom,0);
    gfx_roundrect(Notiz7_Knob.xIn*zoom + 73*zoom, notiz7_knob.yIn * zoom + 60*zoom, 37*zoom, 15*zoom,0);
    */
    
    //rled = 33; gled = 31; yled = 32;
    gfx_x = 180*zoom; gfx_y = 59*zoom;
    INS_GR_Meter <= -30 ? ledon = 1 : ledon = 0;
    gfx_blit(rled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
    gfx_x += 20*zoom;
    INS_GR_Meter <= -27 ? ledon = 1 : ledon = 0;
    gfx_blit(rled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
    gfx_x += 20*zoom;
    INS_GR_Meter <= -24 ? ledon = 1 : ledon = 0;
    gfx_blit(rled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
    gfx_x += 20*zoom;
    INS_GR_Meter <= -21 ? ledon = 1 : ledon = 0;
    gfx_blit(rled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
    gfx_x += 20*zoom;
    INS_GR_Meter <= -18 ? ledon = 1 : ledon = 0;
    gfx_blit(rled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
    gfx_x += 20*zoom;
    INS_GR_Meter <= -15 ? ledon = 1 : ledon = 0;
    gfx_blit(rled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
    gfx_x += 20*zoom;
    INS_GR_Meter <= -12 ? ledon = 1 : ledon = 0;
    gfx_blit(rled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
    gfx_x += 20*zoom;
    INS_GR_Meter <= -9 ? ledon = 1 : ledon = 0;
    gfx_blit(rled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
    gfx_x += 20*zoom;
    INS_GR_Meter <= -6 ? ledon = 1 : ledon = 0;
    gfx_blit(rled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
    gfx_x += 20*zoom;
    INS_GR_Meter <= -4 ? ledon = 1 : ledon = 0;
    gfx_blit(rled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
    gfx_x += 20*zoom;
    INS_GR_Meter <= -2 ? ledon = 1 : ledon = 0;
    gfx_blit(rled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
    gfx_x += 20*zoom;
    INS_GR_Meter <= -1 ? ledon = 1 : ledon = 0;
    gfx_blit(rled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
    
    lightgrey();
     gfx_setfont(1,"Arial",11*zoom,'b');
     gfx_x = 187*zoom; gfx_y = 59*zoom;
     gfx_drawstr("-30");
     gfx_x = 207*zoom; 
     gfx_drawstr("-27");
     gfx_x = 227*zoom;  
     gfx_drawstr("-24");
     gfx_x = 247*zoom; 
     gfx_drawstr("-21");
     gfx_x = 267*zoom; 
     gfx_drawstr("-18");
     gfx_x = 287*zoom;  
     gfx_drawstr("-15");
     gfx_x = 307*zoom;  
     gfx_drawstr("-12");
     gfx_x = 330*zoom;  
     gfx_drawstr("-9");
     gfx_x = 350*zoom;  
     gfx_drawstr("-6");
     gfx_x = 370*zoom;  
     gfx_drawstr("-4");
     gfx_x = 390*zoom;  
     gfx_drawstr("-2");
     gfx_x = 410*zoom;  
     gfx_drawstr("-1");
     
    
     
      gfx_x = 480*zoom; gfx_y = 59*zoom;
     INS_OUT_Meter >= -30 ? ledon = 1 : ledon = 0;
      gfx_blit(gled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
      gfx_x += 20*zoom;
     INS_OUT_Meter >= -24 ? ledon = 1 : ledon = 0;
      gfx_blit(gled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
      gfx_x += 20*zoom;
     INS_OUT_Meter >= -18 ? ledon = 1 : ledon = 0;
      gfx_blit(gled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
      gfx_x += 20*zoom;
     INS_OUT_Meter >= -12 ? ledon = 1 : ledon = 0;
      gfx_blit(gled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
      gfx_x += 20*zoom;
     INS_OUT_Meter >= -6 ? ledon = 1 : ledon = 0;
      gfx_blit(gled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
      gfx_x += 20*zoom;
     INS_OUT_Meter >= -3 ? ledon = 1 : ledon = 0;
      gfx_blit(gled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
      gfx_x += 20*zoom;
     INS_OUT_Meter >= 0 ? ledon = 1 : ledon = 0;
      gfx_blit(gled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
      gfx_x += 20*zoom;
     INS_OUT_Meter >= 3 ? ledon = 1 : ledon = 0;
      gfx_blit(gled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
       gfx_x += 20*zoom;
      INS_OUT_Meter >= 6 ? ledon = 1 : ledon = 0;
       gfx_blit(yled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
        gfx_x += 20*zoom;
       INS_OUT_Meter >= 9 ? ledon = 1 : ledon = 0;
        gfx_blit(yled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
         gfx_x += 20*zoom;
        INS_OUT_Meter >= 12 ? ledon = 1 : ledon = 0;
         gfx_blit(rled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
          gfx_x += 20*zoom;
         INS_OUT_Meter >= 18 ? ledon = 1 : ledon = 0;
          gfx_blit(rled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
          
      lightgrey();
       gfx_setfont(1,"Arial",11*zoom,'b');
       gfx_x = 487*zoom; gfx_y = 58*zoom;
       gfx_drawstr("-30");
       gfx_x = 507*zoom; 
       gfx_drawstr("-24");
       gfx_x = 527*zoom; 
       gfx_drawstr("-18");
       gfx_x = 547*zoom; 
       gfx_drawstr("-12");
       gfx_x = 570*zoom;
       gfx_drawstr("-6");
       gfx_x = 590*zoom;
       gfx_drawstr("-3");
       gfx_x = 610*zoom;
       gfx_drawstr("±0");
       gfx_x = 630*zoom;
       gfx_drawstr("+3");
       gfx_x = 650*zoom;
       gfx_drawstr("+6");
       gfx_x = 670*zoom;
       gfx_drawstr("+9");
       gfx_x = 687*zoom;
       gfx_drawstr("+12");
       gfx_x = 707*zoom;
       gfx_drawstr("+18");
       
       
        gfx_x = 10*zoom; gfx_y = 59*zoom;
       //!INS_GATE_Open ? ledon = 1 : ledon = 0;
       ledon = ratio2db(Plugin.result_gain) < -3 && gate_on;
        gfx_blit(gled, 0.25*zoom,0, 0, 128*!ledon, 128, 128);
        gfx_x += 20*zoom;
       //INS_GATE_Open ? ledon = 1 : ledon = 0;
        gfx_blit(rled, 0.25*zoom,0, 0, 128*ledon, 128, 128);
        lightgrey();
       gfx_x = 23*zoom; gfx_y = 59*zoom;
       gfx_drawstr("+");
       gfx_x = 41*zoom; 
       gfx_drawstr("- -");
       
       black();
       gfx_x = 20*zoom; gfx_y = 42*zoom;
       gfx_drawstr("THRESHOLD");
       
       gfx_x = 255*zoom; gfx_y = 42*zoom;
       gfx_drawstr("GAIN REDUCTION");
       
       gfx_x = 570*zoom; gfx_y = 42*zoom;
       gfx_drawstr("OUTPUT LEVEL");
    
    
    /*
    
    mouseClick == 1 ? (
      Notiz1_knob.k_collision() ? (Notiz1_Knob.dragstart());
      Notiz2_knob.k_collision() ? (Notiz2_Knob.dragstart());
      Notiz3_knob.k_collision() ? (Notiz3_Knob.dragstart());
      Notiz4_knob.k_collision() ? (Notiz4_Knob.dragstart());
      Notiz5_knob.k_collision() ? (Notiz5_Knob.dragstart());
      Notiz6_knob.k_collision() ? (Notiz6_Knob.dragstart());
      Notiz7_knob.k_collision() ? (Notiz7_Knob.dragstart());
      
      g_collision(Notiz1_Knob.xIn*zoom + 73*zoom, notiz1_knob.yIn * zoom + 60*zoom, 37*zoom, 15*zoom) ? Notiz11 == 0 ? notiz11 = 1 : notiz11 = 0;
      g_collision(Notiz2_Knob.xIn*zoom + 76*zoom, notiz2_knob.yIn * zoom - 5*zoom, 37*zoom, 15*zoom) ?  Notiz12 == 0 ? notiz12 = 1 : notiz12 = 0;
      g_collision(Notiz2_Knob.xIn*zoom + 76*zoom, notiz2_knob.yIn * zoom + 60*zoom, 37*zoom, 15*zoom) ? Notiz13 == 0 ? notiz13 = 1 : notiz13 = 0;
      g_collision(Notiz4_Knob.xIn*zoom + 76*zoom, notiz4_knob.yIn * zoom + 60*zoom, 37*zoom, 15*zoom) ? Notiz14 == 0 ? notiz14 = 1 : notiz14 = 0;
      g_collision(Notiz7_Knob.xIn*zoom + 85*zoom, notiz7_knob.yIn * zoom + 60*zoom, 37*zoom, 15*zoom) ? Notiz15 == 0 ? notiz15 = 1 : notiz15 = 0;
    );
    
    
           mouseclick == -1 ? (
           Notiz1_Knob.dragstop();
           Notiz2_Knob.dragstop();
           Notiz3_Knob.dragstop();
           Notiz4_Knob.dragstop();     
           Notiz5_Knob.dragstop();
           Notiz6_Knob.dragstop();
           
           Notiz7_Knob.dragstop();
           );
           
    
    
           mouse_wheel ? 
               (
                Notiz1_Knob.k_collision() ? (Notiz1_Knob.potWheel(); caller = 1;mouse_wheel=0);
                Notiz2_Knob.k_collision() ? (Notiz2_Knob.potWheel(); caller = 1;mouse_wheel=0);
                Notiz3_Knob.k_collision() ? (Notiz3_Knob.potWheel(); caller = 1;mouse_wheel=0);
                Notiz4_Knob.k_collision() ? (Notiz4_Knob.potWheel(); caller = 1;mouse_wheel=0);
                Notiz5_Knob.k_collision() ? (Notiz5_Knob.potWheel(); caller = 1;mouse_wheel=0);
                Notiz6_Knob.k_collision() ? (Notiz6_Knob.potWheel(); caller = 1;mouse_wheel=0);
                Notiz7_Knob.k_collision() ? (Notiz7_Knob.potWheel(); caller = 1;mouse_wheel=0);
               );
               
               
        Notiz1_Knob.dragging ? (Notiz1_Knob.potdrag(); caller = 1;);
        Notiz2_Knob.dragging ? (Notiz2_Knob.potdrag(); caller = 1;);
        Notiz3_Knob.dragging ? (Notiz3_Knob.potdrag(); caller = 1;);
        Notiz4_Knob.dragging ? (Notiz4_Knob.potdrag(); caller = 1;);
        Notiz5_Knob.dragging ? (Notiz5_Knob.potdrag(); caller = 1;);
        Notiz6_Knob.dragging ? (Notiz6_Knob.potdrag(); caller = 1;);
        Notiz7_Knob.dragging ? (Notiz7_Knob.potdrag(); caller = 1;);
        
        
        
     */   
        
        


  ////////////////////////////////////////// MENU MENU MENU ////////////////////////////////////////////////
  last_clicked_item = -1;
  Helpshow ? mouse_cap ? (helpshow = 0;last_clicked_item = -1);
  menu_x = 5; menu_y =5;
 
 gfx_x = menu_x * zoom; gfx_y = menu * zoom; gfx_a=1;
 //gfx_blit(menu,zoom/2,0);
 lightgrey(); //red();
 gfx_roundrect(menu_x * zoom, (menu_y + 5) * zoom, 20*zoom, 20*zoom, 0, 1);
 gfx_line((menu_x+3)*zoom, (menu_y + 11)*zoom, (menu_x+17)*zoom, (menu_y + 11)*zoom);
 gfx_line((menu_x+3)*zoom, (menu_y + 15)*zoom, (menu_x+17)*zoom, (menu_y + 15)*zoom);
 gfx_line((menu_x+3)*zoom, (menu_y + 19)*zoom, (menu_x+17)*zoom, (menu_y + 19)*zoom);
 
 gfx_setfont(1,"Arial",12*zoom,'b');
 lightgrey(); gfx_x = menu_x * zoom + 30*zoom;gfx_y += 14*zoom;
 gfx_drawstr("TUKAN STUDIOS  -  SILVER COMPRESSOR "); 
 gfx_setfont(1,"Arial",12*zoom,'i');
 lakeblue(); gfx_drawstr(" SERIES 2   ");
 gfx_setfont(1,"Arial",12*zoom,'b');
 
 
 
 link_group ? (
   rgb_palette(Link_group);// gfx_a = 0.7;
   gfx_drawstr("JOINS GROUP "); gfx_drawstr(sprintf(#,"%i", link_group));
 );
 gfx_a = 1;

 
  mouseClick ? (
   g_collision(menu_x*zoom, (menu_y+5) * zoom, 20*zoom, 20*zoom) ? (
    gfx_x = menu_x*zoom;
    gfx_y = (menu_y+20)*zoom;
     
      #item2 =">Processing|";#allitems = #item2;
     while_playing == 1 ? (#item2 = "!On Playback|"):(#item2 = "On Playback|");#allitems += #item2;
     while_recording == 1 ? (#item2 = "!On Recording|"):(#item2 = "On Recording|");#allitems += #item2;
     while_stopped == 1 ? (#item2 = "<!On Stop|>Groups|"):(#item2 = "<On Stop|>Groups|");#allitems += #item2;
 
     mnu_grp_loop = 1;
     loop(16,
 
       mnu_grp_loop == 16 ? #item2 += "<";
       gmem[16*64 + 10 + mnu_grp_loop] == 1 ? ( //Gruppe schon an ?
         mnu_grp_loop == Link_Group ? ( //ist selbst in der gruppe
                 #item2 = "!Joins Group ";
         ):(
             #item2 = "Add to Group ";
         );
       ):(
         #item2 = "Start Group ";
       );
     mnu_grp_loop == 1 ? #item2 += "01";
     mnu_grp_loop == 2 ? #item2 += "02";
     mnu_grp_loop == 3 ? #item2 += "03";
     mnu_grp_loop == 4 ? #item2 += "04";
     mnu_grp_loop == 5 ? #item2 += "05";
     mnu_grp_loop == 6 ? #item2 += "06";
     mnu_grp_loop == 7 ? #item2 += "07";
     mnu_grp_loop == 8 ? #item2 += "08";
     mnu_grp_loop == 9 ? #item2 += "09";
     mnu_grp_loop == 10 ? #item2 += "10";
     mnu_grp_loop == 11 ? #item2 += "11";
     mnu_grp_loop == 12 ? #item2 += "12";
     mnu_grp_loop == 13 ? #item2 += "13";
     mnu_grp_loop == 14 ? #item2 += "14";
     mnu_grp_loop == 15 ? #item2 += "15";
     mnu_grp_loop == 16 ? #item2 += "16";
     
     #item2 += "|";
     #allitems += #item2; //sprintf(#temp, '%f',3); 
     mnu_grp_loop += 1;
     );
     
     link_group ? (#allitems += "|<Delete Group ";#allitems += sprintf(#, "%d", link_group);#allitems += "|"):#allitems += "|<#Delete Group|";

     //#allitems += "<#MENU|";
    #allitems += ">Scaling|";
    zoom_off == 0 ? (#item2 = "!Automatic Scaling|"):(#item2 = "Automatic scaling|");#allitems += #item2;
    zoom_off == 1 ? (#item2 = "<!No scaling|"):(#item2 = "<No scaling|");#allitems += #item2;
    
    
    #allitems += ">Levels|";
    slider15 == 0 ? (#item2 = "!Analog Scale|"):(#item2 = "Analog Scale|");#allitems += #item2;
    slider15 == 1 ? (#item2 = "!Digital Scale|"):(#item2 = "Digital Scale|");#allitems += #item2;

    #allitems += "<|Show Info/Help";
    last_clicked_item = gfx_showmenu(#allitems);
  );
  );
 
 
 
 
  
  last_clicked_item == 1 ? (while_playing == 0 ? (while_playing = 1):(while_playing = 0);caller=1;processing_update());
  last_clicked_item == 2 ? (while_recording == 0 ? (while_recording = 1):(while_recording = 0);caller=1;processing_update());
  last_clicked_item == 3 ? (while_stopped == 0 ? (while_stopped = 1):(while_stopped = 0);caller=1;processing_update());
 
   cgroup = last_clicked_item - 3;
  last_clicked_item > 3 && last_clicked_item < 20 ? (
     Link_Group != cgroup ? ( //eigene Linkgruppe NICHT angeklickt
         gmem[16*64 + 10 + cgroup] == 0 ? ( // Gruppe noch frei
             //gmem[16*64 + 10 + cgroup] = 1; Link_Group = cgroup; gmem[16*64 +27 + cgruop] = 1; //Gruppe Starten!
             gmem[16*64 + 10 + cgroup] = 1;Link_Group = cgroup;group_update();
         ):(
             Link_Group = cgroup;// Gruppe teilnehmen
         );
     ):( //Eigene Gruppe angeklickt
           Link_Group = 0;
     );
  
  );
  
   cgroup = last_clicked_item - 3 - 16;
  last_clicked_item == 20 ? (
    gmem[16*64 + 10 + Link_Group] = 0;Link_Group = 0;
  );
  
  
  
  last_clicked_item == 21 ? zoom_off = 0;
  last_clicked_item == 22 ? zoom_off = 1;
  

  last_clicked_item == 23 ? (slider15 = 0; caller = 1);
  last_clicked_item == 24 ? (slider15 = 1; caller = 1);

  last_clicked_item == 25 ? helpshow = 1;
  
  helpshow == 1 ? (
  gfx_r=0;gfx_g=0;gfx_b=0;gfx_a=0.7;
  gfx_rect(menu_x,menu_y+0,370*zoom,155*zoom);
  menu_x +=3;
  gfx_r=0.9;gfx_g=0.9;gfx_b=0.9;gfx_a=1;
  gfx_x = menu_x+3*zoom; gfx_y = menu_y+3*zoom;
  gfx_drawstr("TUKAN STUDIOS SILVER COMPRESSOR (Series 2)");
  gfx_x = menu_x+3*zoom; gfx_y += 13*zoom;
  gfx_drawstr("Version: "); gfx_drawnumber(SILVER_COMPRESSOR_VERSION,2);
  gfx_x = menu_x+3*zoom; gfx_y += 20*zoom;
  gfx_drawstr("Mouse modifier options:");
  gfx_x = menu_x+3*zoom; gfx_y += 15*zoom;
  gfx_drawstr("Fine tune knobs: [shift]");
  gfx_x = menu_x+3*zoom; gfx_y += 13*zoom;
  gfx_drawstr("Reset knobs: [ctrl] ([cmd] on mac)");
  gfx_x = menu_x+3*zoom; gfx_y += 13*zoom;
  gfx_drawstr("Link knobs on visible instances: [win] ([ctrl] on mac)");
  gfx_x = menu_x+3*zoom; gfx_y += 13*zoom;
  gfx_drawstr("Activate number typing: [alt]+[shift]");
  
  gfx_x = menu_x+3*zoom; gfx_y += 20*zoom;
  gfx_drawstr("About the 'Levels' option:");
  gfx_x = menu_x+3*zoom; gfx_y += 13*zoom;
  gfx_drawstr("Analog Scale: Matches to the actual device settings.");
  gfx_x = menu_x+3*zoom; gfx_y += 13*zoom;
  gfx_drawstr("Digital Scale: Matches to the digital values (DAW).");
  );
  
  
  ////////////////////////////////////////// ENDE MENU MENU MENU ////////////////////////////////////////////////
  
  
  
  
  
  
  
  
  /*
  
  gfx_rect(fastrely+10*zoom,fastrelx+26*zoom,42*zoom,16*zoom,0);
  gfx_rect(sidechainx+10*zoom,sidechainy+26*zoom,42*zoom,16*zoom,0);
  gfx_rect(hpfx+10*zoom,hpfy+26*zoom,42*zoom,16*zoom,0);
  gfx_rect(kneex+10*zoom,kneey+26*zoom,42*zoom,16*zoom,0);
  gfx_rect(autox+10*zoom,autoy+26*zoom,42*zoom,16*zoom,0);
  gfx_rect(bypassx+10*zoom,bypassy+26*zoom,42*zoom,16*zoom,0);

*/

  
 ////////////////////////////////////////////////////////////////////////////////////////////// MAUS STEUERUNG
 
 
 
       !Number_input ? (
        
       mouseClick == 1 ? (
       MDX_NI = 0;
       Notiz1_knob.k_collision() ? (MDX_NI = 1; Notiz1_knob.dragstart());
       Notiz2_knob.k_collision() ? Notiz2_knob.dragstart();
       Notiz3_knob.k_collision() ? (MDX_NI = 3; Notiz3_knob.dragstart());
       Notiz4_knob.k_collision() ? (MDX_NI = 4; Notiz4_knob.dragstart());
       Notiz5_knob.k_collision() ? (MDX_NI = 5; Notiz5_knob.dragstart());
       Notiz6_knob.k_collision() ? Notiz6_knob.dragstart();
       //Notiz1_knob.k_collision() ? Notiz1_knob.dragstart();
       Notiz7_knob.k_collision() ? Notiz7_knob.dragstart();
       //KRatio.k_collision() ? KRatio.dragstart();
       //KKnee.k_collision() ? KKnee.dragstart();
       //KHPF.k_collision() ? KHPF.dragstart();
       //KDryWet.k_collision() ? KDryWet.dragstart();
       //KAttack.k_collision() ? KAttack.dragstart();
       //KRelease.k_collision() ? KRelease.dragstart();
       //KOutput.k_collision() ? KOutput.dragstart();
       
       katze = 0;
       
        g_collision(fastrely+10*zoom,fastrelx+26*zoom,42*zoom,16*zoom) ? (slider(BFastRel.slider) == 0 ? (slider(BFastRel.slider) = 1; caller = 1):(slider(BFastRel.slider) = 0; caller =1);BFastRel.quicklink_button());
        g_collision(autox+10*zoom,autoy+26*zoom,42*zoom,16*zoom) ? (slider(BAuto.slider) == 0 ? (slider(BAuto.slider) = 1; caller = 1):(slider(BAuto.slider) = 0; caller =1);BAuto.quicklink_button());
        g_collision(bypassx+10*zoom,bypassy+26*zoom,42*zoom,16*zoom) ? (slider(BBypass.slider) == 0 ? (slider(BBypass.slider) = 1; caller = 1):(slider(BBypass.slider) = 0; caller =1);BBypass.quicklink_button());
        g_collision(sidechainx+10*zoom,sidechainy+26*zoom,42*zoom,16*zoom) ? (slider(BSidechain.slider) == 0 ? (slider(BSidechain.slider) = 1; caller = 1):(slider(BSidechain.slider) = 0; caller =1);BSidechain.quicklink_button());
        g_collision(kneex+10*zoom,kneey+26*zoom,42*zoom,16*zoom) ? (slider(Bknee.slider) == 0 ? (slider(Bknee.slider) = 1; caller = 1):(slider(Bknee.slider) = 0; caller =1);BKnee.quicklink_button());
        g_collision(hpfx+10*zoom,hpfy+26*zoom,42*zoom,16*zoom) ? (slider(BHPF.slider) == 0 ? (slider(BHPF.slider) = 1; caller = 1):(slider(BHPF.slider) = 0; caller =1);BHPF.quicklink_button());
        
       ); 
       
       mouseclick == -1 ? (
       Notiz1_knob.dragstop();
       Notiz2_knob.dragstop();
       Notiz3_knob.dragstop();
       Notiz4_knob.dragstop();
       Notiz5_knob.dragstop();
       Notiz6_knob.dragstop();
       Notiz1_knob.dragstop();
       Notiz7_knob.dragstop();
       //KRatio.dragstop();
       //KKnee.dragstop();
       //KHPF.dragstop();
       //KDryWet.dragstop();
       //KAttack.dragstop();
       //KRelease.dragstop();
       //KOutput.dragstop();
        katze = 0;
       );
       
       
       mouse_wheel ? 
           (
       Notiz1_knob.k_collision() ? Notiz1_knob.potwheel();
       Notiz2_knob.k_collision() ? Notiz2_knob.potwheel();
       Notiz3_knob.k_collision() ? Notiz3_knob.potwheel();
       Notiz4_knob.k_collision() ? Notiz4_knob.potwheel();
       Notiz5_knob.k_collision() ? Notiz5_knob.potwheel();
       Notiz6_knob.k_collision() ? Notiz6_knob.potwheel();
       Notiz1_knob.k_collision() ? Notiz1_knob.potwheel();
       Notiz7_knob.k_collision() ? Notiz7_knob.potwheel();
       //KRatio.k_collision() ? KRatio.potwheel();
       //KKnee.k_collision() ? KKnee.potwheel();
       //KHPF.k_collision() ? KHPF.potwheel();
       //KDryWet.k_collision() ? KDryWet.potwheel();
       //KAttack.k_collision() ? KAttack.potwheel();
       //KRelease.k_collision() ? KRelease.potwheel();
       //KOutput.k_collision() ? KOutput.potwheel();
            mouse_wheel=0;
            caller = 1;
           );
        
        gfx_a=1;
       Notiz1_knob.dragging ? (Notiz1_knob.potdrag();caller = 1;);
       Notiz2_knob.dragging ? (Notiz2_knob.potdrag();caller = 1;);
       Notiz3_knob.dragging ? (Notiz3_knob.potdrag();caller = 1;);
       Notiz4_knob.dragging ? (Notiz4_knob.potdrag();caller = 1;);
       Notiz5_knob.dragging ? (Notiz5_knob.potdrag();caller = 1;);
       Notiz6_knob.dragging ? (Notiz6_knob.potdrag();caller = 1;);
       Notiz1_knob.dragging ? (Notiz1_knob.potdrag();caller = 1;);
       Notiz7_knob.dragging ? (Notiz7_knob.potdrag();caller = 1;);
       //KRatio.dragging ? (KRatio.potdrag();KRatio.readout();caller = 1;);
       //KKnee.dragging ? (KKnee.potdrag();KKnee.readout();caller = 1;);
       //KHPF.dragging ? (KHPF.potdrag();KHPF.readout();caller = 1;);
       //KDryWet.dragging ? (KDryWet.potdrag();KDryWet.readout();caller = 1;);
       //KAttack.dragging ? (KAttack.potdrag();KAttack.readout();caller = 1;);
       //KRelease.dragging ? (KRelease.potdrag();KRelease.readout();caller = 1;);
       //KOutput.dragging ? (KOutput.potdrag();KOutput.readout();caller = 1;);        


      Link_Group == 0 ? (
      gmem[16*64 + 3] == 0 ? linkstart = 0;
      !mouse_cap ? (
      gmem[16*64 + 3] == 1 ? (linkstart == 0 ? link_old = slider(gmem[16*64 + 1]); linkstart = 1);
      gmem[16*64 + 3] == 1 ? (
           tmp_val = link_old +  gmem[16*64 + 2];
      slider(gmem[16*64 + 1]) = tmp_val;
      slider_automate(slider(gmem[16*64 + 1]));
      caller = 1;
      );
      gmem[16*64 + 3] == 2 ? (
      slider(gmem[16*64 + 1]) =  gmem[16*64 + 2];
      caller = 1;
      );
      );
      );
      
      
      
      ); // !number_input

      
      
     
      
      
      gfx_a=1;
      number_input && MDX_NI == 0 ? number_input_show();
      number_input && MDX_NI ? MDX_number_input_show();
      //OEQ_NI == 1 ? number_input
      number_input_invalid = max(0,number_input_invalid-1);
      number_input_invalid ? ( 
      gfx_r=gfx_g=gfx_b=0;
      gfx_rect(zoom*number_input_x,number_input_y*zoom, 200*zoom, gfx_texth+5);
      gfx_r=0;gfx_g=1;gfx_b=0;
      gfx_rect(zoom*number_input_x,zoom*number_input_y, gfx_texth+5, gfx_texth+5);
      red();
      gfx_rect(zoom*number_input_x + gfx_texth+5,zoom*number_input_y, 200*zoom - (gfx_texth+5), gfx_texth+5);
      gfx_r=gfx_g=gfx_b=0.7;
      gfx_roundrect(zoom*number_input_x,zoom*number_input_y, 200*zoom, gfx_texth+5,0);
      gfx_x = zoom*number_input_x + gfx_texth+7; gfx_y = zoom*number_input_y + 2;
      white();
      gfx_drawstr("NO VALID INPUT!");
      );
    
 ////////////////////////////////////////////////////////////////////////////////////////////// ENDE MAUS STEUERUNG


























):gfx_ext_flags == 1 ? (
retti = gfx_ext_retina;
gfx_d = gfx_h / 10; gfx_dx = gfx_w / 7; gfx_dxd = gfx_dx / 10;
INS_GR_Meter <= -1 ? ledon = 1 : ledon = 0; ledon ? rgb(255,50,50) : rgb(85,30,30);
gfx_rect(gfx_dx * 6 + gfx_dxd, gfx_d * 4, gfx_dx  - 2* gfx_dxd , gfx_d *2);
INS_GR_Meter <= -2 ? ledon = 1 : ledon = 0; ledon ? rgb(255,50,50) : rgb(85,30,30);
gfx_rect(gfx_dx * 5 + gfx_dxd, gfx_d * 4, gfx_dx  - 2* gfx_dxd , gfx_d *2);
INS_GR_Meter <= -4 ? ledon = 1 : ledon = 0; ledon ? rgb(255,50,50) : rgb(85,30,30);
gfx_rect(gfx_dx * 4 + gfx_dxd, gfx_d * 4, gfx_dx  - 2* gfx_dxd , gfx_d *2);
INS_GR_Meter <= -6 ? ledon = 1 : ledon = 0; ledon ? rgb(255,50,50) : rgb(85,30,30);
gfx_rect(gfx_dx * 3 + gfx_dxd, gfx_d * 4, gfx_dx  - 2* gfx_dxd , gfx_d *2);
INS_GR_Meter <= -9 ? ledon = 1 : ledon = 0; ledon ? rgb(255,50,50) : rgb(85,30,30);
gfx_rect(gfx_dx * 2 + gfx_dxd, gfx_d * 4, gfx_dx  - 2* gfx_dxd , gfx_d *2);
INS_GR_Meter <= -12 ? ledon = 1 : ledon = 0; ledon ? rgb(255,50,50) : rgb(85,30,30);
gfx_rect(gfx_dx * 1 + gfx_dxd, gfx_d * 4, gfx_dx  - 2* gfx_dxd , gfx_d *2);
INS_GR_Meter <= -15 ? ledon = 1 : ledon = 0; ledon ? rgb(255,50,50) : rgb(85,30,30);
gfx_rect(gfx_dx * 0 + gfx_dxd, gfx_d * 4, gfx_dx  - 2* gfx_dxd , gfx_d *2);


ins_out_meter >= -30 ?  ledon = 1 : ledon = 0; ledon ? rgb(50,255,50) : rgb(30,85,30);
gfx_rect(gfx_dx * 0 + gfx_dxd, gfx_d * 7, gfx_dx  - 2* gfx_dxd , gfx_d *2);
ins_out_meter >= -24 ?  ledon = 1 : ledon = 0; ledon ? rgb(50,255,50) : rgb(30,85,30);
gfx_rect(gfx_dx * 1 + gfx_dxd, gfx_d * 7, gfx_dx  - 2* gfx_dxd , gfx_d *2);
ins_out_meter >= -18 ?  ledon = 1 : ledon = 0; ledon ? rgb(50,255,50) : rgb(30,85,30);
gfx_rect(gfx_dx * 2 + gfx_dxd, gfx_d * 7, gfx_dx  - 2* gfx_dxd , gfx_d *2);
ins_out_meter >= -12 ?  ledon = 1 : ledon = 0; ledon ? rgb(50,255,50) : rgb(30,85,30);
gfx_rect(gfx_dx * 3 + gfx_dxd, gfx_d * 7, gfx_dx  - 2* gfx_dxd , gfx_d *2);
ins_out_meter >= -6 ?  ledon = 1 : ledon = 0; ledon ? rgb(50,255,50) : rgb(30,85,30);
gfx_rect(gfx_dx * 4 + gfx_dxd, gfx_d * 7, gfx_dx  - 2* gfx_dxd , gfx_d *2);
ins_out_meter >= -3 ?  ledon = 1 : ledon = 0; ledon ? rgb(50,255,50) : rgb(30,85,30);
gfx_rect(gfx_dx * 5 + gfx_dxd, gfx_d * 7, gfx_dx  - 2* gfx_dxd , gfx_d *2);
ins_out_meter >= 0 ?  ledon = 1 : ledon = 0; ledon ? rgb(50,255,50) : rgb(30,85,30);
gfx_rect(gfx_dx * 6 + gfx_dxd, gfx_d * 7, gfx_dx  - 2* gfx_dxd , gfx_d *2);

ledon = ratio2db(Plugin.result_gain) < -3 && gate_on;
ledon ? rgb(255,50,50) : rgb(85,30,30);
gfx_rect(gfx_dx * 4 + gfx_dxd, gfx_d, gfx_dx  - 2* gfx_dxd , gfx_d *2);
!ledon ? rgb(50,255,50) : rgb(30,85,30);
gfx_rect(gfx_dx * 3 + gfx_dxd, gfx_d, gfx_dx  - 2* gfx_dxd , gfx_d *2);

zoom = gfx_h / 10;
gfx_setfont(1,"Arial",6*zoom,'b');
rgb_palette(Link_group);
gfx_x = gfx_dxd; gfx_y = 0;
link_group ? gfx_drawnumber(link_group,0);

gfx_setfont(1,"Arial",7*zoom,'b');


Plugin.bypass ? (
gfx_a = 0.7;
black();
gfx_rect(0,0,gfx_w,gfx_h);
gfx_a = 1;
gfx_x = 0; gfx_y = 0;
lightgrey();
gfx_drawstr("BYPASSED");
);

mouseclick && shift ? (slider(BBypass.slider) == 0 ? slider(BBypass.slider) = 1 : slider(BBypass.slider) = 0; caller = 1);

);//EXT FLAGS










S2_sample_on == 0 ? (
gmem[16*64 + 10 + link_group] != 1 ? link_group = 0;
group_check_gfx();
caller == 1 ? (
  parameters_update_on == 0 ? (
    parameters_update();
  );
);
);
S2_sample_on = 0;










//gfx_x = 0; gfx_y = 100;
//gfx_drawnumber(20-slider7*100,0);

/*
gfx_x = 0; gfx_y = 120;
gfx_drawnumber(0.05 + (slider5/100)^3.459  * 4.95,5);

gfx_x = 0; gfx_y = 140;
startpos = 1.2;
slider5 <= 50 ? gfx_drawnumber(startpos + (slider5/100)^1.4 * (6-startpos),5);
startpos = 3.019;
slider5 > 50 ? gfx_drawnumber(startpos + ((slider5-50)/50)^2.5 * (60-startpos),5);

