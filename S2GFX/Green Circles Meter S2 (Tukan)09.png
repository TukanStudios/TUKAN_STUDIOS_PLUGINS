//This plugin uses code from cockos loudness meter:
// This effect Copyright (C) 2021 and later Cockos Incorporated
// License: LGPL - http://www.gnu.org/licenses/lgpl.html

desc:Green Circles Meter S2 (Tukan)
//tags: analysis loudness meter cockos
//author: Cockos





slider1:30<10,360>-Circle Time
slider2:4<0,6,1{LUFS S, LUFS M, LUFS I, RMS, L+R, L, R}>-Circle 1
slider3:-40<-90,-10,1>-Minimum1
slider4:-18<-40,-5>-Target1
slider5:-3<-30,-1>-Over1
slider6:3<0,6,1{LUFS S, LUFS M, LUFS I, RMS, L+R, L, R}>-Circle 2
slider7:-40<-90,-10,1>-Minimum2
slider8:-18<-40,-5>-Target2
slider9:-3<-30,-1>-Over2
slider10:0<0,6,1{LUFS S, LUFS M, LUFS I, RMS, L+R, L, R}>-Circle 3
slider11:-40<-90,-10,1>-Minimum3
slider12:-18<-40,-5>-Target3
slider13:-3<-30,-1>-Over3

slider14:-18<-32,0>-VU Calibration

slider15:10<0,30,1>-Goniometer Boost
slider16:1<0,1,1>-Goniometer on
slider17:33<0,100,1>-Goniometer Speed



filename:0,S2GFX/HD_Back.png
filename:1,S2GFX/circle.png
filename:2,S2GFX/VUMeterBIG76.png
filename:3,S2GFX/VU_Frame.png
filename:4,S2GFX/S2_logo.png

options:no_meter

import S2GFX/tk_lib.jsfx-inc
import tk-vu_lib.jsfx-inc

options:no_meter
options:gfx_hz=60
options:gmem=TukanCirclesS2
options:gfx_idle

@init
CIRCLES_VERSION = 0.9;

ext_tail_size = 10;
ext_nodenorm = 1;
gfx_ext_retina = 1;
gfx_clear=0;
ext_noinit=1;
lastCap=1;
mouse_wheel=1;
is_recording = 0; is_playing = 0; is_stopped = 1;
while_playing = 1; while_recording = 1; while_stopped = 1;
Number_input = 0;
number_input_raw = 0;
number_input_use = 0;
komma = 0;
in_key = 0;
number_input_x = 0;
number_input_y=0;
number_input_slider = 0;
number_input_min=0;
number_input_max=0;
number_input_invalid = 0;
number_input_sign=1;


s2_numbers_of_sliders = 17;
s2_numbers_of_generics = 3;
group_generics = 1000000; // fuer group_generics[bis zu 200]
sliders_old = group_generics + 16*200;
generics_old = sliders_old + 16*64;

eflag = 1;
vu_meter_only = 0;

background = 0;
circle = 0;
// rms-i, lufs-i, lra calculated 0=during playback only, 1=always
WANT_INTEGRATED_ALWAYS=0;

FONT_SZ_MIN=12;
FONT_SZ_MAX=16;
// $xRRGGBB
BG_COLOR=$x000000;
GRID_COLOR=$x7f7f7f;
TEXT_COLOR=$xffffff;
PEAK_COLOR=$x3fff3f;
PEAK_CLIP_COLOR=$xff0000;
RMS_COLOR=$x7f7f7f;
LUFS_COLOR=$x00bfff;
LUFS_HIST_COLOR=$x005f7f;
RED_COLOR=$xff0000;
YELLOW_COLOR=$xffff00;
MONO_COLOR=$xffa500;

PEAK_METER_DECAY=0.150;
LOUD_METER_UPDATE=0.100; // default 100ms, must be divisible into both 0.4 and 3.0
LOUD_METER_SPEED=0.075;

UI_SLIDER_MASK=(1<<15)-1;

//ext_noinit=1;
//ext_nodenorm=1;
//gfx_ext_retina=max(gfx_ext_retina,1);

sliders_showing=0;

NUM_BINS=1024;
BINS_PER_DB=10;
DB_PER_BIN=1/BINS_PER_DB;

REAPER_MAX_CHANNELS=64;





mouse_sensivity();


  //cmx = 100; // 300 500 700 cmr = 82;
  //Parameter_config                 (slider_  default_ minVal_ maxVal_ xIn_ yIn_ wIn   frames_ scaling_ file_) 
       KC1circle.parameter_config     (3,       -40,      -90,    -10,   100-82,  168, 164, 200,    1,  40);
       KC1target.parameter_config     (4,       -18,      -40,    -5,    25, 412, 45, 200,    1,  40);
       KC1over.parameter_config       (5,       -3,       -30,    -1,    125, 412, 45, 200,    1,  40);
       KC2circle.parameter_config     (7,       -40,      -90,    -10,   300-82, 168, 164, 200,    1,  40);
       KC2target.parameter_config     (8,       -18,      -40,    -5,    225, 412, 45, 200,    1,  40);
       KC2over.parameter_config       (9,       -3,       -30,    -1,    325, 412, 45, 200,    1,  40);
       KC3circle.parameter_config     (11,       -40,      -90,    -10,  500-82, 168, 164, 200,    1,  40);
       KC3target.parameter_config     (12,       -18,      -40,    -5,   425, 412, 45, 200,    1,  40);
       KC3over.parameter_config       (13,       -3,       -30,    -1,   525, 412, 45, 200,    1,  40);
       
       KCircle_time.parameter_config  (1,       60,       10,    360,    15,66, 45, 200,    1,  40);
       Kgonio_Speed.parameter_config  (17,       33,       0,    100,    625, 357, 45, 200,    1,  40);
       KGonio_boost.parameter_config (15,       10,       0,    30,      725, 357, 45, 200,    1,  40);
       KVU_calib.parameter_config     (14,       -18,       -32,    0,   582, 66, 45, 200,    1,  40);
       
       Kgonio_on.button_config(16,0,0);
/* 

 
 gfx_rect(25, 432,10,10);
 gfx_rect(25+100, 432,10,10);
 
 gfx_rect(200+25, 432,10,10);
 gfx_rect(200+25+100, 432,10,10);
 
 gfx_rect(400+25, 432,10,10);
 gfx_rect(400+25+100, 432,10,10);
 
 gfx_rect(600+25, 377,10,10);
 gfx_rect(600+25+100, 377,10,10);
 
 gfx_rect(15, 86,10,10);
 gfx_rect(582, 86,10,10);
 */



/*
slider1:cfg_peak=4<0,4,1{off,true peak,true peak clips,peak,peak clips}>-Peak
slider2:cfg_rms_m=0<0,1,1{off,on}>-RMS momentary
slider3:cfg_rms_i=0<0,1,1{off,on}>-RMS integrated
slider4:cfg_lufs_m=2<0,2,1{off,on,on + histogram}>-LUFS momentary
slider5:cfg_lufs_s=1<0,1,1{off,on}>-LUFS short-term
slider6:cfg_lra=1<0,1,1{off,on}>-LRA loudness range
slider7:cfg_lufs_i=1<0,1,1{off,on}>-LUFS integrated
slider8:cfg_alert=0<0,3,1{off,yellow,red,yellow + red>-LUFS alerts
slider9:cfg_yellow=-12<-60,0>-Yellow alert level
slider10:cfg_red=-6<-60,0>-Red alert level
slider11:cfg_reinit=1<0,1,1{off,on}>-Reset on playback start
slider12:cfg_mono=0<0,1,1{off,on}>-Force mono analysis
slider13:cfg_textsize=0<-2,8,1>-Text size
slider14:cfg_yscale=1.8<0.5,4,0.1>-Y axis scaling
slider15:cfg_out_auto=0<0,16,1{off,all,all (inverted),Peak,Peak (inverted),RMS-M,RMS-M (inverted),RMS-I,RMS-I (inverted),LUFS-M,LUFS-M (inverted),LUFS-S,LUFS-S (inverted),LUFS-I,LUFS-I (inverted),LRA,LRA (inverted)}>-Output loudness values as automation

slider30:outparm_peak=-150<-150,20,1>-Peak/True peak dB (output)
slider31:outparm_rms_m=-100<-100,0,1>-RMS-M (output)
slider32:outparm_rms_i=-100<-100,0,1>-RMS-I (output)
slider33:outparm_lufs_m=-100<-100,0,1>-LUFS-M (output)
slider34:outparm_lufs_s=-100<-100,0,1>-LUFS-S (output)
slider35:outparm_lufs_i=-100<-100,0,1>-LUFS-I (output)
slider36:outparm_lufs_lra=0<0,100,1>-LRA (output)
*/
cfg_peak=1;//<0,4,1{off,true peak,true peak clips,peak,peak clips}>-Peak
cfg_rms_m=1;//<0,1,1{off,on}>-RMS momentary
cfg_rms_i=0;//<0,1,1{off,on}>-RMS integrated
cfg_lufs_m=1;//<0,2,1{off,on,on + histogram}>-LUFS momentary
cfg_lufs_s=1;//<0,1,1{off,on}>-LUFS short-term
cfg_lra=1;//<0,1,1{off,on}>-LRA loudness range
cfg_lufs_i=1;//<0,1,1{off,on}>-LUFS integrated
cfg_alert=0;//<0,3,1{off,yellow,red,yellow + red>-LUFS alerts
cfg_yellow=-12;//<-60,0>-Yellow alert level
cfg_red=-6;//<-60,0>-Red alert level
cfg_reinit=1;//<0,1,1{off,on}>-Reset on playback start
cfg_mono=0;//<0,1,1{off,on}>-Force mono analysis
cfg_textsize=0;//<-2,8,1>-Text size
cfg_yscale=1.8;//<0.5,4,0.1>-Y axis scaling
cfg_out_auto=0;//<0,16,1{off,all,all (inverted),Peak,Peak (inverted),RMS-M,RMS-M (inverted),RMS-I,RMS-I (inverted),LUFS-M,LUFS-M (inverted),LUFS-S,LUFS-S (inverted),LUFS-I,LUFS-I (inverted),LRA,LRA (inverted)}>-Output loudness values as automation




function feed_meter_force(in_spl) 
instance (U_Val dB_Val dB_Val_Max S2_meter_fallback)
(
    this.U_Val=abs(in_spl);
    this.dB_Val = ratio2db(this.U_Val);
    this.dB_Val_Max = max(this.dB_Val_Max,this.dB_Val);
    this.dB_Val_Max_GR = min(this.dB_Val_Max_GR,this.dB_Val);
);











// sinc filter for true peak
function sinc_gen_val() global(srate) local(sincpos windowpos) instance(slice_pos) (
  windowpos = (2.0 * $pi / 16/*SINC_FILTER_SIZE*/) * slice_pos;
  sincpos = $pi * (slice_pos - 16/*SINC_FILTER_SIZE*/ * .5);
  slice_pos += 1;
  (0.53836 - cos(windowpos)*0.46164) * sin(sincpos) / sincpos;
);

function sinc_gen_slice(cs, o*) instance(sinc_gen_val slice_pos) global() (
  slice_pos = cs;
  o.v00 = sinc_gen_val(); o.v01 = sinc_gen_val(); o.v02 = sinc_gen_val(); o.v03 = sinc_gen_val();
  o.v04 = sinc_gen_val(); o.v05 = sinc_gen_val(); o.v06 = sinc_gen_val(); o.v07 = sinc_gen_val();
  o.v08 = sinc_gen_val(); o.v09 = sinc_gen_val(); o.v10 = sinc_gen_val(); o.v11 = sinc_gen_val();
  o.v12 = sinc_gen_val(); o.v13 = sinc_gen_val(); o.v14 = sinc_gen_val(); o.v15 = sinc_gen_val();
);

function sinc_init() global(srate) instance(sinc_gen_slice) (
  sinc_gen_slice(srate < 96000 ? .25 : .5,this.s1);
  srate < 96000 ? (
    sinc_gen_slice(.5, this.s2);
    sinc_gen_slice(.75, this.s3);
  );
);

function sinc_slice_abs(hist*) global() (
  abs(
    hist.h00 * this.v00 + hist.h01 * this.v01 + hist.h02 * this.v02 + hist.h03 * this.v03 +
    hist.h04 * this.v04 + hist.h05 * this.v05 + hist.h06 * this.v06 + hist.h07 * this.v07 +
    hist.h08 * this.v08 + hist.h09 * this.v09 + hist.h10 * this.v10 + hist.h11 * this.v11 +
    hist.h12 * this.v12 + hist.h13 * this.v13 + hist.h14 * this.v14 + hist.h15 * this.v15
  );
);

function alloc(sz) global()
(
  memset((this.top+=sz)-sz,0,sz);
);

function init(chidx)
(
  this.chan=chidx;
  this.wt = chidx < 3 || num_ch < 6 ? 1 : chidx == 3 ? 0 : sqrt(2);
  this.f1p1=this.f1p2=this.f2p1=this.f2p2=0;
  this.pkval=this.hipkval=this.clips=0;
  this.ch_lufs_sum=this.ch_rms_sum=0;

  this.h00 = this.h01 = this.h02 = this.h03 = this.h04 = this.h05 = this.h06 = this.h07 =
  this.h08 = this.h09 = this.h10 = this.h11 = this.h12 = this.h13 = this.h14 = this.h15 = 0;
);

function decay()
(
  this.pkval *= pk_decay;
);

function copypks() global(pk hipk clip_cnt) (
  pk[this.chan] = this.pkval;
  hipk[this.chan] = this.hipkval;
  clip_cnt[this.chan] = this.clips;
);

function proc(lspl)
  local(pspl f1p0 f2p0)
  instance(wt ch_rms_sum ch_lufs_sum pkval hipkval clips
           f1p1 f1p2 f2p1 f2p2)
  global(f1a1 f1a2 f1b0 f1b1 f1b2
         f2a1 f2a2 f2b0 f2b1 f2b2
         srate cfg_peak
         sinc.s1.sinc_slice_abs
         sinc.s2.sinc_slice_abs
         sinc.s3.sinc_slice_abs
         lval rval win_pos global_peak)
(
  cfg_peak == 1 || cfg_peak == 2 ? (
    this.h15 = this.h14; this.h14 = this.h13; this.h13 = this.h12; this.h12 = this.h11;
    this.h11 = this.h10; this.h10 = this.h09; this.h09 = this.h08; this.h08 = this.h07;
    this.h07 = this.h06; this.h06 = this.h05; this.h05 = this.h04; this.h04 = this.h03;
    this.h03 = this.h02; this.h02 = this.h01; this.h01 = this.h00; this.h00 = lspl;
  
    pspl = max(abs(this.h08), sinc.s1.sinc_slice_abs(this));
    srate < 96000 ? pspl = max(pspl,max(sinc.s2.sinc_slice_abs(this), sinc.s3.sinc_slice_abs(this)));
  ) : 
  cfg_peak == 3 || cfg_peak == 4 ? (
    pspl=abs(lspl);
  );
  cfg_peak ? (
    pspl > pkval ? (
      pkval=pspl;
      pspl > hipkval ? (
        hipkval=pspl;
        global_peak = max(global_peak,pspl);
      );
    );
    pspl > 1.0 ? clips += 1;
  );

  win_pos == 0 ? ch_rms_sum=ch_lufs_sum=0;

  rval += (ch_rms_sum += lspl*lspl);
  
  lspl *= wt;

  f1p0=lspl-f1a1*f1p1-f1a2*f1p2;
  lspl=f1b0*f1p0+f1b1*f1p1+f1b2*f1p2;
  f1p2=f1p1;
  f1p1=f1p0;
  
  f2p0=lspl-f2a1*f2p1-f2a2*f2p2;
  lspl=f2b0*f2p0+f2b1*f2p1+f2b2*f2p2;
  f2p2=f2p1;
  f2p1=f2p0;

  lval += (ch_lufs_sum += lspl*lspl);
);

function init_lufs_filters()
  local(Vh Vb db f0 Q K a0)
  global(f1a1 f1a2 f1b0 f1b1 f1b2
         f2a1 f2a2 f2b0 f2b1 f2b2 srate)
(
  // f1,f2 could be combined into a 5th order filter

  db=3.999843853973347;
  f0=1681.974450955533;
  Q=0.7071752369554196;
  K=tan($pi*f0/srate);
  Vh=pow(10, db/20);
  Vb=pow(Vh, 0.4996667741545416);
  a0=1+K/Q+K*K;
  f1a1=2*(K*K-1)/a0;
  f1a2=(1-K/Q+K*K)/a0;
  f1b0=(Vh+Vb*K/Q+K*K)/a0;
  f1b1=2*(K*K-Vh)/a0;
  f1b2=(Vh-Vb*K/Q+K*K)/a0;

  f0=38.13547087602444;
  Q=0.5003270373238773;
  K=tan($pi*f0/srate);
  f2a1=2*(K*K-1)/(1+K/Q+K*K);
  f2a2=(1-K/Q+K*K)/(1+K/Q+K*K);
  f2b0=1;
  f2b1=-2;
  f2b2=1;
);

function Reset()
(
  sinc.sinc_init();
  init_lufs_filters();

  alloc.top=0;
  pk=alloc(REAPER_MAX_CHANNELS);
  hipk=alloc(REAPER_MAX_CHANNELS);
  clip_cnt=alloc(REAPER_MAX_CHANNELS);

  m_win_cnt=0.4/LOUD_METER_UPDATE;
  s_win_cnt=3/LOUD_METER_UPDATE;

  win_pos=0;
  win_cnt=0;
  win_len=(LOUD_METER_UPDATE*srate)|0;
  i_win_len=1/(m_win_cnt*win_len);
  i_win_len2=1/(s_win_cnt*win_len);

  rms_m_sum=0;
  rms_m_db=-100;
  rms_m_db_max=-100;
  rms_i_sum=0;
  rms_i_sum_cnt=0;
  rms_i_db=-100;

  lufs_m_sum=0;
  lufs_m_sum_max=0;
  lufs_m_db=-100;
  lufs_s_sum=0;
  lufs_s_sum_max=0;
  lufs_s_db=-100;
  lufs_a_sum=0;
  lufs_a_sum_cnt=0;
  lufs_b_sum=0;
  lufs_b_sum_cnt=0;
  lra_db_diff = 0;
  lra_db_hi = lra_db_lo = lufs_i_db = lufs_m_db = lufs_s_db = -100;

  last_t=0;
  th_lufs_i=th_lufs_s=th_lufs_m=th_rms_i=th_rms_m=0;

  cur_buf=0;
  cur_buf2=0;
  rms_buf=alloc(m_win_cnt);
  lufs_buf=alloc(m_win_cnt);
  lufs_buf2=alloc(s_win_cnt);
  lufs_a_hist=alloc(2*NUM_BINS);
  lufs_b_hist=alloc(NUM_BINS);
  db_hist=alloc(75);
  db_hist_max=0;

  
  circle_lufs_m = alloc(360);
  circle_lufs_s = alloc(360);
  circle_lufs_i = alloc(360);
  circle_rms_m = alloc(360);
  circle_landr = alloc(360);
  circle_l = alloc(360);
  circle_r = alloc(360);
  historyX = alloc(40000);
  historyY = alloc(40000);
  

  
  global_peak = 0;

  ch0.init(0); ch1.init(1);
  num_ch > 2 ? ( ch2.init(2); ch3.init(3);
  num_ch > 4 ? ( ch4.init(4); ch5.init(5);
  num_ch > 6 ? ( ch6.init(6); ch7.init(7);
  num_ch > 8 ? ( ch8.init(8); ch9.init(9); ch10.init(10); ch11.init(11);
  num_ch > 12 ? ( ch12.init(12); ch13.init(13); ch14.init(14); ch15.init(15);
  num_ch > 16 ? ( ch16.init(16); ch17.init(17); ch18.init(18); ch19.init(19);
  num_ch > 20 ? ( ch20.init(20); ch21.init(21); ch22.init(22); ch23.init(23);
  num_ch > 24 ? ( ch24.init(24); ch25.init(25); ch26.init(26); ch27.init(27); ch28.init(28); ch29.init(29); ch30.init(30); ch31.init(31);
  num_ch > 32 ? ( ch32.init(32); ch33.init(33); ch34.init(34); ch35.init(35); ch36.init(36); ch37.init(37); ch38.init(38); ch39.init(39);
  num_ch > 40 ? ( ch40.init(40); ch41.init(41); ch42.init(42); ch43.init(43); ch44.init(44); ch45.init(45); ch46.init(46); ch47.init(47);
  num_ch > 48 ? ( ch48.init(48); ch49.init(49); ch50.init(50); ch51.init(51); ch52.init(52); ch53.init(53); ch54.init(54); ch55.init(55);
  num_ch > 56 ? ( ch56.init(56); ch57.init(57); ch58.init(58); ch59.init(59); ch60.init(60); ch61.init(61); ch62.init(62); ch63.init(63);
  ))))))))))));
  
  
  
  
  
  empty_buf_pos = 0;
  loop(360,
  circle_lufs_m[empty_buf_pos] = -180;
  circle_lufs_s[empty_buf_pos] = -180;
  circle_lufs_i[empty_buf_pos] = -180;
  circle_rms_m[empty_buf_pos] = -180;
  circle_landr[empty_buf_pos] = -180;
  circle_L[empty_buf_pos] = -180;
  circle_R[empty_buf_pos] = -180;
  empty_buf_pos += 1;
  );
  circle_pos = 270;
  circle_lufs_m_max = -180;
  circle_lufs_s_max = -180;
  circle_lufs_i_max = -180;
  circle_rms_m_max = -180;
  circle_landr_max = -180;
  circle_L_max = -180;
  circle_R_max = -180;
  lufs_m_meter.db_val = -180;
  
  lufs_m_meter.db_val_max = -180;
  lufs_s_meter.db_val_max = -180;
  lufs_i_meter.db_val_max = -180;
  rms_meter.db_val_max = -180;
  landr_meter.db_val_max = -180;
  left_meter.db_val_max = -180;
  right_meter.db_val_max = -180;
  
  
  mn_meter_reinit(61);
  
  LUFS_m_meter.feed_meter_force(0);
  LUFS_s_meter.feed_meter_force(0);
  LUFS_i_meter.feed_meter_force(0);
  lufs_s_meter.db_val_max = -180;
  lufs_m_meter.db_val_max = -180;
  lufs_i_meter.db_val_max = -180;
  lufs_s_meter.db_val = -180;
  lufs_m_meter.db_val = -180;
  lufs_i_meter.db_val = -180;
  rms_meter.feed_meter_force(0);
  rms_meter.db_val = -180;
  rms_meter.db_val_max = -180;
  landr_meter.feed_meter_force(0);
  landr_meter.db_val = -180;
  landr_meter.db_val_max = -180;
  left_meter.feed_meter_force(0);
  left_meter.db_val = -180;
  left_meter.db_val_max = -180;
  right_meter.feed_meter_force(0);
  right_meter.db_val = -180;
  right_meter.db_val_max = -180;
);

Reset();





















//////////////////////////////////////////////// GONIO

Scaling = 0;

   // Simple hard clipping
  //
  function clamp (signal) (max(-1, min(1, signal)));
  
  // Some radian constants to minimize per-sample calculations
  quarterPi = $PI * 0.25; //  45°
  pi        = $PI;        // 180°
  oneDot5Pi = $PI * 1.5;  // 270°
  twoPi     = $PI * 2.0;  // 360°
  
  // At 786 kHz sample rate, 20 ms = 15270 samples,
  // so 20000 samples buffer should be sufficient.
  //
  //historyX = 10000; // Stores X coordinates
  //historyY = 30000; // Stores Y coordinates
  numCoords = ceil(srate * 0.05); //0.05  # of samples ~20 ms window
  lastCoord = numCoords - 1; // To save calculations later
  
  // Things related to the display drawing colours
  //
  colourRange = 85; // Fader 0-255 --> 255/3 = 85
  colourR = 1; // Red colour default amount [0,1]
  colourG = 0; // Green colour default amount [0,1]
  colourB = 0; // Blue colour default amount [0,1]
  colourA = 0.75; // Alpha/transparency amount fixed
  //
  function setAxisHardColour () (gfx_set(1,1,1,0.4));
  function setAxisSoftColour () (gfx_set(1,1,1,0.2));
  function setDecibelColour  () (gfx_set(1,1,1,0.1));
  function setLabelColour    () (gfx_set(1,1,1,0.25));
  //
  // This sets the drawing colour of the display
  //
  // The UI fader ranges between [0,255] and its range is split into
  // three sections of an equal third (=85) each. In every section,
  // one colour is totally out and the two remaining colours fade in
  // opposite directions, i.e. one gets stronger and one drops off.
  //
  // Colour amount calculations implemented after FastLED "Spectrum"
  // hue chart rather than "Rainbow", merely for its simplicity.
  // https://github.com/FastLED/FastLED/wiki/FastLED-HSV-Colors
  // https://raw.githubusercontent.com/FastLED/FastLED/gh-pages/images/HSV-spectrum-with-desc.jpg
  //
  function tintColour () local (fraction)
  (
    // Positions 0 and 255 are always Red,
    // so no calculations necessary here.
    tint % 255 == 0 ?
    (
      colourR = 1; // full
      colourG = 0; // out
      colourB = 0; // out
    );
    
    // First third of the colour range:
    // Red falls, Green rises, no blue
    (tint > 0) && (tint < 85) ?
    (
      // How far into this third of 85 is
      // the fader, result in range [0,1]
      fraction = tint / 85;
      
      colourR = 1 - fraction; // fall
      colourG = fraction; // rise
      colourB = 0; // out
    );
    
    // Second third of the colour range:
    // No red, Green falls, Blue rises
    (tint >= 85) && (tint < 171) ?
    (
      // How far into this third of 85 is
      // the fader, result in range [0,1]
      fraction = (tint - 84) / 85;
      
      colourR = 0; // out
      colourG = 1 - fraction; // fall
      colourB = fraction; // rise
    );
    
    // Last third of the colour range:
    // Red rises, no Green, Blue falls
    (tint >= 171) && (tint < 255) ?
    (
      // How far into this third of 85 is
      // the fader, result in range [0,1]
      fraction = (tint - 170) / 85;
      
      colourR = fraction; // rise
      colourG = 0; // out
      colourB = 1 - fraction; // fall
    );
  );
  
  // This will take a regular set of L/R samples and turn them
  // into a set of X/Y coordinates for placement on the scope.
  // 
  // The samples are turned into polar coordinates, this gives
  // a rotational angle and the distance from the center, from
  // which the carthesian X/Y coordinates are then calculated.
  // 
  // Since this effect has no output pins, it's not necessary
  // to copy the input samples to variable containers, instead
  // the processing will be performed directly on the samples.
  //
  uis = 0;
  function calculateCoordinates () local (radius, angle)
  (
    // Calculate polar coordinate from input samples
    radius = sqrt(sqr(spl0) + sqr(spl1));
    radius = min(radius,sqrt(2));
    
    angle  = atan(spl1 / spl0);
    uis = radius;
    // Arctan doesn't like it if the samples are zero or lower,
    // so compensate the angle if that happens to be the case.
    angle += ((spl0 < 0 && spl1 != 0) * pi) + ((spl0 > 0 && spl1 < 0) * twoPi);
    spl0 == 0 ? angle = oneDot5Pi - (spl1 > 0) * pi;
    spl1 == 0 ? angle = (spl0 <= 0) * pi;
    
    // To make the scope display upright, add 45° to the angle
    angle += quarterPi;
    
    // Convert polar coordinate to cartesian X/Y coordinate
    spl0 = (radius * cos(angle)); // X value
    spl1 = (radius * sin(angle)); // Y value
  );
  
  // Move everything in the history back one step and add the
  // latest samples at the end. At this point, the values are 
  // not the input samples anymore, but their X/Y coordinates.
  //
  function addToHistory ()
  (
    // Shift buffers -1 i.e. to the left, loses the last value
    memcpy(historyX, historyX+1, numCoords);
    memcpy(historyY, historyY+1, numCoords);
    
    // Insert the latest values at the back of the buffers
    historyX[lastCoord] = spl0;
    historyY[lastCoord] = spl1;
  );
  
  // Paints the L/R, M/S, dB guides and labels onto the canvas
  //
  function drawIndicators () local (top, left, right, bottom, middleH, middleV)
  (
    // Switch to the main screen buffer
    gfx_dest = -1;
    
    // Draw L/R indicator axes
    //
    (axes == 1 || axes == 2 || axes == 5) ?
    (
      // Convenience variables for code readability
      top    = centerY - viewScale + 1;
      left   = centerX - viewScale + 1;
      bottom = centerY + viewScale;
      right  = centerX + viewScale;
    
      // Draw L/R axis guides
      setAxisSoftColour(); //setAxisHardColour();
      gfx_line(left, top, right, bottom, 1);
      gfx_line(left, bottom, right, top, 1);
      
      // Draw L/R labels
      labels == 1 ?
      (
        setLabelColour();
        gfx_y = top - 11;
        gfx_x = left - 12;
        gfx_drawstr("L");
        gfx_x = right + 6;
        gfx_drawstr("R");
      );
    );
    
    // Draw Mid/Side indicator axes
    //
    (axes == 3 || axes == 4 || axes == 5) ?
    (
      // Convenience variables for code readability
      top     = centerY - viewSize;
      left    = centerX - viewSize;
      bottom  = centerY + viewSize;
      right   = centerX + viewSize;
      middleH = centerX; // Horizontal = left/right
      middleV = centerY; // Vertical = up/down
      
      // Draw M/S axis guides (softer if mixed with L/R axes)
      axes == 5 ? setAxisSoftColour() : setAxisHardColour();
      gfx_line(left, middleV, right, middleV, 1);
      gfx_line(middleH, top, middleH, bottom, 1);
      
      // Draw M/+S/S- labels
      labels == 1 ?
      (
        setLabelColour();
        gfx_x = centerX + 8;
        gfx_y = centerY + viewSize - 15;
        gfx_drawstr("M");
        gfx_y = centerY + 7;
        gfx_x = centerX - viewSize + 6;
        gfx_drawstr("+S");
        gfx_x = centerX + viewSize - 22;
        gfx_drawstr("S-");
      );
    );
    
    // Draw dB indicator rings and labels
    //
    (axes == 2 || axes == 4 || axes == 5) ?
    (
      //  0 dBfs = 1.0 * viewSize = as far out as it will go
      //
      //gfx_set(0, 0, 0, 0.4);
      black(); gfx_a=1;
      //gfx_circle(centerX, centerY, viewSize, 0);
      labels == 1 ?
      (
        setLabelColour();
        gfx_y = centerY + viewScale - 4;
        gfx_x = max(centerX - viewScale - 19, 6);
        gfx_drawstr("0");
      );
      
      //
      // -3 dBfs = 0.7079457844
      //
      //gfx_set(1,1,1,0.175);
      gfx_r=gfx_b=gfx_g=0.2; gfx_a=1;
      gfx_circle(centerX, centerY, viewSize * 0.7079457844, 0, 1);
      labels == 1 ?
      (
        //setLabelColour();
        gfx_y = centerY + viewScale * 0.7079457844 - 6;
        gfx_x = max(centerX - viewScale * 0.7079457844 - 28, 6);
        gfx_drawstr("-3");
      );
      
      //
      // -6 dBfs = 0.5011872336
      //
      gfx_set(1,1,1,0.15);
      gfx_circle(centerX, centerY, viewSize * 0.5011872336, 0, 1);
      labels == 1 ?
      (
        //setLabelColour();
        gfx_y = centerY + viewScale * 0.5011872336 - 6;
        gfx_x = max(centerX - viewScale * 0.5011872336 - 28, 6);
        gfx_drawstr("-6");
      );
      
      //
      // -12 dBfs = 0.2511886432
      //
      gfx_set(1,1,1,0.1);
      gfx_circle(centerX, centerY, viewSize * 0.2511886432, 0, 1);
      labels == 1 ?
      (
        //setLabelColour();
        gfx_y = centerY + viewScale * 0.2511886432 - 5;
        gfx_x = max(centerX - viewScale * 0.2511886432 - 35, 6);
        gfx_drawstr("-12");
      );
      
      //
      // -24 dBfs = 0.06309573445
      //
      gfx_set(1,1,1,0.075);
      gfx_circle(centerX, centerY, viewSize * 0.06309573445, 0, 1);
      //
      // Leaving out -24 dBfs label because too compact
    );
  );
  
  // Draws the sample history visualizations
  //
  // Blurring the main screen buffer would not just blur the history
  // display, but also the indicators and labels. To avoid this, the
  // history display will be drawn onto a separate off-screen buffer
  // first, so it doesn't mix with the axes and labels. If no "glow"
  // is required, the off-screen buffer can be blitted directly onto
  // the main screen buffer. If "glow" activated, blit the unblurred
  // history display to yet another off-screen buffer first, blur it
  // there, and finally blit it back to the unblurred buffer and mix
  // them in alpha, i.e. make both partially transparent so they add
  // up to an evenly lit image.
  // 
  function drawHistory () local (dim, coord, offsetX, offsetY, posX, posY, lastX, lastY, thisR, thisG)
  ( 
    // Switch to off-screen frame buffer. Don't clear it, so
    // the last calculated history is still contained there.
    gfx_dest = 127;
    gfx_setimgdim(127, gfx_w, gfx_h);
    //black(); gfx_rect(0,0,gfx_w,gfx_h);
    // Dim the existing history that's still in the buffer.
    // If "glow" activated, dimming can/should be faster so
    // the mix of the two doesn't accumulate too much after
    // a few seconds. The image should not dim/decay while
    // the display is "frozen".
    (freeze != 1 && stopped != 1) ?
    (
      dim = goni_speed;//(glow == 1 ? 0.925 : 0.98);
      gfx_muladdrect(0,0,gfx_w,gfx_h, dim, dim, dim);
    );
    
    // Iterate through all buffered coordinates in the history
    coord = lastCoord;
    while
    (
      // Calculate this point's position in relation to X/Y center
      offsetX = (historyX[coord] * viewScale*(floor(0.5+(Scaling/10))+1));
      offsetY = (historyY[coord] * viewScale*(floor(0.5+(Scaling/10))+1));
      
      //offsetX = max(offsetX, -cmr*zoom);
      // Set the drawing position
      offsetY > 0 ? (
        offsetY = min(127*zoom,offsetY);
      ):(
        offsetY = max(-127*zoom,offsetY);
      );
      offsetX > 0 ? (
        offsetX = min(127*zoom,offsetX);
      ):(
        offsetX = max(-127*zoom,offsetX);
      );
      gfx_x = centerX - offsetX;
      gfx_y = centerY - offsetY;
      
      // History colour
      gfx_set(colourR, colourG, colourB, colourA, 127);
      
      // Draw point onto graph
      //gfx_x = max(gfx_x,min(gfx_x, centerX + cos(-$pi) * viewSize));
      view == 0 ? (gfx_setpixel(colourR, colourG, colourB));
      view == 1 ? (gfx_line(lastX, lastY, gfx_x, gfx_y, 1));
      view == 2 ? (gfx_lineto(centerX, centerY, 1));
      
      //gfx_circle(centerX, centerY , viewsize);
      // Save current coordinates so can be referred
      // to in next iterations when drawing lines.
      lastX = gfx_x;
      lastY = gfx_y;
      
      // Decrement iterator
      (coord -= 1) > -1;
    );
    
    // Blit the image from the off-screen buffer back to the 
    // main buffer, i.e. plugin GUI. If "glow" active, lower
    // the blitting opacity as the intensity will accumulate
    // when mixed with the later blitted "glow" image buffer.
    gfx_dest = -1;
    gfx_x = gfx_y = 0;
    gfx_a = 1;//(glow == 1 ? 0.7 : 1.0);
    gfx_blit(127,1,0);
    
    // If the history display should "glow"
    glow = 1; // GONI NEU
    glow == 1 ?
    (
      // Blit currently unblurred image to off-screen buffer
      gfx_dest = 100;
      gfx_setimgdim(100, gfx_w, gfx_h);
      gfx_a = 1.0; // full opacity before blurring
      gfx_x = gfx_y = 0;
      gfx_blit(127,1,0);
      
      // Blur it a few times, more blur runs = faster decay.
      gfx_x = gfx_y = 0;
      gfx_blurto(gfx_w, gfx_h);
      gfx_x = gfx_y = 0;
      gfx_blurto(gfx_w, gfx_h);
      gfx_x = gfx_y = 0;
      gfx_blurto(gfx_w, gfx_h);
      
      // Switch to the main buffer and blit the now blurred
      // visualization on top of what's already there, i.e.
      // indicators and un-blurred visualization.
      gfx_dest = -1;
      gfx_a = 0.3;
      gfx_x = gfx_y = 0;
      gfx_blit(100,1,0);
    );
  );

  //attack = exp(-1/(3/1000*srate));
  //release = exp(-1/(1000/1000*srate));
  //decay = 1/srate/0.6;
  k=sqrt(2);
  function GFXClear () (
  gfx_x=gfx_y=gfx_r=gfx_g=gfx_b=0; gfx_a=1;
  gfx_rectto(gfx_w,gfx_h)
  );
  gfx_clear=-1;
  p=$PI/180;
  c=1;
  s=0;
  i=0;
  Corr=1;
  Indicar=1;
  view = 1;
  tint=84;
  glow=1;
  axes=5;
  labels=0;
  //goni_speed = 1;
  
//decay*=goni_speed*4;

/////////////////////////////////////////////////////////////////// GONIO



function parameters_update () (

parameters_update_on = 1;

slider4 >= slider5 ? slider4 = slider5 -1;
slider3 >= slider4 ? slider3 = slider4 -1;

slider8 >= slider9 ? slider8 = slider9 -1;
slider7 >= slider8 ? slider7 = slider8 -1;

slider12 >= slider13 ? slider12 = slider13 -1;
slider11 >= slider12 ? slider11 = slider12 -1;

KC1circle.Parameter_Boundaries();
KC1over.Parameter_Boundaries();
KC1target.Parameter_Boundaries();
KC2circle.Parameter_Boundaries();
KC2over.Parameter_Boundaries();
KC2target.Parameter_Boundaries();
KC3circle.Parameter_Boundaries();
KC3over.Parameter_Boundaries();
KC3target.Parameter_Boundaries();

KCircle.Parameter_Boundaries();
KGonio_boost.Parameter_Boundaries();
KGonio_speed.Parameter_Boundaries();
KVU_calib.Parameter_Boundaries();

 group_generics[1] = eflag;
 group_generics[2] = cfg_peak;
 group_generics[3] = vu_meter_only;
    group_parameters();
    
 eflag = group_generics[1];
 cfg_peak = group_generics[2]; 
 vu_meter_only = group_generics[3]; 
 
circle_time = slider1;
circle1 = slider2; circle1 == 0 ? circle1 = 1 : circle1 == 1 ? circle1 = 0;
minimum1 = slider3;
target1 = slider4;
over1 = slider5;
circle2 = slider6; circle2 == 0 ? circle2 = 1 : circle2 == 1 ? circle2 = 0;
minimum2 = slider7;
target2 = slider8;
over2 = slider9;
circle3 = slider10; circle3 == 0 ? circle3 = 1 : circle3 == 1 ? circle3 = 0;
minimum3 = slider11;
target3 = slider12;
over3 = slider13;

tintColour();

  attack = exp(-1/(3/1000*srate));
  release = exp(-1/(1000/1000*srate));
  decay = 1/srate/0.6;
  gonispeed_percent = slider17;
  goni_speed = 1-(gonispeed_percent*0.008 + 0.1);
  
decay*=goni_speed*4;

VU_Calib = db2ratio(abs(slider14));
VU_Calib_gfx = slider14;
goniometer_boost = db2ratio(slider15);
goniometer_on = slider16;

caller = 0;
parameters_update_on = 0;
);








@slider
caller = 1;








@serialize
file_var(0, while_playing);
file_var(0, while_recording);
file_var(0, while_stopped);
file_var(0, link_group);
file_var(0, CIRCLES_VERSION);
file_var(0, eflag);
file_var(0, VU_Meter_only);
file_var(0, cfg_peak);
seriloop = 0;
loop(64*16 + 27 + 16,
file_var(0, gmem[seriloop]);
seriloop += 1;
);

seriloop = 0;
loop(200*16,
file_var(0, group_generics[seriloop]);
seriloop += 1;
);









@block

want_reset =
  (num_ch > 0 && num_ch != last_nch) ||
  srate != last_sr;
last_nch=num_ch;
last_sr=srate;

cfg_reinit && (play_state&1) ? (
  abs(play_position-last_play_pos) > 0.1 ? want_reset=1;
  last_play_pos=play_position+samplesblock/srate;
);

want_reset ? Reset();

pk_decay=pow(0.5, samplesblock/srate/PEAK_METER_DECAY);

ch0.decay(); ch1.decay();
num_ch > 2 ? ( ch2.decay(); ch3.decay();
num_ch > 4 ? ( ch4.decay(); ch5.decay();
num_ch > 6 ? ( ch6.decay(); ch7.decay();
num_ch > 8 ? ( ch8.decay(); ch9.decay(); ch10.decay(); ch11.decay();
num_ch > 12 ? ( ch12.decay(); ch13.decay(); ch14.decay(); ch15.decay();
num_ch > 16 ? ( ch16.decay(); ch17.decay(); ch18.decay(); ch19.decay();
num_ch > 20 ? ( ch20.decay(); ch21.decay(); ch22.decay(); ch23.decay();
num_ch > 24 ? ( ch24.decay(); ch25.decay(); ch26.decay(); ch27.decay(); ch28.decay(); ch29.decay(); ch30.decay(); ch31.decay();
num_ch > 32 ? ( ch32.decay(); ch33.decay(); ch34.decay(); ch35.decay(); ch36.decay(); ch37.decay(); ch38.decay(); ch39.decay();
num_ch > 40 ? ( ch40.decay(); ch41.decay(); ch42.decay(); ch43.decay(); ch44.decay(); ch45.decay(); ch46.decay(); ch47.decay();
num_ch > 48 ? ( ch48.decay(); ch49.decay(); ch50.decay(); ch51.decay(); ch52.decay(); ch53.decay(); ch54.decay(); ch55.decay();
num_ch > 56 ? ( ch56.decay(); ch57.decay(); ch58.decay(); ch59.decay(); ch60.decay(); ch61.decay(); ch62.decay(); ch63.decay();
))))))))))));

function make_output_slider(b, base) ( cfg_out_auto>=2 && !(cfg_out_auto&1) ? base - b : b );
outparm_lufs_m = make_output_slider(lufs_m_db + (cfg_mono ? -3 : 0),-100);
outparm_lufs_s = make_output_slider(lufs_s_db + (cfg_mono ? -3 : 0),-100);
outparm_lufs_i = make_output_slider(lufs_i_db + (cfg_mono ? -3 : 0),-100);
outparm_lufs_lra = make_output_slider(lra_db_diff,100);
outparm_peak = make_output_slider(global_peak > 0 ? log(global_peak)*20/log(10) : -150,-150);
outparm_rms_m = make_output_slider(rms_m_db + (cfg_mono ? -3 : 0),-100);
outparm_rms_i = make_output_slider(rms_i_db + (cfg_mono ? -3 : 0),-100);

cfg_out_auto ? slider_automate(
  cfg_out_auto > 2 ? (2^(29 + floor((cfg_out_auto-3)/2))) : (
    2^29 | // (true) peak
    2^30 | // rms-m
    2^31 | // rms-i
    2^32 | // lufs-m
    2^33 | // lufs-s
    2^34 | // lufs-i
    2^35 | // lra
    0
  )
);





  // Triggers a display freeze when project is stopped 
  // or paused in "Play/Pause" freeze mode. Responsive
  // enough if this is switched in the @block section.
  stopped = (freeze == 2 && play_state < 1) ? 1 : 0;
  stopped = 0;
  
  
  
  
  
  
  
  
@sample

S2_sample_on = 1;
gmem[16*64 + 10 + link_group] != 1 ? link_group = 0;
group_check_smpl();
caller == 1 ? (
  parameters_update_on == 0 ? (
    parameters_update();
  );
);




playstates();

process = 0;
while_playing ? is_playing ? process = 1;
while_recording ? is_recording ? process = 1;
while_stopped ? is_stopped ? process = 1;

process == 1 ? (






  Left_meter.mnmetersample(spl0*VU_Calib);
  Right_meter.mnmetersample(spl1*VU_Calib);
  Landr.mnmetersample(max(abs(spl0*VU_Calib),abs(spl1*VU_Calib)));
  

VU_Meter_only == 0 ? (
  
  
vspl0 = spl0;
vspl1 = spl1;
  // If the display is frozen, don't calculate any new
  // samples and don't mess with the history buffers.
  goniometer_on ? (
  (freeze != 1 && stopped != 1) ?
  (
  //spl0 = clamp(spl0);
  //spl1 = clamp(spl1);
  spl0 *= goniometer_boost;
  spl1 *= goniometer_boost;
    calculateCoordinates();
    addToHistory();
  );
  );
  spl0 = vspl0;
  spl1 = vspl1;
  

  // Bufering input
  inl=spl0;
  inr=spl1;
  Lr=inl-inr;
  Rr=inl+inr;


  //////////////////
  // Detect Phase //
  //////////////////
  As=abs(Lr);
  Am=abs(Rr);

  
  Am>=As ? Corr=1 : Corr=-1;     // Correlation     1.3
  Am==As && Am>0.001 ? Corr=0;   // Stabilizer      1.9
Indicor=Indicor-(Indicor-corr)*decay;



rval=lval=0;

ch0.proc(spl0); ch1.proc(spl1);
num_ch > 2 ? ( ch2.proc(spl2); ch3.proc(spl3);
num_ch > 4 ? ( ch4.proc(spl4); ch5.proc(spl5);
num_ch > 6 ? ( ch6.proc(spl6); ch7.proc(spl7);
num_ch > 8 ? ( ch8.proc(spl8); ch9.proc(spl9); ch10.proc(spl10); ch11.proc(spl11);
num_ch > 12 ? ( ch12.proc(spl12); ch13.proc(spl13); ch14.proc(spl14); ch15.proc(spl15);
num_ch > 16 ? ( ch16.proc(spl16); ch17.proc(spl17); ch18.proc(spl18); ch19.proc(spl19);
num_ch > 20 ? ( ch20.proc(spl20); ch21.proc(spl21); ch22.proc(spl22); ch23.proc(spl23);
num_ch > 24 ? ( ch24.proc(spl24); ch25.proc(spl25); ch26.proc(spl26); ch27.proc(spl27); ch28.proc(spl28); ch29.proc(spl29); ch30.proc(spl30); ch31.proc(spl31);
num_ch > 32 ? ( ch32.proc(spl32); ch33.proc(spl33); ch34.proc(spl34); ch35.proc(spl35); ch36.proc(spl36); ch37.proc(spl37); ch38.proc(spl38); ch39.proc(spl39);
num_ch > 40 ? ( ch40.proc(spl40); ch41.proc(spl41); ch42.proc(spl42); ch43.proc(spl43); ch44.proc(spl44); ch45.proc(spl45); ch46.proc(spl46); ch47.proc(spl47);
num_ch > 48 ? ( ch48.proc(spl48); ch49.proc(spl49); ch50.proc(spl50); ch51.proc(spl51); ch52.proc(spl52); ch53.proc(spl53); ch54.proc(spl54); ch55.proc(spl55);
num_ch > 56 ? ( ch56.proc(spl56); ch57.proc(spl57); ch58.proc(spl58); ch59.proc(spl59); ch60.proc(spl60); ch61.proc(spl61); ch62.proc(spl62); ch63.proc(spl63);
))))))))))));

(win_pos += 1) >= win_len ? (
  win_pos=0;
  win_cnt += 1;

  prev_rval=rms_buf[cur_buf];
  rms_buf[cur_buf]=rval;
  
  prev_lval=lufs_buf[cur_buf];
  lufs_buf[cur_buf]=lval;
  
  prev_lval2=lufs_buf2[cur_buf2];
  lufs_buf2[cur_buf2]=lval;

  (cur_buf += 1) >= m_win_cnt ? cur_buf=0;
  (cur_buf2 += 1) >= s_win_cnt ? cur_buf2=0;

  rms_m_sum += (rval-prev_rval)*i_win_len;
  lufs_m_sum += (lval-prev_lval)*i_win_len;
  lufs_s_sum += (lval-prev_lval2)*i_win_len2;
  
  WANT_INTEGRATED_ALWAYS || (play_state&1) ? (
    rms_i_sum += rms_m_sum;
    rms_i_sum_cnt += 1;
    rms_i_sum > 0 && rms_i_sum_cnt >= m_win_cnt ? (
      rms_i_db=log(rms_i_sum/rms_i_sum_cnt)*10/log(10);
    ) : (
      rms_i_db=-100;
    );
  );
  
  rms_m_sum > 0 && win_cnt >= m_win_cnt ? (
    rms_m_db=log(rms_m_sum)*10/log(10);
    rms_m_db > rms_m_db_max ? rms_m_db_max=rms_m_db;
  ) : (
    rms_m_db=-100;
  );
  
  lufs_m_sum > 0 && win_cnt >= m_win_cnt ? (
    lufs_m_sum > lufs_m_sum_max ? lufs_m_sum_max=lufs_m_sum;
    lufs_m_db=-0.691+log(lufs_m_sum)*10/log(10);

    a = WANT_INTEGRATED_ALWAYS || (play_state&1) ? ((lufs_m_db+70)*BINS_PER_DB)|0 : -1;
    a >= 0 ? (
      a >= NUM_BINS ? a=NUM_BINS-1;
      lufs_a_sum += lufs_m_sum;
      lufs_a_sum_cnt += 1;
      lufs_a_hist[2*a] += 1;
      lufs_a_hist[2*a+1] += lufs_m_sum;
      db_hist_max = max(db_hist_max,db_hist[min(a*DB_PER_BIN,74)] += 1);

      lufs_a_db=-0.691+log(lufs_a_sum/lufs_a_sum_cnt)*10/log(10);
      lufs_a_gate=((lufs_a_db-10+70)*BINS_PER_DB)|0;
      lufs_i_sum=0;
      lufs_i_cnt=0;
      bin=max(lufs_a_gate,0);
      loop(NUM_BINS-bin,
        lufs_i_cnt += lufs_a_hist[2*bin];
        lufs_i_sum += lufs_a_hist[2*bin+1];
        bin += 1;
      );
      lufs_i_db=lufs_i_sum > 0 ? -0.691+log(lufs_i_sum/lufs_i_cnt)*10/log(10) : -100;
    );
  ) : (
    lufs_m_db=-100;
  );

  lufs_s_sum > 0 && win_cnt >= s_win_cnt ? (
    lufs_s_sum > lufs_s_sum_max ? lufs_s_sum_max=lufs_s_sum;
    lufs_s_db=-0.691+log(lufs_s_sum)*10/log(10);

    b = WANT_INTEGRATED_ALWAYS || (play_state&1) ? ((lufs_s_db+70)*BINS_PER_DB)|0 : -1;
    b >= 0 ? (
      b >= NUM_BINS ? b=NUM_BINS-1;
      lufs_b_sum += lufs_s_sum;
      lufs_b_sum_cnt += 1;
      lufs_b_hist[b] += 1;

      lufs_b_db=-0.691+log(lufs_b_sum/lufs_b_sum_cnt)*10/log(10);
      lufs_b_gate=((lufs_b_db-20+70)*BINS_PER_DB)|0;

      lra_cnt=0;
      bin=max(lufs_b_gate,0);
      loop(NUM_BINS-bin,
        lra_cnt += lufs_b_hist[bin];
        bin += 1;
      );
      lra_cnt >= 20 ? (
        lra_cnt_lo=lra_cnt_hi=0;
        bin=lufs_b_gate;
        while(bin < NUM_BINS && lra_cnt_lo < lra_cnt*0.10)
        (
          lra_cnt_lo += lufs_b_hist[bin];
          bin += 1;
        );
        bin_lo=bin-1;
        bin=NUM_BINS-1;
        while(bin >= lufs_b_gate && lra_cnt_hi < lra_cnt*0.05)
        (
          lra_cnt_hi += lufs_b_hist[bin];
          bin -= 1;
        );
        bin_hi=bin+1;
        lra_db_lo=bin_lo*DB_PER_BIN-70;
        lra_db_hi=bin_hi*DB_PER_BIN-70;
        lra_db_diff = lra_db_hi-lra_db_lo;
      );
    );
  ) : (
    lufs_s_db=-100;
  );
);







play_state == 0 ? ps = 0; // stop
play_state == 1 ? ps = 1; // play
play_state == 5 ? ps = 1; // record
play_state == 2 ? ps = 2; // pause
play_state == 6 ? ps = 2; // pause record
ps_old == 0 ? ps != 0 ? (
empty_buf_pos = 0;
loop(360,
circle_lufs_m[empty_buf_pos] = -180;
circle_lufs_s[empty_buf_pos] = -180;
circle_lufs_i[empty_buf_pos] = -180;
circle_rms_m[empty_buf_pos] = -180;
circle_landr[empty_buf_pos] = -180;
circle_L[empty_buf_pos] = -180;
circle_R[empty_buf_pos] = -180;
empty_buf_pos += 1;
);
circle_pos = 270;
circle_lufs_m_max = -180;
circle_lufs_s_max = -180;
circle_lufs_i_max = -180;
circle_rms_m_max = -180;
circle_landr_max = -180;
circle_L_max = -180;
circle_R_max = -180;
lufs_m_meter.db_val = -180;

lufs_m_meter.db_val_max = -180;
lufs_s_meter.db_val_max = -180;
lufs_i_meter.db_val_max = -180;
rms_meter.db_val_max = -180;
landr_meter.db_val_max = -180;
left_meter.db_val_max = -180;
right_meter.db_val_max = -180;


);


ps_old = ps;




ps == 1 ? (

circle_cnt += 1;
circle_lufs_m_max = max(circle_lufs_m_max, lufs_m_db);
circle_lufs_s_max = max(circle_lufs_s_max, lufs_s_db);
circle_lufs_i_max = max(circle_lufs_i_max, lufs_i_db);
circle_rms_m_max = max(circle_rms_m_max, rms_m_db);
circle_landr_max = max(circle_landr_max, max(ratio2db(ch0.pkval),ratio2db(ch1.pkval)));
circle_L_max = max(circle_L_max, ratio2dB(ch0.pkval));
circle_R_max = max(circle_R_max, ratio2dB(ch1.pkval));



circle_cnt >= circle_time*srate/360 ? (
circle_cnt = 0;
circle_pos += 1;
circle_pos >= 360 ? circle_pos = 0;

circle_lufs_m[circle_pos] = circle_lufs_m_max;
circle_lufs_m_max = -180;
circle_lufs_s[circle_pos] = circle_lufs_s_max;
circle_lufs_s_max = -180;
circle_lufs_i[circle_pos] = circle_lufs_i_max;
circle_lufs_i_max = -180;
circle_rms_m[circle_pos] = circle_rms_m_max;
circle_rms_m_max = -180;

circle_landr[circle_pos] = circle_landr_max;
circle_landr_max = -180;

circle_L[circle_pos] = circle_L_max;
circle_L_max = -180;
circle_R[circle_pos] = circle_R_max;
circle_R_max = -180;

LUFS_m_meter.feed_meter_force(db2ratio(lufs_m_db));
LUFS_s_meter.feed_meter_force(db2ratio(lufs_s_db));
LUFS_i_meter.feed_meter_force(db2ratio(lufs_i_db));

);

); //kommt nicht von mir .. oder PS == 1 ? ...


Left_Meter.feed_Meter(ch0.pkval);
Right_Meter.feed_Meter(ch1.pkval);
Landr_Meter.feed_meter(max(abs(ch0.pkval), abs(ch0.pkval)));
RMS_Meter.feed_Meter(db2ratio(rms_m_db));

); // VU_Meter_only

); // Process










@gfx 803 475

ch0.copypks(); ch1.copypks();
num_ch > 2 ? ( ch2.copypks(); ch3.copypks();
num_ch > 4 ? ( ch4.copypks(); ch5.copypks();
num_ch > 6 ? ( ch6.copypks(); ch7.copypks();
num_ch > 8 ? ( ch8.copypks(); ch9.copypks(); ch10.copypks(); ch11.copypks();
num_ch > 12 ? ( ch12.copypks(); ch13.copypks(); ch14.copypks(); ch15.copypks();
num_ch > 16 ? ( ch16.copypks(); ch17.copypks(); ch18.copypks(); ch19.copypks();
num_ch > 20 ? ( ch20.copypks(); ch21.copypks(); ch22.copypks(); ch23.copypks();
num_ch > 24 ? ( ch24.copypks(); ch25.copypks(); ch26.copypks(); ch27.copypks(); ch28.copypks(); ch29.copypks(); ch30.copypks(); ch31.copypks();
num_ch > 32 ? ( ch32.copypks(); ch33.copypks(); ch34.copypks(); ch35.copypks(); ch36.copypks(); ch37.copypks(); ch38.copypks(); ch39.copypks();
num_ch > 40 ? ( ch40.copypks(); ch41.copypks(); ch42.copypks(); ch43.copypks(); ch44.copypks(); ch45.copypks(); ch46.copypks(); ch47.copypks();
num_ch > 48 ? ( ch48.copypks(); ch49.copypks(); ch50.copypks(); ch51.copypks(); ch52.copypks(); ch53.copypks(); ch54.copypks(); ch55.copypks();
num_ch > 56 ? ( ch56.copypks(); ch57.copypks(); ch58.copypks(); ch59.copypks(); ch60.copypks(); ch61.copypks(); ch62.copypks(); ch63.copypks();
))))))))))));

t=time_precise();
speed = last_t ? 1.0-pow(0.5, (t-last_t)/LOUD_METER_SPEED) : 1;
last_t=t;




function circle() (
gfx_r=gfx_g=gfx_b=0;
gfx_circle(cmx*zoom,cmy*zoom,cmr*zoom,1);
gfx_r=gfx_g=gfx_b=1;
//gfx_circle(cmx*zoom,cmy*zoom,cmr*zoom);

gfx_r=gfx_g=gfx_b = 0.8;
gfx_circle(cmx*zoom,cmy*zoom, zoom*cmr* (Low_value+target)/Low_value);
gfx_circle(cmx*zoom,cmy*zoom, zoom*cmr* (Low_value+over)/Low_value);

winkel = 0;
loop(4,
gfx_line(cmx*zoom + cos($pi*winkel)* cmr*zoom, cmy*zoom + sin($pi*winkel)* cmr*zoom, cmx*zoom + cos($pi+$pi*winkel)* cmr*zoom, cmy*zoom + sin($pi+$pi*winkel)* cmr*zoom);
winkel += 0.25;
);



 gfx_setimgdim(126,0,0);
 gfx_setimgdim(126,2.2*cmr*zoom,2.2*cmr*zoom);
 gfx_dest = 126;
 //gfx_set(0,0,0,1,0,126);
 black(); gfx_a = 1; gfx_circle(cmr*zoom, cmr*zoom, cmr*zoom, 1);
 cmx_function = cmr;
 cmy_function = cmr;
 
 gfx_r = gfx_b=0;
 circle_loop_pos = circle_pos+1;
 gfx_a_loop = 0.1;
 
 loop(360,
 gfx_g = gfx_a_loop; //floor(100*gfx_a_loop)/100;
 circle_loop_pos >=  360 ? circle_loop_pos = 0;
 rad_c_pos = 2*$pi*(circle_loop_pos/360);
 c_x_old = c_x; c_y_old = c_y;
 c_x_t_old = c_x_t; c_y_t_old = c_y_t;
 c_x_o_old = c_x_o; c_y_o_old = c_y_o;
 
 cinput == 0 ? take_value = circle_lufs_m[circle_loop_pos];
 cinput == 1 ? take_value = circle_lufs_s[circle_loop_pos];
 cinput == 2 ? take_value = circle_lufs_i[circle_loop_pos];
 cinput == 3 ? take_value = circle_rms_m[circle_loop_pos];
 cinput == 4 ? take_value = circle_landr[circle_loop_pos];
 cinput == 5 ? take_value = circle_L[circle_loop_pos];
 cinput == 6 ? take_value = circle_R[circle_loop_pos];
 
 auslenkung = max(0,(Low_value+take_value)/Low_value);
 auslenkung > 1.001 ? auslenkung = 0;
 c_x = cmx_function + cos(rad_c_pos)* cmr * auslenkung;
 c_y = cmy_function + sin(rad_c_pos)* cmr * auslenkung;
 
 circle_loop_pos == circle_pos+1 ? (c_x_old = c_x; c_y_old = c_y);
 
 gfx_triangle(cmx_function*zoom,cmy_function*zoom, c_x*zoom,c_y*zoom, c_x_old*zoom, c_y_old*zoom);
 
 circle_loop_pos += 1;
 gfx_a_loop += 0.5/360;
 );
 
 gfx_a_loop = 0.1;
 circle_loop_pos = circle_pos+1;
 loop(360,
 gfx_g = gfx_a_loop; //floor(100*gfx_a_loop)/100;
 
 circle_loop_pos >=  360 ? circle_loop_pos = 0;
 rad_c_pos = 2*$pi*(circle_loop_pos/360);
 rad_c_pos_old = 2*$pi*((circle_loop_pos-1)/360);
 
 c_x_old = c_x; c_y_old = c_y;
 
 cinput == 0 ? take_value = circle_lufs_m[circle_loop_pos];
 cinput == 1 ? take_value = circle_lufs_s[circle_loop_pos];
 cinput == 2 ? take_value = circle_lufs_i[circle_loop_pos];
 cinput == 3 ? take_value = circle_rms_m[circle_loop_pos];
 cinput == 4 ? take_value = circle_landr[circle_loop_pos];
 cinput == 5 ? take_value = circle_L[circle_loop_pos];
 cinput == 6 ? take_value = circle_R[circle_loop_pos];
 
 auslenkung = max(0,(Low_value+take_value)/Low_value);
 auslenkung > 1.001 ? auslenkung = 0;
 
 c_x = cmx_function + cos(rad_c_pos)* cmr * auslenkung;
 c_y = cmy_function + sin(rad_c_pos)* cmr * auslenkung;
 c_x_t = cmx_function + cos(rad_c_pos)* cmr * max(0,(Low_value+target)/Low_value);
 c_y_t = cmy_function + sin(rad_c_pos)* cmr * max(0,(Low_value+target)/Low_value);
 c_x_t_old = cmx_function + cos(rad_c_pos_old)* cmr * max(0,(Low_value+target)/Low_value);
 c_y_t_old = cmy_function + sin(rad_c_pos_old)* cmr * max(0,(Low_value+target)/Low_value);
 
 take_value >= target ? (
 gfx_g *= 2;
 auslenkung > 0 ? (
 gfx_triangle(c_x_t*zoom, c_y_t*zoom, c_x*zoom,c_y*zoom, c_x_t_old*zoom, c_y_t_old*zoom, c_x_old*zoom, c_y_old*zoom);
 ):(
 c_x = c_x_t;
 c_y = c_y_t;
 );
 ):(
 c_x = c_x_t;
 c_y = c_y_t;
 );
 
 circle_loop_pos += 1;
 gfx_a_loop += 0.5/360;
 );
 
 gfx_a_loop = 0.1;
 circle_loop_pos = circle_pos+1;
 loop(360,
 gfx_r = gfx_a_loop; gfx_g = gfx_b = 0.3 * gfx_a_loop;//floor(100*gfx_a_loop)/100;
 circle_loop_pos >=  360 ? circle_loop_pos = 0;
 rad_c_pos = 2*$pi*(circle_loop_pos/360);
 rad_c_pos_old = 2*$pi*((circle_loop_pos-1)/360);
 c_x_old = c_x; c_y_old = c_y;
 
 cinput == 0 ? take_value = circle_lufs_m[circle_loop_pos];
 cinput == 1 ? take_value = circle_lufs_s[circle_loop_pos];
 cinput == 2 ? take_value = circle_lufs_i[circle_loop_pos];
 cinput == 3 ? take_value = circle_rms_m[circle_loop_pos];
 cinput == 4 ? take_value = circle_landr[circle_loop_pos];
 cinput == 5 ? take_value = circle_L[circle_loop_pos];
 cinput == 6 ? take_value = circle_R[circle_loop_pos];
 
 auslenkung = max(0,(Low_value+take_value)/Low_value);
 auslenkung > 1.001 ? auslenkung = 0;
 
 c_x = cmx_function + cos(rad_c_pos)* cmr * auslenkung;
 c_y = cmy_function + sin(rad_c_pos)* cmr *auslenkung;
 c_x_o = cmx_function + cos(rad_c_pos)* cmr * max(0,(Low_value+over)/Low_value);
 c_y_o = cmy_function + sin(rad_c_pos)* cmr * max(0,(Low_value+over)/Low_value);
 c_x_o_old = cmx_function + cos(rad_c_pos_old)* cmr * max(0,(Low_value+over)/Low_value);
 c_y_o_old = cmy_function + sin(rad_c_pos_old)* cmr * max(0,(Low_value+over)/Low_value);
 
 take_value >= over ? (
 auslenkung > 0 ? (
 gfx_triangle(c_x_o*zoom, c_y_o*zoom, c_x*zoom,c_y*zoom, c_x_old*zoom, c_y_old*zoom, c_x_o_old*zoom, c_y_o_old*zoom);
 ):(
 c_x = c_x_o;
 c_y = c_y_o;
 rgb(155,0,150);
 gfx_triangle(cmx_function*zoom + cos(rad_c_pos)* cmr*zoom, cmy_function*zoom + sin(rad_c_pos)* cmr*zoom, cmx_function*zoom, cmy_function*zoom, cmx_function*zoom + cos(rad_c_pos_old)* cmr*zoom, cmy_function*zoom + sin(rad_c_pos_old)* cmr*zoom);
 );
 ):(
 c_x = c_x_o;
 c_y = c_y_o;
 );
 
 circle_loop_pos += 1;
 gfx_a_loop += 0.9/360;
 );

 gfx_dest = -1;
 gfx_x=cmx*zoom-cmr*zoom; gfx_y=cmy*zoom-cmr*zoom;gfx_a=0.7;
 gfx_blit(126,1,0);
 
 
 
 
 
 cinput == 3 ? take_value = RMS_Meter.dB_Val;
 cinput == 4 ? take_value = landr_Meter.dB_Val;
  cinput == 5 ? take_value = left_Meter.dB_Val;
   cinput == 6 ? take_value = right_Meter.dB_Val;
 black(); gfx_a=1;
 gfx_rect(cmx*zoom - cmr*0.9*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom);
 take_value >= over ? (
 gfx_b = gfx_g = 0.1; gfx_r = 1; gfx_a = 1;
 ): take_value >= target ? (
 gfx_g = 1; gfx_r=gfx_b=0; gfx_a = 1;
 ):( gfx_r=gfx_b=0; gfx_g=0.5; gfx_a=1);
 gfx_x = cmx*zoom - cmr*0.9*zoom; gfx_y = cmy*zoom + (cmr+47)*zoom;
 
 gfx_setfont(1,"Arial",16*zoom,'b');
 take_value >= -96 ? (
 #myreadout = sprintf(#, "%.1f", take_value,1);
 ):(#myreadout = "- - -");
 gfx_drawstr(#myreadout, 0x05, gfx_x+45*zoom, gfx_y + 25*zoom);
 lightgrey();
 gfx_roundrect(cmx*zoom - cmr*0.9*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom,0);
 
 cinput == 0 ? take_value = LUFS_m_meter.dB_Val_Max;
 cinput == 1 ? take_value = LUFS_s_meter.dB_Val_Max;
 cinput == 2 ? take_value = LUFS_i_meter.dB_Val_Max;
 cinput == 3 ? take_value = RMS_Meter.dB_Val_Max;
 cinput == 4 ? take_value = landr_Meter.dB_Val_Max;
  cinput == 5 ? take_value = left_Meter.dB_Val_Max;
   cinput == 6 ? take_value = right_Meter.dB_Val_Max;
 black(); gfx_a=1;
 gfx_rect(cmx*zoom + cmr*0.9*zoom - 45*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom);
 take_value >= over ? (
 gfx_b = gfx_g = 0.1; gfx_r = 1; gfx_a = 1;
 ): take_value >= target ? (
 gfx_g = 1; gfx_r=gfx_b=0; gfx_a = 1;
 ):( gfx_r=gfx_b=0; gfx_g=0.5; gfx_a=1);
 gfx_x = cmx*zoom + cmr*0.9*zoom - 45*zoom; gfx_y = cmy*zoom + (cmr+47)*zoom;
 
 gfx_setfont(1,"Arial",16*zoom,'b');
 take_value >= -96 ? (
 #myreadout = sprintf(#, "%.1f", take_value,1);
 ):(#myreadout = "- - -");
 gfx_drawstr(#myreadout, 0x05, gfx_x+45*zoom, gfx_y + 25*zoom);
 lightgrey();
 gfx_roundrect(cmx*zoom + cmr*0.9*zoom  -45*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom,0);
 
 gfx_x = cmx * zoom - cmr*zoom;
 gfx_y = cmy * zoom - cmr*zoom - 35*zoom;
 cinput == 0 ? #myreadout = "LUFS (M)";
 cinput == 1 ? #myreadout = "LUFS (S)";
 cinput == 2 ? #myreadout = "LUFS (I)";
 cinput == 3 ? #myreadout = "RMS";
 cinput == 4 ? #myreadout = "LEFT & RIGHT";
 cinput == 5 ? #myreadout = "LEFT";
 cinput == 6 ? #myreadout = "RIGHT";
 gfx_drawstr(#myreadout, 0x05, gfx_x+2*cmr*zoom, gfx_y + gfx_texth);
 
 
 black(); gfx_a=1;
 gfx_rect(cmx*zoom - cmr*0.9*zoom, cmy*zoom + (cmr+100)*zoom, 45*zoom, 25*zoom); //Target
 gfx_rect(cmx*zoom + cmr*0.9*zoom - 45*zoom, cmy*zoom + (cmr+100)*zoom, 45*zoom, 25*zoom); //over
 lightgrey();
 gfx_roundrect(cmx*zoom - cmr*0.9*zoom, cmy*zoom + (cmr+100)*zoom, 45*zoom, 25*zoom,0);
 gfx_roundrect(cmx*zoom + cmr*0.9*zoom  -45*zoom, cmy*zoom + (cmr+100)*zoom, 45*zoom, 25*zoom,0);
 gfx_x = cmx*zoom - cmr*0.9*zoom; gfx_y = cmy*zoom + (cmr+102)*zoom;
 #myreadout = sprintf(#, "%.1f", target,1);
 rgb(30,130,30);
 gfx_drawstr(#myreadout, 0x05, gfx_x+45*zoom, gfx_y + 25*zoom);
 gfx_x = cmx*zoom + cmr*0.9*zoom -45*zoom; gfx_y = cmy*zoom + (cmr+102)*zoom;
 #myreadout = sprintf(#, "%.1f", over,1);
 rgb(180,50,50);
 gfx_drawstr(#myreadout, 0x05, gfx_x+45*zoom, gfx_y + 25*zoom);
 
 
 lightgrey();gfx_setfont(1,"Arial",10*zoom,'b');
 gfx_x = cmx*zoom - cmr * zoom *0.9; gfx_y = cmy*zoom + cmr * zoom + 72*zoom;
 gfx_drawstr("LIVE");
 gfx_x = cmx*zoom - cmr * zoom *0.9; gfx_y = cmy*zoom + cmr * zoom + 86*zoom;
 gfx_drawstr("TARGET");
 gfx_x = cmx*zoom + cmr * zoom *0.9 -27*zoom; gfx_y = cmy*zoom + cmr * zoom + 72*zoom;
 gfx_drawstr("PEAK");
 gfx_x = cmx*zoom + cmr * zoom *0.9 -28*zoom; gfx_y = cmy*zoom + cmr * zoom + 86*zoom;
 gfx_drawstr("OVER");
 
 
 gfx_x = cmx *zoom + cmr*0.15*zoom; gfx_y = cmy*zoom + 130*zoom;
 


 menu_x = cmx * zoom - cmr * zoom - 9*zoom; menu_y = cmy*zoom - cmr * zoom - 40*zoom; gfx_a=1;
 //gfx_blit(menu,zoom/2,0);
 lightgrey(); //red();
 gfx_roundrect(menu_x, menu_y + 5 * zoom, 20*zoom, 20*zoom, 0, 1);
 gfx_line(menu_x+3*zoom, menu_y + 11*zoom, menu_x+17*zoom, menu_y + 11*zoom);
 gfx_line(menu_x+3*zoom, menu_y + 15*zoom, menu_x+17*zoom, menu_y + 15*zoom);
 gfx_line(menu_x+3*zoom, menu_y + 19*zoom, menu_x+17*zoom, menu_y + 19*zoom);
 
 
); // end function




 function meter_show_circles() 
 instance (xIn yIn width heihgt dB_range dB_Val dB_Val_Max)
 local (dB_clipped dB_Max_clipped)
 (
  db_clipped = min(0, this.dB_Val);
  db_Max_clipped = min(0, this.db_Val_Max);
 gfx_r=gfx_b=0; gfx_g=0.5;
 db_clipped >= -this.db_range ? gfx_rect(this.xIn*zoom, this.yIn*zoom, this.width *zoom + min(db_clipped, target)*(this.width*zoom/this.db_range),this.height*zoom);
 
 db_clipped >= target ? (
 gfx_g = 1;
 gfx_x = this.xIn*zoom + this.width * zoom + target*(this.width*zoom/this.db_range);
 gfx_y = this.yIn*zoom;
 gfx_rectto(this.xIn*zoom + this.width *zoom + min(db_clipped, over)*(this.width*zoom/this.db_range), gfx_y + this.height*zoom);
 );
 
 db_clipped >= over ? (
 gfx_b = gfx_g = 0.1; gfx_r = 1; gfx_a = 1;
 gfx_x = this.xIn*zoom + this.width * zoom + over*(this.width*zoom/this.db_range);
 gfx_y = this.yIn*zoom;
 gfx_rectto(this.xIn*zoom + this.width *zoom + db_clipped*(this.width*zoom/this.db_range), gfx_y + this.height*zoom);
 );
 
 db_max_clipped >= over ? (
 gfx_b = gfx_g = 0.1; gfx_r = 1; gfx_a = 1;
 ): db_max_clipped >= target ? (
 gfx_g = 1; gfx_r=gfx_b=0; gfx_a = 1;
 ):( gfx_r=gfx_b=0; gfx_g=0.5; gfx_a=1);
 db_max_clipped >= -this.db_range ? gfx_rect(this.xIn*zoom+this.width *zoom + db_max_clipped*(this.width*zoom/this.db_range), this.yIn*zoom, min(1,2*zoom),this.height*zoom);
 
 
 );
 
 
/*
gfx_clear=((BG_COLOR&$xff)<<16)|(BG_COLOR&$xff00)|((BG_COLOR&$xff0000)>>16);

fsz=FONT_SZ_MIN+min(gfx_w/100,FONT_SZ_MAX-FONT_SZ_MIN);
fsz *= 1.0+cfg_textsize/10;
gfx_ext_retina > 1 ? fsz *= 1.5;
gfx_setfont(1,"Arial",fsz);
rsz=2*gfx_ext_retina;

xu=gfx_texth*3/4;
yu=gfx_texth*7/8;

want_vu = gfx_h > yu*7;
want_axis = gfx_h > yu*10 && gfx_w > xu*14;
want_capt = gfx_h > yu*4;

nch = cfg_mono ? 1 : max(num_ch,2);

xl=xr=xu;
want_axis ? xr += gfx_texth*2;

vh = want_vu ? gfx_h-yu*5.5 : gfx_h/2-yu;
y0 = want_vu ? gfx_h-yu*3.5 : gfx_h/2-yu*3/4;
yt = (want_vu ? y0+yu : gfx_h/2)|0;
ylo=gfx_h-yu;
yhi=yu;

want_peak = cfg_peak ? 1 : 0;
want_rms_m = cfg_rms_m ? 1 : 0;
want_rms_i = cfg_rms_i ? 1 : 0;
want_lufs_m = cfg_lufs_m ? 1 : 0;
want_lufs_s = cfg_lufs_s ? 1 : 0;
want_lra = cfg_lra ? 1 : 0;
want_lufs_i = cfg_lufs_i ? 1 : 0;

cols=want_peak*nch+want_rms_m+want_rms_i+
  want_lufs_m+want_lufs_s+want_lra*0.5+want_lufs_i;

colw = cols ? (gfx_w-xl-xr)/cols : gfx_w;
while(colw < xu*3 && cols > want_lufs_i) (
  want_peak ? ( want_peak=0; cols -= nch; ) :
  want_rms_m ? ( want_rms_m=0; cols -= 1; ) :
  want_rms_i ? ( want_rms_i=0; cols -= 1; ) :
  want_lufs_m ? ( want_lufs_m=0; cols -= 1; ) :
  want_lufs_s ? ( want_lufs_s=0; cols -= 1; ) :
  want_lra ? ( want_lra=0; cols -= 0.5; );
  colw=(gfx_w-xl-xr)/cols;
);

want_abbr = colw < gfx_texth*4;

x=gfx_w-xr-colw/2;

function draw_str(ts tx ty tc)
(
  gfx_x=tx;
  gfx_y=ty;
  gfx_drawstr(ts,tc|256,tx,ty);
);

function format_dbv(hv)
(
  hv <= -72 ? "" : sprintf(#, "%+.1f", hv);
);
function format_db(v)
(
  v <= 10^(-72/20) ? "" : format_dbv(log(v)*20/log(10));
);
function scale_db1(v) global(cfg_yscale)
(
  v <= -72 ? 0 : v >= 0 ? 1 : pow(v*1/72+1,cfg_yscale);
);
function scale_v(v) global(cfg_yscale)
(
  v <= 10^(-72/20) ? 0 : v >= 1 ? 1 : pow(log(v)*20/log(10)/72+1,cfg_yscale);
);

function set_color(trgb)
(
  gfx_set((trgb&$xff0000)/$xff0000,(trgb&$xff00)/$xff00,(trgb&$xff)/$xff);
);
function set_alert_color(tdb, trgb)
(
  (cfg_alert == 2 || cfg_alert == 3) && tdb >= cfg_red ?
    set_color(RED_COLOR) :
  (cfg_alert == 1 || cfg_alert == 3) && tdb >= cfg_yellow ?
    set_color(YELLOW_COLOR) :
    set_color(trgb);
);
function set_text_alert_color(tdb)
(
  want_vu ? set_color(TEXT_COLOR) : set_alert_color(tdb, TEXT_COLOR);
);

function draw_grid(db hhi hlo) local(th)
(
  th=scale_db1(db)*vh;
  hlo < 0 || hhi < 0 || (th > hlo+gfx_texth*5/4 && th < hhi-gfx_texth*5/4) ? (
    gfx_line(xl,y0-th,gfx_w-xr,y0-th);
    sprintf(#num,"%+.0f",db);
    want_axis ? draw_str(#num,gfx_w-xr+gfx_texth*3/4,y0-th,4);
    th;
  ) : (
    -1;
  );
);

function draw_histogram(txlo, txhi, lasty, lasttw, y, tw)
(
  gfx_triangle(txlo-lasttw,y0-lasty,txlo-tw,y0-y,txlo,y0-lasty,txlo,y0-y);
  gfx_triangle(txhi+lasttw,y0-lasty,txhi+tw,y0-y,txhi,y0-lasty,txhi,y0-y);
  gfx_line(txlo-lasttw,y0-lasty,txlo-tw,y0-y);
  gfx_line(txhi+lasttw,y0-lasty,txhi+tw,y0-y);
);

want_vu ? (
  set_color(GRID_COLOR);

  ty0=draw_grid(0,-1,-1);
  ty12=draw_grid(-12,-1,-1);
  ty24=draw_grid(-24,-1,-1);
  ty48=draw_grid(-48,-1,-1);

  ty6=draw_grid(-6,ty0,ty12);
  ty18=draw_grid(-18,ty12,ty24);
  ty36=draw_grid(-36,ty24,ty48);
  ty60=draw_grid(-60,ty48,0);

  ty3=draw_grid(-3,ty0,ty6 >= 0 ? ty6 : ty12);
  ty30=draw_grid(-30,ty24,ty36 >= 0 ? ty36 : ty24);
  ty42=draw_grid(-42,ty36 >= 0 ? ty36 : ty24,ty48);

  set_color(TEXT_COLOR);
  gfx_line(xl,y0,gfx_w-xr,y0);
);


want_lufs_i ? (
  want_capt ? (
    set_color(TEXT_COLOR);
    draw_str(!want_abbr ? "LUFS-I" : "L-I",x,yt,5);
  );
  lufs_a_sum > 0 ? (
    lufs_i_db > -100 ? (
      db = cfg_mono ? lufs_i_db-3 : lufs_i_db;
      want_vu ? (
        th_lufs_i += (scale_db1(db)-th_lufs_i)*speed;
        th=(vh*th_lufs_i)|0;
        set_alert_color(db,LUFS_COLOR);
        gfx_rect(x-colw/4,y0-th,colw/2,th);
      );
      set_text_alert_color(db);
      draw_str(format_dbv(db),x,ylo,5);
    );
  );
  x -= colw;
);

want_lra ? (
  want_capt ? (
    set_color(TEXT_COLOR);
    draw_str("LRA",x+colw/4,yt,5);
  );
  lra_db_diff > 0 ? (
    want_vu ? (
      dblo = cfg_mono ? lra_db_lo-3 : lra_db_lo;
      dbhi = cfg_mono ? lra_db_hi-3 : lra_db_hi;
      th_lo=(scale_db1(dblo)*vh)|0;
      th_hi=(scale_db1(dbhi)*vh)|0;
      set_color(LUFS_COLOR);
      gfx_rect(x+colw*3/32,y0-th_hi,colw*5/16,rsz);
      gfx_rect(x+colw*3/32,y0-th_lo,colw*5/16,rsz);
      gfx_rect(x+colw*9/32,y0-th_hi,colw/8,th_hi-th_lo+rsz); 
    );
    set_color(TEXT_COLOR);
    // lra_db_diff is always positive and close to x.y0
    draw_str(sprintf(#,"%.1f",lra_db_diff + 0.01),x+colw/4,ylo,5);
  );
  
  x -= colw/2;
);

want_lufs_s ? (
  want_capt ? (
    set_color(TEXT_COLOR);
    draw_str(!want_abbr ? "LUFS-S" : "L-S",x,yt,5);
  );
  lufs_s_db > -100 ? (
    db = cfg_mono ? lufs_s_db-3 : lufs_s_db;
    want_vu ? (
      th_lufs_s += (scale_db1(db)-th_lufs_s)*speed;
      th=(vh*th_lufs_s)|0;
      set_alert_color(db,LUFS_COLOR);
      gfx_rect(x-colw/4,y0-th,colw/2,th);
    );
    set_text_alert_color(db);
    draw_str(format_dbv(db),x,ylo,5);
  );
  lufs_s_sum_max > 0 ? (
    db=-0.691+log(lufs_s_sum_max)*10/log(10);
    cfg_mono ? db -= 3;
    want_vu ? (
      set_alert_color(db,LUFS_COLOR);
      gfx_rect(x-colw/4,y0-scale_db1(db)*vh,colw/2,rsz);
    );
    set_text_alert_color(db);
    draw_str(format_dbv(db),x,yhi,5);
  );
  x -= colw;
);

want_lufs_m ? (
  want_capt ? (
    set_color(TEXT_COLOR);
    draw_str(!want_abbr ? "LUFS-M" : "L-M",x,yt,5);
  );
  lufs_m_db > -100 ? (
    db = cfg_mono ? lufs_m_db-3 : lufs_m_db;
    want_vu ? (
      th_lufs_m += (scale_db1(db)-th_lufs_m)*speed;
      th=(vh*th_lufs_m)|0;
      set_alert_color(db,LUFS_COLOR);
      gfx_rect(x-colw/4,y0-th,colw/2,th);
    );
    set_text_alert_color(db);
    draw_str(format_dbv(db),x,ylo,5);
  );
  lufs_m_sum_max > 0 ? (
    db=-0.691+log(lufs_m_sum_max)*10/log(10);
    cfg_mono ? db -= 3;
    want_vu ? (
      set_alert_color(db,LUFS_COLOR);
      gfx_rect(x-colw/4,y0-scale_db1(db)*vh,colw/2,rsz);
    );
    set_text_alert_color(db);
    draw_str(format_dbv(db),x,yhi,5);
  );
  cfg_lufs_m == 2 && want_vu && db_hist_max > 0 ? (
    set_color(LUFS_HIST_COLOR);
    txlo=x-colw/4-3;
    txhi=x+colw/4+2;
    maxtw=colw/4-2;
    lasty=lasttw=0;
    d=cnt=0;
    loop(75,
      db = cfg_mono ? d-70-3 : d-70;
      y=scale_db1(db-0.5)*vh;
      y > lasty ? (
        tw=(cnt/db_hist_max*maxtw)|0;
        tw > 0 || lasttw > 0 ? (
          draw_histogram(txlo,txhi,lasty,lasttw,y,tw);
        );
        lasty=y;
        lasttw=tw;
        cnt=0;
      );
      cnt += db_hist[d];
      d += 1;
    );
  );
  x -= colw;
);

want_rms_i ? (
  want_capt ? (
    set_color(TEXT_COLOR);
    draw_str(!want_abbr ? "RMS-I" : "R-I",x,yt,5);
  );
  rms_i_db > -100 ? (
    db = cfg_mono ? rms_i_db-3 : rms_i_db;
    want_vu ? (
      th_rms_i += (scale_db1(db)-th_rms_i)*speed;
      th=(vh*th_rms_i)|0;
      set_color(RMS_COLOR);
      gfx_rect(x-colw/4,y0-th,colw/2,th);
    );
    set_color(TEXT_COLOR);
    draw_str(format_dbv(db),x,ylo,5);
  );
  x -= colw;
);

want_rms_m ? (
  want_capt ? (
    set_color(TEXT_COLOR);
    draw_str(!want_abbr ? "RMS-M" : "R-M",x,yt,5);
  );
  rms_m_db > -100 ? (
    db = cfg_mono ? rms_m_db-3 : rms_m_db;
    want_vu ? (
      th_rms_m += (scale_db1(db)-th_rms_m)*speed;
      th=(vh*th_rms_m)|0;
      set_color(RMS_COLOR);
      gfx_rect(x-colw/4,y0-th,colw/2,th);
    );
    set_color(TEXT_COLOR);
    draw_str(format_dbv(db),x,ylo,5);
  );
  rms_m_db_max > -100 ? (
    db = cfg_mono ? rms_m_db_max-3 : rms_m_db_max;
    want_vu ? (
      set_color(RMS_COLOR);
      gfx_rect(x-colw/4,y0-scale_db1(db)*vh,colw/2,rsz);
    );
    set_color(TEXT_COLOR);
    draw_str(format_dbv(db),x,yhi,5);
  );
  x -= colw;
);

want_peak ? (
  want_capt ? (
    set_color(TEXT_COLOR);
    label = cfg_peak == 1 ? (!want_abbr && !cfg_mono ? "True Peak" : "TPeak") :
       cfg_peak == 2 ? (!want_abbr && !cfg_mono ? "True Peak Clips" : "TPClip") :
       cfg_peak == 4 ? (!want_abbr && !cfg_mono ? "Peak Clips" : "Clip") :
       "Peak";
    draw_str(label,x-(nch-1)*colw/2,yt,5);
  );
  ch=nch-1;
  loop(nch,
    pk[ch] > 0 ? (
      pv=pk[ch];
      want_vu ? (
        th=(vh*scale_v(pv))|0;
        set_color(PEAK_COLOR);
        gfx_rect(x-colw/4,y0-th,colw/2,th);
      );
      cfg_peak == 1 || cfg_peak == 3 ? (
        set_color(!want_vu && pv > 1 ? PEAK_CLIP_COLOR : TEXT_COLOR);
        draw_str(format_db(pv),x,ylo,5);
      ) : (
        clips=clip_cnt[ch];
        set_color(!want_vu && clips ? PEAK_CLIP_COLOR : TEXT_COLOR);
        draw_str(clips > 999 ? ">999" : sprintf(#,"%d",clips),x,ylo,5);
      );
    );
    hipk[ch] > 0 ? (
      hv=hipk[ch];
      want_vu ? (
        set_color(hv > 1 ? PEAK_CLIP_COLOR : PEAK_COLOR);
        gfx_rect(x-colw/4,y0-vh*scale_v(hv),colw/2,rsz);
      );
      set_color(!want_vu && hv > 1 ? PEAK_CLIP_COLOR : TEXT_COLOR);
      draw_str(format_db(hv),x,yhi,5)
    );
    x -= colw;
    ch -= 1;
  );
);


has_click = (mouse_cap&1) && !(last_cap&1) ? 1 : 0;
last_cap=mouse_cap;

want_axis && !(gfx_ext_flags&1) ? (
  set_color(MONO_COLOR);
  tc1=(gfx_w-gfx_texth*27/16)|0;
  tc2=(gfx_w-gfx_texth*21/16)|0;
  tr=(gfx_texth*7/16)|0;
  cfg_mono ? gfx_mode = 1;
  gfx_circle(tc1,yt,tr,cfg_mono?1:0,0);
  gfx_circle(tc2,yt,tr,cfg_mono?1:0,0);
  cfg_mono ? (
    set_color(BG_COLOR);
    gfx_x=tc1-tr; gfx_y=yt-tr+1;
    gfx_drawstr("M",1|4|256,tc2+tr,yt+tr+1);
  );
  has_click && abs(mouse_x-(tc1+tc2)/2) <= tr*3/2+1 && abs(mouse_y-yt) <= tr+1 ? (
    cfg_mono=!cfg_mono;
    slider_automate(cfg_mono);
    has_click=0;
  );
);
(want_axis || sliders_showing) && !(gfx_ext_flags&1) ? (
  set_color(TEXT_COLOR);
  tx=gfx_w-gfx_texth*3/2;
  gfx_rect(gfx_x=tx-gfx_texth/2,gfx_y=ylo-gfx_texth/2,gfx_texth+1,gfx_texth+1,0);
  gfx_drawstr("?",1|4,gfx_x+gfx_texth+1,gfx_y+gfx_texth+1);
  has_click && abs(mouse_x-tx) < gfx_texth/2 && abs(mouse_y-ylo) < gfx_texth/2 ? (
    sliders_showing = slider_show(UI_SLIDER_MASK,-1) > 0;
    has_click=0;
  );
);

has_click ? Reset();



*/





 mouseHold = mouse_cap & 1;
 press_superkey = mouse_cap & 32;
 press_ctrl = mouse_cap & 4;
 press_shift = mouse_cap & 8;
 press_alt = mouse_cap & 16;
 superkey=ctrl=shift=alt=shift_alt=shift_ctrl=shift_superkey=ctrl_superkey = 0;
 press_superkey ? !press_ctrl ? !press_shift ? !press_alt ? superkey=press_superkey;
 !press_superkey ? press_ctrl ? !press_shift ? !press_alt ? ctrl=press_ctrl;
 !press_superkey ? !press_ctrl ? press_shift ? !press_alt ? shift=press_shift;
 !press_superkey ? !press_ctrl ? !press_shift ? press_alt ? alt=press_alt;
 !press_superkey ? !press_ctrl ? press_shift ? press_alt ? shift_alt=1;
 !press_superkey ? press_ctrl ? press_shift ? !press_alt ? shift_ctrl=1;
 press_superkey ? !press_ctrl ? press_shift ? !press_alt ? shift_superkey=1;
 press_superkey ? press_ctrl ? !press_shift ? !press_alt ? ctrl_superkey=1;
 
 mouseClick = mouseHold - lastCap;
 lastCap = mouseHold;








gfx_ext_flags == 0 ? (

s2_zoom_X = gfx_w / 803;
s2_zoom_y = gfx_h / 475;
zoom = min(s2_zoom_x, s2_zoom_y);// * gfx_ext_retina;
zoom_off == 1 ? zoom = gfx_ext_retina;
//zoom = slider64;



/*
circle_lufs_m_max = -180;
circle_lufs_s_max = -180;
circle_lufs_i_max = -180;
circle_rms_m_max = -180;
circle_landr_max = -180;
circle_L_max = -180;
circle_R_max = -180;
*/




gfx_x=gfx_y=0;
gfx_blit(0,zoom*0.5,0);


//black(); gfx_rect(0,0,gfx_w, gfx_h);
target = target1;
over = over1;
Low_value = abs(minimum1); // kreis mittelpunkt
cmx = 100; cmy = 250; //mittelpunkt in px
cmr = 82; //radius
cinput = circle1; // wird die Input auswahl---
circle(); zcor = 10;
gfx_x = cmx * zoom - cmr * zoom -  zcor*zoom;
gfx_y = cmy * zoom - cmr * zoom - zcor*zoom;
gfx_blit(1, zoom*0.5,0); // frame


black(); gfx_a = 1; gfx_rect(cmx*zoom - 0.9*cmr*zoom, cmy*zoom + cmr*zoom +25*zoom, cmr*zoom * 0.9 * 2, 12*zoom);
circle1 == 0 ? (
LUFS_m_Meter.meter_config(cmx - 0.9*cmr,cmy + cmr +25, 2*cmr*0.9, 12, Low_value, 0);
LUFS_m_meter.meter_show_circles();
):circle1 == 1 ? (
LUFS_s_Meter.meter_config(cmx - 0.9*cmr,cmy + cmr +25, 2*cmr*0.9, 12, Low_value, 0);
LUFS_s_meter.meter_show_circles();
):circle1 == 2 ? (
LUFS_i_Meter.meter_config(cmx - 0.9*cmr,cmy + cmr +25, 2*cmr*0.9, 12, Low_value, 0);
LUFS_i_meter.meter_show_circles();
):circle1 == 3 ? (
RMS_Meter.meter_config(cmx - 0.9*cmr,cmy + cmr +25, 2*cmr*0.9, 12, Low_value, 20);
RMS_meter.meter_show_circles();
):circle1 == 4 ? (
Landr_Meter.meter_config(cmx - 0.9*cmr,cmy + cmr +25, 2*cmr*0.9, 12, Low_value, 20);
landr_meter.meter_show_circles();
):circle1 == 5 ? (
Left_Meter.meter_config(cmx - 0.9*cmr,cmy + cmr +25, 2*cmr*0.9, 12, Low_value, 20);
left_meter.meter_show_circles();
):circle1 == 6 ? (
right_Meter.meter_config(cmx - 0.9*cmr,cmy + cmr +25, 2*cmr*0.9, 12, Low_value, 20);
right_meter.meter_show_circles();
);
lightgrey(); gfx_a = 1; gfx_roundrect(cmx*zoom - 0.9*cmr*zoom, cmy*zoom + cmr*zoom +25*zoom, cmr*zoom * 0.9 * 2, 12*zoom, 0);
 gfx_roundrect(cmx * zoom - cmr*zoom - 14*zoom, cmy * zoom - cmr*zoom - 42*zoom, cmr*2*zoom + 28*zoom, 343*zoom, 7*zoom);


target = target2;
over = over2;
Low_value = abs(minimum2); // kreis mittelpunkt
cmx = 300; cmy = 250; //mittelpunkt in px
cmr = 82; //radius
cinput = circle2; // wird die Input auswahl---
circle();
gfx_x = cmx * zoom - cmr * zoom -  zcor*zoom;
gfx_y = cmy * zoom - cmr * zoom - zcor*zoom;
gfx_blit(1, zoom*0.5,0); // frame

black(); gfx_a = 1; gfx_rect(cmx*zoom - 0.9*cmr*zoom, cmy*zoom + cmr*zoom +25*zoom, cmr*zoom * 0.9 * 2, 12*zoom);
circle2 == 0 ? (
LUFS_m_Meter.meter_config(cmx - 0.9*cmr,cmy + cmr +25, 2*cmr*0.9, 12, Low_value, 0);
LUFS_m_meter.meter_show_circles();
):circle2 == 1 ? (
LUFS_s_Meter.meter_config(cmx - 0.9*cmr,cmy + cmr +25, 2*cmr*0.9, 12, Low_value, 0);
LUFS_s_meter.meter_show_circles();
):circle2 == 2 ? (
LUFS_i_Meter.meter_config(cmx - 0.9*cmr,cmy + cmr +25, 2*cmr*0.9, 12, Low_value, 0);
LUFS_i_meter.meter_show_circles();
):circle2 == 3 ? (
RMS_Meter.meter_config(cmx - 0.9*cmr,cmy + cmr +25, 2*cmr*0.9, 12, Low_value, 20);
RMS_meter.meter_show_circles();
):circle2 == 4 ? (
Landr_Meter.meter_config(cmx - 0.9*cmr,cmy + cmr +25, 2*cmr*0.9, 12, Low_value, 20);
landr_meter.meter_show_circles();
):circle2 == 5 ? (
Left_Meter.meter_config(cmx - 0.9*cmr,cmy + cmr +25, 2*cmr*0.9, 12, Low_value, 20);
left_meter.meter_show_circles();
):circle2 == 6 ? (
right_Meter.meter_config(cmx - 0.9*cmr,cmy + cmr +25, 2*cmr*0.9, 12, Low_value, 20);
right_meter.meter_show_circles();
);
lightgrey(); gfx_a = 1; gfx_roundrect(cmx*zoom - 0.9*cmr*zoom, cmy*zoom + cmr*zoom +25*zoom, cmr*zoom * 0.9 * 2, 12*zoom, 0);
 gfx_roundrect(cmx * zoom - cmr*zoom - 14*zoom, cmy * zoom - cmr*zoom - 42*zoom, cmr*2*zoom + 28*zoom, 343*zoom, 7*zoom);

target = target3;
over = over3;
Low_value = abs(minimum3); // kreis mittelpunkt
cmx = 500; cmy = 250; //mittelpunkt in px
cmr = 82; //radius
cinput = circle3; // wird die Input auswahl---
circle();
gfx_x = cmx * zoom - cmr * zoom -  zcor*zoom;
gfx_y = cmy * zoom - cmr * zoom - zcor*zoom;
gfx_blit(1, zoom*0.5,0); // frame

black(); gfx_a = 1; gfx_rect(cmx*zoom - 0.9*cmr*zoom, cmy*zoom + cmr*zoom +25*zoom, cmr*zoom * 0.9 * 2, 12*zoom);
circle3 == 0 ? (
LUFS_m_Meter.meter_config(cmx - 0.9*cmr,cmy + cmr +25, 2*cmr*0.9, 12, Low_value, 0);
LUFS_m_meter.meter_show_circles();
):circle3 == 1 ? (
LUFS_s_Meter.meter_config(cmx - 0.9*cmr,cmy + cmr +25, 2*cmr*0.9, 12, Low_value, 0);
LUFS_s_meter.meter_show_circles();
):circle3 == 2 ? (
LUFS_i_Meter.meter_config(cmx - 0.9*cmr,cmy + cmr +25, 2*cmr*0.9, 12, Low_value, 0);
LUFS_i_meter.meter_show_circles();
):circle3 == 3 ? (
RMS_Meter.meter_config(cmx - 0.9*cmr,cmy + cmr +25, 2*cmr*0.9, 12, Low_value, 20);
RMS_meter.meter_show_circles();
):circle3 == 4 ? (
Landr_Meter.meter_config(cmx - 0.9*cmr,cmy + cmr +25, 2*cmr*0.9, 12, Low_value, 20);
landr_meter.meter_show_circles();
):circle3 == 5 ? (
Left_Meter.meter_config(cmx - 0.9*cmr,cmy + cmr +25, 2*cmr*0.9, 12, Low_value, 20);
left_meter.meter_show_circles();
):circle3 == 6 ? (
right_Meter.meter_config(cmx - 0.9*cmr,cmy + cmr +25, 2*cmr*0.9, 12, Low_value, 20);
right_meter.meter_show_circles();
);
lightgrey(); gfx_a = 1; gfx_roundrect(cmx*zoom - 0.9*cmr*zoom, cmy*zoom + cmr*zoom +25*zoom, cmr*zoom * 0.9 * 2, 12*zoom, 0);
 gfx_roundrect(cmx * zoom - cmr*zoom - 14*zoom, cmy * zoom - cmr*zoom - 42*zoom, cmr*2*zoom + 28*zoom, 343*zoom, 7*zoom);



cmx = 700; cmy = 250; //mittelpunkt in px
cmr = 83; //radius
gfx_r=gfx_g=gfx_b=0;
gfx_circle(cmx*zoom,cmy*zoom,cmr*zoom,1);
gfx_r=gfx_g=gfx_b=1;
//gfx_circle(cmx*zoom,cmy*zoom,cmr*zoom);
  // Calculate the side length of a square centered in the window
  viewSize = cmr*zoom;//min(gfx_w, gfx_h) / 2;
  
  // The distance a dot may be from center in any
  // direction to still appear inside a circle.
  viewScale = (viewSize * 0.70710681);
  
  // The absolute center point in the current window
  centerX = cmx*zoom;//gfx_w * 0.5;
  centerY = cmy*zoom;//gfx_h * 0.5;
  
  goniometer_on ? drawHistory();
  drawIndicators();
  
  gfx_a = 1;
  gfx_x = cmx * zoom - cmr * zoom -  zcor*zoom;
  gfx_y = cmy * zoom - cmr * zoom - zcor*zoom;
  gfx_blit(1, zoom*0.5,0); // frame
  
  
  
  //size = min(gfx_w,gfx_h);
  size = cmr * 2;
  Sizi = Size*45/46/2;
  gx0=gfx_w/2;
  gx2=gx0-sizeh*1/45;
  sizeH = size/2;
  sizeQ=sizeH/2;
  size2Q=2*sizeQ;
  size3Q=3*sizeQ;
  x03=gx0-sizeh;
  shiftLed=(size>150)*15+(size<150)*4;
  step=0.004;
  
  ph=indicor;
  
  gfx_r=gfx_g=gfx_b=0; gfx_a = 1;
  gfx_rect(cmx*zoom - cmr*0.9*zoom, cmy*zoom + cmr*zoom + 25*zoom, cmr*1.8*zoom, 12*zoom);
  gfx_r=gfx_b = 0; gfx_g = 8; gfx_a = 1;
  gfx_rect(cmx*zoom + cmr*0.9 * ph*zoom - 5*zoom, cmy*zoom + cmr*zoom + 25*zoom, 5*zoom, 12*zoom);
  lightgrey(); gfx_a = 1;
 gfx_roundrect(cmx*zoom - cmr*0.9*zoom, cmy*zoom + cmr*zoom + 25*zoom, cmr*1.8*zoom, 12*zoom,0);
  
  gfx_setfont(1,"Arial",16*zoom,'b');
  gfx_x = cmx * zoom - cmr*zoom;
  gfx_y = cmy * zoom - cmr*zoom - 35*zoom;
  #myreadout = "GONIOMETER";
  gfx_drawstr(#myreadout, 0x05, gfx_x+2*cmr*zoom, gfx_y + gfx_texth);
  gfx_roundrect(cmx * zoom - cmr*zoom - 14*zoom, cmy * zoom - cmr*zoom - 42*zoom, cmr*2*zoom + 28*zoom, 343*zoom, 7*zoom);


 gfx_setfont(1,"Arial",16*zoom,'b');
 black(); gfx_a=1;
 gfx_rect(cmx*zoom - cmr*0.9*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom);
 goniometer_on ? (gfx_r=gfx_b=0; gfx_g=0.6; gfx_a=1):(gfx_r=gfx_b= gfx_g=0.3; gfx_a=1);
 gfx_x = cmx*zoom - cmr*0.9*zoom; gfx_y = cmy*zoom + (cmr+47)*zoom;
 #myreadout = sprintf(#, "%.0f", Gonispeed_percent,1);
 gfx_drawstr(#myreadout, 0x05, gfx_x+45*zoom, gfx_y + 25*zoom);
 lightgrey();
 gfx_roundrect(cmx*zoom - cmr*0.9*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom,0);
 lightgrey();gfx_setfont(1,"Arial",10*zoom,'b');
 gfx_x = cmx*zoom - cmr * zoom *0.9; gfx_y = cmy*zoom + cmr * zoom + 72*zoom;
 gfx_drawstr("SPEED");
 

 gfx_setfont(1,"Arial",16*zoom,'b');
 black(); gfx_a=1;
 gfx_rect(cmx*zoom + cmr*0.9*zoom - 45*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom);
 goniometer_on ? (gfx_r=gfx_b=0; gfx_g=0.6; gfx_a=1):(gfx_r=gfx_b= gfx_g=0.3; gfx_a=1);
 gfx_x = cmx*zoom + cmr*0.9*zoom - 45*zoom; gfx_y = cmy*zoom + (cmr+47)*zoom;
 #myreadout = sprintf(#, "%.0f", ratio2db(goniometer_boost),1);
 gfx_drawstr(#myreadout, 0x05, gfx_x+45*zoom, gfx_y + 25*zoom);
 lightgrey();gfx_setfont(1,"Arial",10*zoom,'b');
 gfx_roundrect(cmx*zoom + cmr*0.9*zoom  -45*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom,0);
 gfx_x = cmx*zoom + cmr * zoom *0.9 -36*zoom; gfx_y = cmy*zoom + cmr * zoom + 72*zoom;
 gfx_drawstr("BOOST");
 
 gfx_setfont(1,"Arial",16*zoom,'b');
 black(); gfx_a=1;
 gfx_rect(cmx*zoom - 22*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom);
 goniometer_on ? (#myreadout = "ON"; gfx_r=gfx_b=0; gfx_g=0.6; gfx_a=1):(#myreadout =  "OFF"; gfx_r=gfx_b= gfx_g=0.3; gfx_a=1);
 gfx_x = cmx*zoom - 22*zoom; gfx_y = cmy*zoom + (cmr+47)*zoom;
 gfx_drawstr(#myreadout, 0x05, gfx_x+45*zoom, gfx_y + 25*zoom);
 lightgrey();gfx_setfont(1,"Arial",10*zoom,'b');
 gfx_roundrect(cmx*zoom -22*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom,0);

 
 
 
 



black();
VUx = 435*zoom; VUy = 46*zoom;
left_meter.mnmetergfx(zoom*0.7, VUx, VUy, 2);
gfx_x = VUx -5*zoom; gfx_y = VUy - 5*zoom;
gfx_blit(3, zoom*0.35,0);
VUx += 210*zoom;
right_meter.mnmetergfx(zoom*0.7, VUx, VUy, 2);
gfx_x = VUx -5*zoom; gfx_y = VUy - 5*zoom;
gfx_blit(3, zoom*0.35,0);


 gfx_setfont(1,"Arial",16*zoom,'b');
 black(); gfx_a=1;
 gfx_rect(582*zoom, 86*zoom, 45*zoom, 25*zoom);
 gfx_x = 582*zoom; gfx_y = 87*zoom;
 #myreadout = sprintf(#, "%.1f", VU_Calib_gfx,1); gfx_r=gfx_b=0; gfx_g=0.6; gfx_a=1;
 gfx_drawstr(#myreadout, 0x05, gfx_x+45*zoom, gfx_y + 25*zoom);
 lightgrey();
 gfx_roundrect(582*zoom, 86*zoom, 45*zoom, 25*zoom,0);
 lightgrey();gfx_setfont(1,"Arial",10*zoom,'b');
 gfx_x = 584*zoom; gfx_y = 72*zoom;
 gfx_drawstr("VU Calib.");
 
 
 gfx_setfont(1,"Arial",16*zoom,'b');
 black(); gfx_a=1;
 gfx_rect(15*zoom, 86*zoom, 45*zoom, 25*zoom);
 gfx_r=gfx_b=0; gfx_g=0.6; gfx_a=1;
                  aa=0;
                  hours=0;
                  aaa=floor(circle_time);
                  while (aaa >= 60) (
                  aa += 1;
                  aaa -= 60; 
                  );
                  while (aa >= 60) (
                  hours+=1;
                  aa -= 60;
                  );
                  //#playtime = sprintf(#, "%02d" ,hours);
                  //#playtime += ":";
 #playtime = sprintf(#, "%01d",aa); // %.0f
 #playtime += ":";
 #playtime += sprintf(#, "%02d" ,aaa);
 gfx_x = 15*zoom; gfx_y = 87*zoom;
 gfx_drawstr(#playtime, 0x05, gfx_x+45*zoom, gfx_y + 25*zoom);
 lightgrey();gfx_setfont(1,"Arial",10*zoom,'b');
 gfx_x = 68*zoom; gfx_y = 92*zoom;
 gfx_drawstr("CIRCLE DURATION");
 gfx_roundrect(15*zoom, 86*zoom, 45*zoom, 25*zoom,0);
 
 
 gfx_x = 340*zoom; gfx_y = 40*zoom; gfx_a = 0.7;
 gfx_blit(4,zoom*0.6,0);
 gfx_a = 1;
 /*
 orange(); gfx_a = 1;
 cmx = 100; cmr = 82;
 gfx_roundrect(cmx*zoom - cmr*0.9*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom,0); //live
 gfx_roundrect(cmx*zoom + cmr*0.9*zoom - 45*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom,0); //Over
 gfx_roundrect(cmx*zoom - cmr*0.9*zoom, cmy*zoom + (cmr+100)*zoom, 45*zoom, 25*zoom,0); //Target
 gfx_roundrect(cmx*zoom + cmr*0.9*zoom - 45*zoom, cmy*zoom + (cmr+100)*zoom, 45*zoom, 25*zoom,0); //over
 menu_x = cmx * zoom - cmr * zoom - 9*zoom; menu_y = cmy*zoom - cmr * zoom - 40*zoom; 
 gfx_roundrect(menu_x, menu_y + 5 * zoom, 20*zoom, 20*zoom, 0); // circlemenu
 gfx_roundrect(cmx * zoom - 0.7*cmr * zoom, cmy*zoom - 0.7*cmr*zoom, 1.4*cmr*zoom, 1.4*cmr*zoom,0);
 
 
 gfx_x = gfx_y = 10;
 g_collision(cmx * zoom - 0.7*cmr * zoom, cmy*zoom - 0.7*cmr*zoom, 1.4*cmr*zoom, 1.4*cmr*zoom) ? gfx_drawstr("Circle");
 g_collision(menu_x, menu_y + 5 * zoom, 20*zoom, 20*zoom) ? gfx_drawstr("menu");
 g_collision(cmx*zoom - cmr*0.9*zoom, cmy*zoom + (cmr+100)*zoom, 45*zoom, 25*zoom) ? gfx_drawstr("target");
 g_collision(cmx*zoom + cmr*0.9*zoom - 45*zoom, cmy*zoom + (cmr+100)*zoom, 45*zoom, 25*zoom) ? gfx_drawstr("over");
 g_collision(cmx*zoom - cmr*0.9*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom) ? gfx_drawstr("Live");
 g_collision(cmx*zoom + cmr*0.9*zoom - 45*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom) ? gfx_drawstr("Over");
 */
 
 ////////////////////////////////////////////////////////////////////////////////////////////// MAUS STEUERUNG
 gfx_setfont(1,"Arial",12*zoom,'b');
       !Number_input ? (
       
 
 
       mouseClick == 1 ? (
       cmx = 100; cmr = 82;
       g_collision(cmx * zoom - 0.7*cmr * zoom, cmy*zoom - 0.7*cmr*zoom, 1.4*cmr*zoom, 1.4*cmr*zoom) ? KC1circle.dragstart();
       g_collision(cmx*zoom - cmr*0.9*zoom, cmy*zoom + (cmr+100)*zoom, 45*zoom, 25*zoom) ? KC1target.dragstart();
       g_collision(cmx*zoom + cmr*0.9*zoom - 45*zoom, cmy*zoom + (cmr+100)*zoom, 45*zoom, 25*zoom) ? KC1over.dragstart();
       g_collision(cmx*zoom - cmr*0.9*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom) ? Reset();
       g_collision(cmx*zoom + cmr*0.9*zoom - 45*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom) ? Reset();
       menu_x = cmx * zoom - cmr * zoom - 9*zoom; menu_y = cmy*zoom - cmr * zoom - 40*zoom; 
       g_collision(menu_x, menu_y + 5 * zoom, 20*zoom, 20*zoom) ? (
       #allitems = "LUFS S|LUFS M|LUFS I|RMS|Max. L/R|LEFT|RIGHT|";
       gfx_x = menu_x + 20; gfx_y = menu_y;
       last_clicked_item = gfx_showmenu(#allitems);
       last_clicked_item > 0 ? slider2 = last_clicked_item-1;
       caller = 1;
       );
       
       cmx = 300;
       g_collision(cmx * zoom - 0.7*cmr * zoom, cmy*zoom - 0.7*cmr*zoom, 1.4*cmr*zoom, 1.4*cmr*zoom) ? KC2circle.dragstart();
       g_collision(cmx*zoom - cmr*0.9*zoom, cmy*zoom + (cmr+100)*zoom, 45*zoom, 25*zoom) ? KC2target.dragstart();
       g_collision(cmx*zoom + cmr*0.9*zoom - 45*zoom, cmy*zoom + (cmr+100)*zoom, 45*zoom, 25*zoom) ? KC2over.dragstart();
       g_collision(cmx*zoom - cmr*0.9*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom) ? Reset();
       g_collision(cmx*zoom + cmr*0.9*zoom - 45*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom) ? Reset();
       menu_x = cmx * zoom - cmr * zoom - 9*zoom; menu_y = cmy*zoom - cmr * zoom - 40*zoom; 
       g_collision(menu_x, menu_y + 5 * zoom, 20*zoom, 20*zoom) ? (
       #allitems = "LUFS S|LUFS M|LUFS I|RMS|Max. L/R|LEFT|RIGHT|";
       gfx_x = menu_x + 20; gfx_y = menu_y;
       last_clicked_item = gfx_showmenu(#allitems);
       last_clicked_item > 0 ? slider6 = last_clicked_item-1;
       caller = 1;
       );
       
       cmx = 500;
       g_collision(cmx * zoom - 0.7*cmr * zoom, cmy*zoom - 0.7*cmr*zoom, 1.4*cmr*zoom, 1.4*cmr*zoom) ? KC3circle.dragstart();
       g_collision(cmx*zoom - cmr*0.9*zoom, cmy*zoom + (cmr+100)*zoom, 45*zoom, 25*zoom) ? KC3target.dragstart();
       g_collision(cmx*zoom + cmr*0.9*zoom - 45*zoom, cmy*zoom + (cmr+100)*zoom, 45*zoom, 25*zoom) ? KC3over.dragstart();
       g_collision(cmx*zoom - cmr*0.9*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom) ? Reset();
       g_collision(cmx*zoom + cmr*0.9*zoom - 45*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom) ? Reset();
       menu_x = cmx * zoom - cmr * zoom - 9*zoom; menu_y = cmy*zoom - cmr * zoom - 40*zoom; 
       g_collision(menu_x, menu_y + 5 * zoom, 20*zoom, 20*zoom) ? (
       #allitems = "LUFS S|LUFS M|LUFS I|RMS|Max. L/R|LEFT|RIGHT|";
       gfx_x = menu_x + 20; gfx_y = menu_y;
       last_clicked_item = gfx_showmenu(#allitems);
       last_clicked_item > 0 ? slider10 = last_clicked_item-1;
       caller = 1;
       );
       
       cmx = 700;
       g_collision(cmx*zoom - cmr*0.9*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom) ? Kgonio_speed.dragstart();
       g_collision(cmx*zoom + cmr*0.9*zoom  -45*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom) ? Kgonio_boost.dragstart();
       g_collision(cmx*zoom -22*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom) ? (slider16 == 0 ? slider16 = 1 : slider16 = 0; Kgonio_on.quicklink_button(); caller = 1);
       g_collision(582*zoom, 86*zoom, 45*zoom, 25*zoom) ? KVU_calib.dragstart();
       g_collision(15*zoom, 86*zoom, 45*zoom, 25*zoom) ? KCircle_time.dragstart();
       /*
       cmx*zoom - cmr*0.9*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom
       cmx*zoom + cmr*0.9*zoom  -45*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom
       cmx*zoom -22*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom
       582*zoom, 86*zoom, 45*zoom, 25*zoom
       15*zoom, 86*zoom, 45*zoom, 25*zoom
       */
       
       
       ); 
       
       mouseclick == -1 ? (
       KC1circle.dragstop();
       KC1target.dragstop();
       KC1over.dragstop();
       KC2circle.dragstop();
       KC2target.dragstop();
       KC2over.dragstop();
       KC3circle.dragstop();
       KC3target.dragstop();
       KC3over.dragstop();
       Kgonio_speed.dragstop();
       KGonio_Boost.dragstop();
       KVU_Calib.dragstop();
       KCircle_time.dragstop();
       );
       
       
       mouse_wheel ? 
           (
           cmx = 100;
       g_collision(cmx * zoom - 0.7*cmr * zoom, cmy*zoom - 0.7*cmr*zoom, 1.4*cmr*zoom, 1.4*cmr*zoom) ? KC1circle.potwheel();
       g_collision(cmx*zoom - cmr*0.9*zoom, cmy*zoom + (cmr+100)*zoom, 45*zoom, 25*zoom) ? KC1target.potwheel();
       g_collision(cmx*zoom + cmr*0.9*zoom - 45*zoom, cmy*zoom + (cmr+100)*zoom, 45*zoom, 25*zoom) ? KC1over.potwheel();
           cmx = 300;
       g_collision(cmx * zoom - 0.7*cmr * zoom, cmy*zoom - 0.7*cmr*zoom, 1.4*cmr*zoom, 1.4*cmr*zoom) ? KC2circle.potwheel();
       g_collision(cmx*zoom - cmr*0.9*zoom, cmy*zoom + (cmr+100)*zoom, 45*zoom, 25*zoom) ? KC2target.potwheel();
       g_collision(cmx*zoom + cmr*0.9*zoom - 45*zoom, cmy*zoom + (cmr+100)*zoom, 45*zoom, 25*zoom) ? KC2over.potwheel();
           cmx = 500;
       g_collision(cmx * zoom - 0.7*cmr * zoom, cmy*zoom - 0.7*cmr*zoom, 1.4*cmr*zoom, 1.4*cmr*zoom) ? KC3circle.potwheel();
       g_collision(cmx*zoom - cmr*0.9*zoom, cmy*zoom + (cmr+100)*zoom, 45*zoom, 25*zoom) ? KC3target.potwheel();
       g_collision(cmx*zoom + cmr*0.9*zoom - 45*zoom, cmy*zoom + (cmr+100)*zoom, 45*zoom, 25*zoom) ? KC3over.potwheel();
       
       cmx = 700;
       g_collision(cmx*zoom - cmr*0.9*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom) ? Kgonio_speed.potwheel();
       g_collision(cmx*zoom + cmr*0.9*zoom  -45*zoom, cmy*zoom + (cmr+45)*zoom, 45*zoom, 25*zoom) ? Kgonio_boost.potwheel();
       g_collision(582*zoom, 86*zoom, 45*zoom, 25*zoom) ? KVU_calib.potwheel();
       g_collision(15*zoom, 86*zoom, 45*zoom, 25*zoom) ? KCircle_time.potwheel();
            mouse_wheel=0;
            caller = 1;
           );
        
        gfx_a=1;
       KC1circle.dragging ? (KC1circle.potdrag(); KC1circle.readout();caller = 1;);
       KC1target.dragging ? (KC1target.potdrag(); caller = 1;);
       KC1over.dragging ?   (KC1over.potdrag();   caller = 1;);
       KC2circle.dragging ? (KC2circle.potdrag(); KC2circle.readout();caller = 1;);
       KC2target.dragging ? (KC2target.potdrag(); caller = 1;);
       KC2over.dragging ?   (KC2over.potdrag();   caller = 1;);
       KC3circle.dragging ? (KC3circle.potdrag(); KC3circle.readout();caller = 1;);
       KC3target.dragging ? (KC3target.potdrag(); caller = 1;);
       KC3over.dragging ?   (KC3over.potdrag();   caller = 1;);
       KGonio_Speed.dragging ? (KGonio_Speed.potdrag(); caller = 1;);
       KGonio_Boost.dragging ?   (KGonio_Boost.potdrag();   caller = 1;);
       KVU_calib.dragging ? (KVU_calib.potdrag(); caller = 1;);
       KCircle_time.dragging ?   (KCircle_time.potdrag();   caller = 1;);
       
      Link_Group == 0 ? (
      gmem[16*64 + 3] == 0 ? linkstart = 0;
      !mouse_cap ? (
      gmem[16*64 + 3] == 1 ? (linkstart == 0 ? link_old = slider(gmem[16*64 + 1]); linkstart = 1);
      gmem[16*64 + 3] == 1 ? (
           tmp_val = link_old +  gmem[16*64 + 2];
      slider(gmem[16*64 + 1]) = tmp_val;
      slider_automate(slider(gmem[16*64 + 1]));
      caller = 1;
      );
      gmem[16*64 + 3] == 2 ? (
      slider(gmem[16*64 + 1]) =  gmem[16*64 + 2];
      caller = 1;
      );
      );
      );
      
      
      
      ); // !number_input
 
      
      
     
      
      
      gfx_a=1;
      number_input ? number_input_show();
      //OEQ_NI == 1 ? number_input
      number_input_invalid = max(0,number_input_invalid-1);
      number_input_invalid ? ( 
      gfx_r=gfx_g=gfx_b=0;
      gfx_rect(zoom*number_input_x,number_input_y*zoom, 200*zoom, gfx_texth+5);
      gfx_r=0;gfx_g=1;gfx_b=0;
      gfx_rect(zoom*number_input_x,zoom*number_input_y, gfx_texth+5, gfx_texth+5);
      red();
      gfx_rect(zoom*number_input_x + gfx_texth+5,zoom*number_input_y, 200*zoom - (gfx_texth+5), gfx_texth+5);
      gfx_r=gfx_g=gfx_b=0.7;
      gfx_roundrect(zoom*number_input_x,zoom*number_input_y, 200*zoom, gfx_texth+5,0);
      gfx_x = zoom*number_input_x + gfx_texth+7; gfx_y = zoom*number_input_y + 2;
      white();
      gfx_drawstr("NO VALID INPUT!");
      );
    
 ////////////////////////////////////////////////////////////////////////////////////////////// ENDE MAUS STEUERUNG
 
 
 
 
 
  ////////////////////////////////////////// MENU MENU MENU ////////////////////////////////////////////////
  last_clicked_item = -1;
  Helpshow ? mouse_cap ? (helpshow = 0;last_clicked_item = -1);
  menu_x = 5; menu_y =5;
 
 gfx_x = menu_x * zoom; gfx_y = menu * zoom; gfx_a=1;
 //gfx_blit(menu,zoom/2,0);
 lightgrey(); //red();
 gfx_roundrect(menu_x * zoom, (menu_y + 5) * zoom, 20*zoom, 20*zoom, 0, 1);
 gfx_line((menu_x+3)*zoom, (menu_y + 11)*zoom, (menu_x+17)*zoom, (menu_y + 11)*zoom);
 gfx_line((menu_x+3)*zoom, (menu_y + 15)*zoom, (menu_x+17)*zoom, (menu_y + 15)*zoom);
 gfx_line((menu_x+3)*zoom, (menu_y + 19)*zoom, (menu_x+17)*zoom, (menu_y + 19)*zoom);
 
 gfx_setfont(1,"Arial",12*zoom,'b');
 lightgrey(); gfx_x = menu_x * zoom + 30*zoom;gfx_y += 15*zoom;
 gfx_drawstr("TUKAN STUDIOS  -  GREEN CIRCLES METER "); 
 gfx_setfont(1,"Arial",12*zoom,'i');
 lakeblue(); gfx_drawstr(" SERIES 2   ");
 gfx_setfont(1,"Arial",12*zoom,'b');
 
 
 
 link_group ? (
   rgb_palette(Link_group);// gfx_a = 0.7;
   gfx_drawstr("JOINS GROUP "); gfx_drawstr(sprintf(#,"%i", link_group));
 );
 gfx_a = 1;
 
 
  mouseClick ? (
   g_collision(menu_x*zoom, (menu_y+5) * zoom, 20*zoom, 20*zoom) ? (
    gfx_x = menu_x*zoom;
    gfx_y = (menu_y+20)*zoom;
     
      #item2 =">Processing|";#allitems = #item2;
     while_playing == 1 ? (#item2 = "!On Playback|"):(#item2 = "On Playback|");#allitems += #item2;
     while_recording == 1 ? (#item2 = "!On Recording|"):(#item2 = "On Recording|");#allitems += #item2;
     while_stopped == 1 ? (#item2 = "<!On Stop|>Groups|"):(#item2 = "<On Stop|>Groups|");#allitems += #item2;
 
     mnu_grp_loop = 1;
     loop(16,
 
       mnu_grp_loop == 16 ? #item2 += "<";
       gmem[16*64 + 10 + mnu_grp_loop] == 1 ? ( //Gruppe schon an ?
         mnu_grp_loop == Link_Group ? ( //ist selbst in der gruppe
                 #item2 = "!Joins Group ";
         ):(
             #item2 = "Add to Group ";
         );
       ):(
         #item2 = "Start Group ";
       );
     mnu_grp_loop == 1 ? #item2 += "01";
     mnu_grp_loop == 2 ? #item2 += "02";
     mnu_grp_loop == 3 ? #item2 += "03";
     mnu_grp_loop == 4 ? #item2 += "04";
     mnu_grp_loop == 5 ? #item2 += "05";
     mnu_grp_loop == 6 ? #item2 += "06";
     mnu_grp_loop == 7 ? #item2 += "07";
     mnu_grp_loop == 8 ? #item2 += "08";
     mnu_grp_loop == 9 ? #item2 += "09";
     mnu_grp_loop == 10 ? #item2 += "10";
     mnu_grp_loop == 11 ? #item2 += "11";
     mnu_grp_loop == 12 ? #item2 += "12";
     mnu_grp_loop == 13 ? #item2 += "13";
     mnu_grp_loop == 14 ? #item2 += "14";
     mnu_grp_loop == 15 ? #item2 += "15";
     mnu_grp_loop == 16 ? #item2 += "16";
     
     #item2 += "|";
     #allitems += #item2; //sprintf(#temp, '%f',3); 
     mnu_grp_loop += 1;
     );
     
     link_group ? (#allitems += "|<Delete Group ";#allitems += sprintf(#, "%d", link_group);#allitems += "|"):#allitems += "|<#Delete Group|";
 
     //#allitems += "<#MENU|";
    #allitems += ">Scaling|";
    zoom_off == 0 ? (#item2 = "!Automatic Scaling|"):(#item2 = "Automatic scaling|");#allitems += #item2;
    zoom_off == 1 ? (#item2 = "<!No scaling|"):(#item2 = "<No scaling|");#allitems += #item2;
  
  #allitems += ">MCP / TCP|";
 eflag == 1 ? #allitems += "!CIRCLE 1|" : #allitems += "CIRCLE 1|";
 eflag == 2 ? #allitems += "!CIRCLE 2|" : #allitems +="CIRCLE 2|";
 eflag == 3 ? #allitems += "!CIRCLE 3|" : #allitems +="CIRCLE 3|";
 eflag == 4 ? #allitems += "!GONIOMETER|" : #allitems +="GONIOMETER|";
 eflag == 5 ? #allitems += "!VU L/R Max|" : #allitems +="VU L/R Max|";
 eflag == 6 ? #allitems += "!VU L/R|" : #allitems +="VU L/R|";
 eflag == 7 ? #allitems += "!VU LEFT|" : #allitems +="VU LEFT|";
 eflag == 8 ? #allitems += "<!VU RIGHT|" :#allitems += "<VU RIGHT|";
    
    vu_meter_only ==1 ? #allitems += "!VU METER ONLY|" : #allitems +="VU METER ONLY|";
    cfg_peak == 1 ? #allitems += "!USE TRUE PEAK||" : #allitems +="USE TRUE PEAK||";
    #allitems += "|Show Info/Help";
    last_clicked_item = gfx_showmenu(#allitems);
  );
  );
 
 
 
 
  
  last_clicked_item == 1 ? (while_playing == 0 ? (while_playing = 1):(while_playing = 0);caller=1;processing_update());
  last_clicked_item == 2 ? (while_recording == 0 ? (while_recording = 1):(while_recording = 0);caller=1;processing_update());
  last_clicked_item == 3 ? (while_stopped == 0 ? (while_stopped = 1):(while_stopped = 0);caller=1;processing_update());
 
   cgroup = last_clicked_item - 3;
  last_clicked_item > 3 && last_clicked_item < 20 ? (
     Link_Group != cgroup ? ( //eigene Linkgruppe NICHT angeklickt
         gmem[16*64 + 10 + cgroup] == 0 ? ( // Gruppe noch frei
             //gmem[16*64 + 10 + cgroup] = 1; Link_Group = cgroup; gmem[16*64 +27 + cgruop] = 1; //Gruppe Starten!
             gmem[16*64 + 10 + cgroup] = 1;Link_Group = cgroup;group_update();
         ):(
             Link_Group = cgroup;// Gruppe teilnehmen
         );
     ):( //Eigene Gruppe angeklickt
           Link_Group = 0;
     );
  
  );
  
   cgroup = last_clicked_item - 3 - 16;
  last_clicked_item == 20 ? (
    gmem[16*64 + 10 + Link_Group] = 0;Link_Group = 0;
  );
  
  
  
  
  last_clicked_item == 21 ? zoom_off = 0;
  last_clicked_item == 22 ? zoom_off = 1;
 
  last_clicked_item > 22 && last_clicked_item < 31 ? (
  eflag_select = last_clicked_item - 22;
  eflag_select != eflag ? eflag_select != 0 ? (eflag = eflag_select; caller = 1);
  eflag = max(eflag, 1);;
  eflag_select = 0;
  caller = 1;
  );
  
  last_clicked_item == 31 ? (vu_meter_only == 1 ? vu_meter_only = 0 : vu_meter_only = 1; caller = 1);
  last_clicked_item == 32 ? (cfg_peak == 1 ? cfg_peak = 3 : cfg_peak = 1; caller = 1);
  last_clicked_item == 33 ? helpshow = 1;
  
  helpshow == 1 ? (
  gfx_r=0;gfx_g=0;gfx_b=0;gfx_a=0.7;
  gfx_rect(menu_x,menu_y+0,310*zoom,110*zoom);
  menu_x +=3;
  gfx_r=0.9;gfx_g=0.9;gfx_b=0.9;gfx_a=1;
  gfx_x = menu_x+3*zoom; gfx_y = menu_y+3*zoom;
  gfx_drawstr("TUKAN STUDIOS GREEN CIRCLES METER (Series 2)");
  gfx_x = menu_x+3*zoom; gfx_y += 13*zoom;
  gfx_drawstr("Version: "); gfx_drawnumber(Circles_VERSION,2);
  gfx_x = menu_x+3*zoom; gfx_y += 20*zoom;
  gfx_drawstr("Mouse modifier options:");
  gfx_x = menu_x+3*zoom; gfx_y += 15*zoom;
  gfx_drawstr("Fine tune knobs: [shift]");
  gfx_x = menu_x+3*zoom; gfx_y += 13*zoom;
  gfx_drawstr("Reset knobs: [ctrl] ([cmd] on mac)");
  gfx_x = menu_x+3*zoom; gfx_y += 13*zoom;
  gfx_drawstr("Link knobs on visible instances: [win] ([ctrl] on mac)");
  gfx_x = menu_x+3*zoom; gfx_y += 13*zoom;
  gfx_drawstr("Activate number typing: [alt]+[shift]");
  );
  
  
  ////////////////////////////////////////// ENDE MENU MENU MENU ////////////////////////////////////////////////
 
 
 
 ):gfx_ext_flags == 1 ? (
 gfx_a = 1;
 black();
 gfx_rect(0,0,gfx_w,gfx_h);
 eflag_select != eflag ? eflag_select != 0 ? (eflag = eflag_select; caller = 1);
 eflag = max(eflag, 1);;
 eflag_select = 0;
 
 
 cmx = gfx_w/2; cmy = gfx_h/2; //mittelpunkt in px
 cmr = gfx_h/2; //radius
 
 eflag == 1 ? (
 target = target1;
 over = over1;
 Low_value = abs(minimum1); // kreis mittelpunkt 
 cinput = circle1; // wird die Input auswahl---
 ):eflag == 2 ? (
 target = target2;
 over = over2;
 Low_value = abs(minimum2); // kreis mittelpunkt 
 cinput = circle2; // wird die Input auswahl---
 ):eflag == 3 ? (
 target = target3;
 over = over3;
 Low_value = abs(minimum3); // kreis mittelpunkt 
 cinput = circle3; // wird die Input auswahl---
 );
 
 
 
 
 eflag < 4 ? (
 zoom = 1;
 circle();
 
 zoom = gfx_h / 88;
 cinput == 0 ? take_value = LUFS_m_meter.dB_Val_Max;
 cinput == 1 ? take_value = LUFS_s_meter.dB_Val_Max;
 cinput == 2 ? take_value = LUFS_i_meter.dB_Val_Max;
 cinput == 3 ? take_value = RMS_Meter.dB_Val_Max;
 cinput == 4 ? take_value = landr_Meter.dB_Val_Max;
  cinput == 5 ? take_value = left_Meter.dB_Val_Max;
   cinput == 6 ? take_value = right_Meter.dB_Val_Max;
   
 take_value >= over ? (
 gfx_b = gfx_g = 0.1; gfx_r = 1; gfx_a = 1;
 ): take_value >= target ? (
 gfx_g = 1; gfx_r=gfx_b=0; gfx_a = 1;
 ):( gfx_r=gfx_b=0; gfx_g=0.5; gfx_a=1);
 
 //gfx_x = cmx*zoom + cmr*0.9*zoom - 45*zoom; gfx_y = cmy*zoom + (cmr+47)*zoom;
 
 gfx_setfont(1,"Arial",16*zoom,'b');
 take_value >= -96 ? (
 #myreadout = sprintf(#, "%.1f", take_value,1);
 ):(#myreadout = "- - -");
 gfx_measurestr(#myreadout, mrw, mrh);
 gfx_x = gfx_w - mrw - 2; gfx_y = gfx_h - mrh - 2;
 gfx_drawstr(#myreadout);
 
 cinput == 0 ? take_value = LUFS_m_meter.dB_Val;
 cinput == 1 ? take_value = LUFS_s_meter.dB_Val;
 cinput == 2 ? take_value = LUFS_i_meter.dB_Val;
 cinput == 3 ? take_value = RMS_Meter.dB_Val;
 cinput == 4 ? take_value = landr_Meter.dB_Val;
  cinput == 5 ? take_value = left_Meter.dB_Val;
   cinput == 6 ? take_value = right_Meter.dB_Val;
   
 take_value >= over ? (
 gfx_b = gfx_g = 0.1; gfx_r = 1; gfx_a = 1;
 ): take_value >= target ? (
 gfx_g = 1; gfx_r=gfx_b=0; gfx_a = 1;
 ):( gfx_r=gfx_b=0; gfx_g=0.5; gfx_a=1);
 
 //gfx_x = cmx*zoom + cmr*0.9*zoom - 45*zoom; gfx_y = cmy*zoom + (cmr+47)*zoom;
 
 gfx_setfont(1,"Arial",16*zoom,'b');
 take_value >= -96 ? (
 #myreadout = sprintf(#, "%.1f", take_value,1);
 ):(#myreadout = "- - -");
 gfx_measurestr(#myreadout, mrw, mrh);
 gfx_x = 2; gfx_y = gfx_h - mrh - 2;
 gfx_drawstr(#myreadout);
 
 );
 
 
 
 
gfx_a = 1; lightgrey(); gfx_circle(cmx, cmy, cmr);
 eflag == 4 ? (
 // Calculate the side length of a square centered in the window
 viewSize = cmr;//min(gfx_w, gfx_h) / 2;
  // The distance a dot may be from center in any
 // direction to still appear inside a circle.
 viewScale = (viewSize * 0.70710681);
  // The absolute center point in the current window
 centerX = cmx;//gfx_w * 0.5;
 centerY = cmy;//gfx_h * 0.5;
 
 goniometer_on ? drawHistory();
 drawIndicators();
 );
 
 eflag == 5 ? (
 zoom = gfx_h / 88;
 black();
 landr.mnmetergfx(zoom, -22*zoom, 0, 2);
 );
 
 eflag == 6 ? (
 zoom = gfx_h / 88;
 red();
 right_meter.mnmetergfx(zoom, -22*zoom, 0, 2);
 black();
 left_meter.mnmetergfx(zoom, -22*zoom, 0, 80);
 );
 
 eflag == 7 ? (
 zoom = gfx_h / 88;
 black();
 left_meter.mnmetergfx(zoom, -22*zoom, 0, 2);
 );
 
 eflag == 8 ? (
 zoom = gfx_h / 88;
 black();
 right_meter.mnmetergfx(zoom, -22*zoom, 0, 2);
 );
 
 
 mouseClick ? reset();
 
 mouse_cap == 2 ? (
 eflag == 1 ? #allitems = "!CIRCLE 1|" : #allitems = "CIRCLE 1|";
 eflag == 2 ? #allitems += "!CIRCLE 2|" : #allitems +="CIRCLE 2|";
 eflag == 3 ? #allitems += "!CIRCLE 3|" : #allitems +="CIRCLE 3|";
 eflag == 4 ? #allitems += "!GONIOMETER|" : #allitems +="GONIOMETER|";
 eflag == 5 ? #allitems += "!VU L/R Max|" : #allitems +="VU L/R Max|";
 eflag == 6 ? #allitems += "!VU L/R|" : #allitems +="VU L/R|";
 eflag == 7 ? #allitems += "!VU LEFT|" : #allitems +="VU LEFT|";
 eflag == 8 ? #allitems += "!VU RIGHT|" :#allitems += "VU RIGHT|";
 eflag_select = gfx_showmenu(#allitems);
 );
 
 #mini_group = sprintf(#, "%i", Link_Group);
 gfx_measurestr(#mini_group, mini_w, mini_h);
 gfx_x = gfx_w - mini_w - 2; gfx_y = 2;
 Link_Group ? (
   rgb_palette(Link_group);
   gfx_drawstr(#mini_group);
 );
 ); // ext flags
 
 
 
 
 S2_sample_on == 0 ? (
 
 In_Meter.dB_Val = -100;; //in_spl, Fallback in dB/s
 Out_Meter.dB_Val = -100;
 LUFS_m_meter.dB_Val = -100;
 LUFS_s_meter.dB_Val = -100;
 LUFS_i_meter.dB_Val = -100;
 //lufs_s_meter.db_val_max = -180;
 //lufs_m_meter.db_val_max = -180;
 //lufs_i_meter.db_val_max = -180;
 lufs_s_meter.db_val = -180;
 lufs_m_meter.db_val = -180;
 lufs_i_meter.db_val = -180;
 rms_meter.dB_Val = -100;
 rms_meter.db_val = -180;
 //rms_meter.db_val_max = -180;
 landr_meter.dB_Val = -100;
 landr_meter.db_val = -180;
 //landr_meter.db_val_max = -180;
 left_meter.dB_Val = -100;
 left_meter.db_val = -180;
 //left_meter.db_val_max = -180;
 right_meter.dB_Val = -100;
 right_meter.db_val = -180;
 //right_meter.db_val_max = -180;
 
 gmem[16*64 + 10 + link_group] != 1 ? link_group = 0;
 group_check_gfx();
 caller == 1 ? (
   parameters_update_on == 0 ? (
     parameters_update();
   );
 );
 );
 S2_sample_on = 0;
 
 
 
 
