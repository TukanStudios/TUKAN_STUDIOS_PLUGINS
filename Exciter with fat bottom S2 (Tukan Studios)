desc:Exciter with fat bottom S2 (Tukan)


in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right outpu


slider1:1<0,2,.01>-Output
slider2:26.25<0,60,.0001>-Frequency 1 //Sub Freq
slider3:1<0,2.82,0.01>-Sub Level
slider4:0<0,1,1{Sub ON, Sub BYPASS}>-Sub Bypass
slider5:82<63,100,.0001>-Frequency 2 //Exciter Freq 4
slider6:1<0,2.82,0.01>-Exc Level
slider7:0<0,1,1{Exc ON, Exc BYPASS}>-Exc Bypass
slider8:FIR=1 <0,1,1{IIR, FIR}>-Sound engine
slider9:0<0,1,1{ON, BYPASS}>-Bypass



filename:0,S2GFX/HD_Back.png
filename:1,S2GFX/BlueKnob.png
filename:2,S2GFX/RedKnob.png
filename:3,S2GFX/SmallKnob.png
filename:4,S2GFX/button.png
filename:5,S2GFX/switch.png
filename:6,S2GFX/gled.png
filename:7,S2GFX/rled.png
filename:8,S2GFX/yled.png
filename:9,S2GFX/oled.png
filename:10,S2GFX/bled.png
filename:11,S2GFX/menu.png
filename:12,S2GFX/S2_logo.png

/62 12/24 db/Oct
/63 Phase Linear
import S2GFX/tk_lib.jsfx-inc

options:no_meter
options:gfx_hz=60
options:gmem=TukanExciterS2
//options:gfx_idle


@init
Exciter_Version = 1.16;
//0.99 removed options:gfx_idle
at_start = -1;

// OCTAVER
bufsize=-1;
//

ext_tail_size = -1;
ext_nodenorm = 1;
gfx_ext_retina = 1;
gfx_clear=0;
ext_noinit=1;
lastCap=1;
mouse_wheel=1;
is_recording = 0; is_playing = 0; is_stopped = 1;
while_playing = 1; while_recording = 1; while_stopped = 1;
Number_input = 0;
number_input_raw = 0;
number_input_use = 0;
komma = 0;
in_key = 0;
number_input_x = 0;
number_input_y=0;
number_input_slider = 0;
number_input_min=0;
number_input_max=0;
number_input_invalid = 0;
number_input_sign=1;


s2_numbers_of_sliders = 9;
s2_numbers_of_generics = 0;
group_generics =0; // fuer group_generics[bis zu 200]
sliders_old = group_generics + 16*200;
generics_old = sliders_old + 16*64;



 blueknob = 1;
 redknob = 2;
 smallknob = 3;
 button = 4;
 switch = 5;
 gled = 6; rled = 7; yled = 8; oled = 9; bled = 10;
 menu = 11;  
 logo = 12;
 Mouse_Sensivity ();



     //Parameter_config           (slider_  default_ minVal_ maxVal_ xIn_ yIn_ wIn   frames_ scaling_ file_)      
     Knobs_x = 40;
     knobs_y = 65;
     K_Sub_freq.parameter_config   (2,       26.25,      0,    60,  knobs_x,   knobs_y,  150,  200,    1,       redknob);
     K_Sub_Mix.parameter_config    (3,       1,          0,  2.82,  knobs_x + 130, knobs_y,  150,  200,    1,    blueknob);     

     K_Exc_freq.parameter_config   (5,       82,      63,    100,  knobs_x +350,   knobs_y,  150,  200,    1,       redknob);
     K_Exc_Mix.parameter_config    (6,       1,          0,  2.82,  knobs_x +480, knobs_y,  150,  200,    1,    blueknob); 
     
     K_Out.parameter_config        (1,       1,          0,  2,  knobs_x + 707, knobs_y,  150,  200,    1,    blueknob);
     
     B_sub_Bypass.button_config(4, knobs_x + 250 ,75);
     
     B_exc_Bypass.button_config(7, knobs_x + 600 ,75);
     
     B_Bypass.button_config(9, knobs_x + 765, 3);






       
  MAX_FREQ = 44100 / 2.0;
  MIN_FREQ = 20;
  FREQ_LOG_MAX = log(MAX_FREQ / MIN_FREQ);
function per_to_freq(x, range) (
  MIN_FREQ * exp(FREQ_LOG_MAX * x / range);
);
function freq_to_per(freq, range) (
  range * log(freq / MIN_FREQ) / FREQ_LOG_MAX;
);



   function number_input_show_freq () (
     gfx_r=gfx_g=gfx_b=0;
     gfx_rect(zoom*number_input_x,number_input_y*zoom, 200*zoom, gfx_texth+5);
     gfx_r=0;gfx_g=1;gfx_b=0;
     gfx_rect(zoom*number_input_x,zoom*number_input_y, gfx_texth+5, gfx_texth+5);
     gfx_r=gfx_g=gfx_b=0.7;
     gfx_roundrect(zoom*number_input_x,zoom*number_input_y, 200*zoom, gfx_texth+5,0);
     gfx_x = zoom*number_input_x + gfx_texth+7; gfx_y = zoom*number_input_y + 2;
     gfx_drawnumber(number_input_use,komma);
  
  
         mouseclick && !shift_alt ? 
       (
         g_collision(zoom*number_input_x,zoom*number_input_y, gfx_texth+5, gfx_texth+5) ?
         (
           number_input_use = freq_to_per(number_input_use, 100);

           valid = 0;
           number_input_use >= number_input_min && number_input_use <= number_input_max ? valid = 1;
           valid ? (
           slider(number_input_slider) = number_input_use;
           caller = 1;
           ):(
           number_input_invalid = 90;
           );
           Number_input = 0;
           number_input_raw = 0;
           number_input_use = 0;
           komma = 0;
           in_key = 0;
           //number_input_x = 0;
           //number_input_y=0;
         ):(
           Number_input = 0;
           number_input_raw = 0;
           number_input_use = 0;
           komma = 0;
           in_key = 0;
           number_input_x = 0;
           number_input_y=0;
         );
       );
  
       in_key=gfx_getchar();
  
       in_key ? Aaa = in_key;
         in_key == 8 ? (
         number_input_raw = floor(number_input_raw/10);
         komma = max(0,komma-1);
         komma == 1 ? komma = 0;
         );
  
       in_key == 45 ? number_input_sign*=-1;
  
       in_key == 46 ? komma = 1;
       in_key > 47 ? (
       in_key < 58 ? (
           number_input_raw = (number_input_raw*10) + (in_key-48);
           komma ? komma += 1;
       );
       );
  
       komma ? (number_input_use = number_input_raw / (10^(komma-1))):(number_input_use = number_input_raw);
       number_input_use *= number_input_sign;
  
     );
  
  
  
  function number_input_show_db () (
    gfx_r=gfx_g=gfx_b=0;
    gfx_rect(zoom*number_input_x,number_input_y*zoom, 200*zoom, gfx_texth+5);
    gfx_r=0;gfx_g=1;gfx_b=0;
    gfx_rect(zoom*number_input_x,zoom*number_input_y, gfx_texth+5, gfx_texth+5);
    gfx_r=gfx_g=gfx_b=0.7;
    gfx_roundrect(zoom*number_input_x,zoom*number_input_y, 200*zoom, gfx_texth+5,0);
    gfx_x = zoom*number_input_x + gfx_texth+7; gfx_y = zoom*number_input_y + 2;
    gfx_drawnumber(number_input_use,komma);
  
  
        mouseclick && !shift_alt ? 
      (
        g_collision(zoom*number_input_x,zoom*number_input_y, gfx_texth+5, gfx_texth+5) ?
        (
          number_input_use = db2ratio(number_input_use);
  
          valid = 0;
          number_input_use >= number_input_min && number_input_use <= number_input_max ? valid = 1;
          valid ? (
          slider(number_input_slider) = number_input_use;
          caller = 1;
          ):(
          number_input_invalid = 90;
          );
          Number_input = 0;
          number_input_raw = 0;
          number_input_use = 0;
          komma = 0;
          in_key = 0;
          //number_input_x = 0;
          //number_input_y=0;
        ):(
          Number_input = 0;
          number_input_raw = 0;
          number_input_use = 0;
          komma = 0;
          in_key = 0;
          number_input_x = 0;
          number_input_y=0;
        );
      );
  
      in_key=gfx_getchar();
  
      in_key ? Aaa = in_key;
        in_key == 8 ? (
        number_input_raw = floor(number_input_raw/10);
        komma = max(0,komma-1);
        komma == 1 ? komma = 0;
        );
  
      in_key == 45 ? number_input_sign*=-1;
  
      in_key == 46 ? komma = 1;
      in_key > 47 ? (
      in_key < 58 ? (
          number_input_raw = (number_input_raw*10) + (in_key-48);
          komma ? komma += 1;
      );
      );
  
      komma ? (number_input_use = number_input_raw / (10^(komma-1))):(number_input_use = number_input_raw);
      number_input_use *= number_input_sign;
  
    );
  
  
  function readout_f () (
  thisfreq = per_to_freq(slider(this.slider),100);
  thisfreq < 1000 ? (
  sprintf(#readout, "%.0f", thisfreq); #readout += "Hz";
  ):(
  sprintf(#readout, "%.2f", thisfreq/1000); #readout += "kHz";  
  );
  gfx_x = this.xIn*zoom; gfx_y = this.yIn*zoom - gfx_texth - 2*zoom;
  gfx_measurestr(#readout, rdow, rdoh);
  gfx_r=gfx_b=gfx_g=0; gfx_rect(gfx_x+2*zoom, gfx_y, rdow+3*zoom, gfx_texth+2*zoom);
  gfx_r=gfx_g=gfx_b=0.8;
  gfx_x += 3*zoom;
  gfx_drawstr(#readout);
  );
  

  function readout_db () (
  thisdb = ratio2db(slider(this.slider));
  sprintf(#readout, "%.1f", thisdb);
    slider(this.slider) == 0 ? #readout = "OFF";
  gfx_x = this.xIn*zoom; gfx_y = this.yIn*zoom - gfx_texth - 2*zoom;
  gfx_measurestr(#readout, rdow, rdoh);
  gfx_r=gfx_b=gfx_g=0; gfx_rect(gfx_x+2*zoom, gfx_y, rdow+3*zoom, gfx_texth+2*zoom);
  gfx_r=gfx_g=gfx_b=0.8;
  gfx_x += 3*zoom;
  gfx_drawstr(#readout);
  );

function parameters_update () (

parameters_update_on = 1;


K_Sub_freq.parameter_boundaries();
K_Sub_Mix.parameter_boundaries();
K_Exc_freq.parameter_boundaries();
K_Exc_Mix.parameter_boundaries();
K_Out.parameter_boundaries();

group_parameters();


K_Sub_freq.parameter_boundaries();
K_Sub_Mix.parameter_boundaries();
K_Exc_freq.parameter_boundaries();
K_Exc_Mix.parameter_boundaries();
K_Out.parameter_boundaries();

/*

3 -> 5
*/
//OCTAVER

vslider7=44;//<4,500,10>Chunk (ms)
vslider8=1;//<0,1>Overlap

nbufsize=srate*0.001*vslider7; nbufsize=nbufsize&65534; 
nbufsize != bufsize ? (bufsize=nbufsize; bufpos=0);
vslider8=min(1,max(0,vslider8)); rspos=bufsize*vslider8; invbs=1/rspos;
sublevel = slider3;
basslevel = max(1,sublevel*5);
Sub_bypass = slider4;
//

/// EXCITER
hdistr = min(50/100,.9); // 0 - 0.9 ...offensichtlich
foo = 2*hdistr/(1-hdistr);
Exclevel = slider6;
treblelevel = max(1,exclevel*2.4);
Exc_Bypass = slider7;
///
band_mode=0;
cuts = 2;

slider2 = max(0,min(slider2, 60));
slider5 = max(63,min(slider5, 100));




Freq1 = slider2 / 100;
Freq2 = slider5 / 100;
Freq3 = 100;//slider4 / 100;
Freq4 = 100;//slider5 / 100;

last_sent_f1 = last_sent_f2 = last_sent_f3 = last_sent_f4 = 0;

//vslider2 = slider2; vslider3 = slider3; vslider4 = slider4; vslider5 = slider5;

output_level = slider1;
bypass = slider9;

Drive1 = Drive2 = Drive3 = Drive4 = Drive5 = 0;
abs_placement = 1;
FIR_quality = 1;
masterGainSlider = 0;

caller = 0;
parameters_update_on = 0;
);





  function f_trafo(freq)
  local()
  global(srate, freq_max, norm_freq_min)
  instance()
  (
    freq_max * exp( (1-freq) * log(norm_freq_min) )
  );

  function initBands()
  local()
  global()
  instance(lg1, lg2, lg3, lg4, lg5, b1, b2, b3, b4, b5)
  (
    lg1 = lg2 = lg3 = lg4 = lg5 = -1000000;
    b1.ldrive = b2.ldrive = b3.ldrive = b4.ldrive = b5.ldrive = -1000000;
    b1.initialized = b2.initialized = b3.initialized = b4.initialized = b5.initialized = 0;
  );

maxCuts = 4;
driveMax = 60;
driveMin = -40;
driveRange = driveMax - driveMin;

filterBank.initBands();

// Precompute some things
gainRange = ( gainMax - gainMin );
iGainRange = 1.0 / gainRange;
iDriveRange = 1.0 / driveRange;

///////////////////
/* SLIDER LAYOUT */
///////////////////
/* Keep these updated with the slider locations */

//frequencyLocation = 2;
//driveLocation     = 10;//6

/* Shift slider data right (for different bands) *
function shiftRight(loc, fromIdx, numElements)
  local(midx)
  global()
  (
    midx = loc + numElements;
    loop(numElements-fromIdx,
      slider(midx) = slider(midx-1);
      midx = midx - 1;
    );
  );

/* Shift slider data left  (for different bands) *
function shiftLeft(loc, fromIdx, numElements)
  local(midx)
  global()
  (
    midx = loc+fromIdx;
    loop(numElements-fromIdx,
      slider(midx) = slider(midx+1);
      midx = midx + 1;
    );
  );
  
/* Shift slider data right (for different bands) *
function shiftRightMem(loc, fromIdx, numElements)
  local(midx)
  global()
  (
    midx = loc + numElements;
    loop(numElements-fromIdx,
      midx[] = midx[-1];
      midx -= 1;
    );
  );

/* Shift slider data left  (for different bands) *
function shiftLeftMem(loc, fromIdx, numElements)
  local(midx)
  global()
  (
    midx = loc+fromIdx;
    loop(numElements-fromIdx,
      midx[] = midx[1];
      midx += 1;
    );
  );  

/* Make room for a new band in the slider data *
function addBand(idx)
  local(midx)
  instance()
  (
    shiftRight( driveLocation,     idx, maxCuts );
    shiftRight( frequencyLocation, idx, maxCuts-1 );
    
    cuts = cuts + 1;
  );
  
/* Remove a band and move other slider data accordingly *
function remBand(idx)
  local(midx)
  instance()
  (
    shiftLeft( driveLocation,     idx, maxCuts );
    shiftLeft( frequencyLocation, idx, maxCuts-1 );
    
    cuts = cuts - 1;
  );  

/* Feed sample to FFT */
function feedSample(sample)
  global(fftSize)
  instance(recPtr, window, rStart, rEnd, fftLoc)
  local()
  (
    recPtr[] = sample;
    recPtr = (recPtr+1) >= rEnd ? rStart : recPtr + 1;
  );

/* Initialize FFT windowing function */
function initWindow(windowtype)
  global(fftSize)
  instance(recPtr, window, rStart, rEnd, fftLoc)
  local(i, pwr, dwindowpos, windowpos)
  (
    windowpos = 0;
    dwindowpos = $pi*2/fftSize;
    i = 0; pwr = 0;
    loop(fftSize*.5+1,
       pwr += (window[i] = (
         windowtype==1 ? ( 0.53836 - cos(windowpos)*0.46164 ) :
         windowtype==2 ? ( 0.35875 - 0.48829 * cos(windowpos) + 0.14128 * cos(2*windowpos) - 0.01168 * cos(3*windowpos) ) :
         windowtype==3 ? ( 0.42 - 0.50 * cos(windowpos) + 0.08 * cos(2.0*windowpos) ) :
         windowtype==4 ? ( 1.0 ) :
         ( .21557895 - 0.41663158 * cos(windowpos) + 0.277263158 * cos(2*windowpos) - 0.083578947 * cos(3*windowpos) + 0.006947368 * cos(4*windowpos) )
         ) );
       i+=1;
       windowpos+=dwindowpos;
    );
    pwr=.5/(pwr*2-window[i-1]);
    loop(fftsize*.5+1,window[i-=1]*=pwr);
 );
  
function setToFFTLoc()
 global(fftSize)
 instance(recPtr, rStart)
 local()
 ( 
    recPtr = rStart + fftSize;
 ); 

/* Calculate current spectrum */
function calcFFT()
  global(fftSize)
  instance(recPtr, window, rStart, rEnd, fftLoc, slope, yshift)
  local(buf1, buf2, buf3, yOut, i, prec, ty)
  (
    buf1=recPtr-fftSize;
    buf1<rStart ? buf1+=(rEnd-rStart);
    buf2=window;
    buf3=fftLoc;
    loop(fftSize*.5 + 1,
      buf3[] = buf1[]*buf2[];
      buf3+=1;
    
      buf2+=1;
      (buf1+=1) >= rEnd ? buf1 -= (rEnd-rStart);
    );
    buf2-=1;
    loop(fftSize*.5 - 1,
      buf3[] = buf1[]*(buf2-=1)[];
      buf3+=1;
      (buf1+=1) >= rEnd ? buf1 -= (rEnd-rStart);
    );
    
    fft_real(fftLoc,fftSize);
    fft_permute(fftLoc,fftSize/2);
    
    buf3    = fftLoc;
    yOut    = fftLoc;  
    i       = 0;
    slope   = .5*log(2)*slope;
    yshift  = slope*log(1.0+.5*fftSize);
    prec    = (10^(-500/20*2));
    loop(fftSize*0.5,   
      ty      = sqr(buf3[0])+sqr(buf3[1]);
      ty      = log(max(ty,prec));
      
      ty      = ty + slope*log(1.0+i) - yshift;
      yOut[]  = ty;
      yOut    += 1;
      buf3    += 2;    
      
      i += 1;
    );
  );  

/* Set location of a window */
function setWindowLocation(_x, _y, _w, _h)
  global()
  instance(x, y, w, h, cap)
  local()
  ( 
    x = _x;
    y = _y;
    w = _w;
    h = _h;
  );


  

function isOver(mx, my)
  instance(x, y, w, h)
  global(overRange)
  local()
  (
    ( ( mx >= (x-overRange) ) && ( mx <= (x+w+overRange) ) && ( my >= (y-overRange) ) && ( my <= (y+h+overRange) ) ) ? 1 : 0;
  );

function clamp(value, mini, maxi)
  local()
  global()
  (
    max(min(value,maxi),mini)
  );

function overRect(x, y, w, h, mx, my)
  local()
  global()
  (
    ( (mx > x) && (mx < (x+w) ) && (my > y) && (my < (y+h) ) )
  );

function pixelToWindowRatio(x_loc)
  instance(x, y, w, h, hzoffset)
  global(fftSize, norm_freq_min)
  local(lmin, wsc, hfft)
  (
    hfft  = 0.5*fftSize;
    lmin  = log(norm_freq_min);
    wsc   = w/log(1+fftSize*0.5-hzoffset);
    
    1-log( (exp((x_loc)/wsc) + hzoffset)/hfft )/lmin
  );
  

  
function updateBands()
  global(Freq1,   Freq2,   Freq3,   Freq4,
         Ceil1,   Ceil2,   Ceil3,   Ceil4,
         Drive1,  Drive2,  Drive3,  Drive4,  Drive5,
         fftSize, driveRange, driveMax, abs_placement, cuts,
         norm_freq_min)
  instance(x, y, w, h, hzoffset,
           x1,  x2,  x3,  x4,  x5,  /* Frequencies          */
           y1,  y2,  y3,  y4,  y5,  /* Drives               */
           )
  local(F1, F2, F3, F4, F5, wsc, hfft, lmin, irange, dmax)
  (
    abs_placement ? (
      F1 = clamp(Freq1, 0, 1);
      F2 = clamp(Freq2, F1, cuts > 2 ? F3 : 1);
      F3 = clamp(Freq3, F2, cuts > 3 ? F4 : 1);
      F4 = clamp(Freq4, F3, 1.0);
    ) : (
      F1 = Freq1;
      F2 = Freq1  + Freq2 * (1 - Freq1);
      F3 = F2     + Freq3 * (1 - F2);
      F4 = F3     + Freq4 * (1 - F3);
    );
    
    hfft = 0.5*fftSize;
    lmin = log(norm_freq_min);
    
    wsc = w/log(1+fftSize*0.5-hzoffset);
    x1 = ( x + log( hfft * exp( (1-F1) * lmin ) - hzoffset ) * wsc );
    x2 = ( x + log( hfft * exp( (1-F2) * lmin ) - hzoffset ) * wsc );
    x3 = ( x + log( hfft * exp( (1-F3) * lmin ) - hzoffset ) * wsc );
    x4 = ( x + log( hfft * exp( (1-F4) * lmin ) - hzoffset ) * wsc );
    x5 = ( x + log( hfft * exp( lmin ) - hzoffset ) * wsc );
       
    iRange = 1/driveRange;
    dmax = iRange * driveMax;
    
    y1 = y+h*(dmax-iRange*Drive1);
    y2 = y+h*(dmax-iRange*Drive2);
    y3 = y+h*(dmax-iRange*Drive3);
    y4 = y+h*(dmax-iRange*Drive4);
    y5 = y+h*(dmax-iRange*Drive5);
  );

lineR = 1;
lineG = .9;
lineB = 1.0;
lineA = .95;
lineHighlightR = 0;
lineHighlightG = .7;
lineHighlightB = .5;
  
function initBuffer(scopebuffer_in, scopebuffermax_in)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopebuffer     = scopebuffer_in;
    scopebuffermax  = scopebuffermax_in;
    
    scopeptr < scopebuffer ? (
      scopeptr = scopebuffer 
    ) : ( scopeptr > scopebuffermax ) ? scopeptr = scopebuffer    
  );
  
function setOffset(offset)
  local()
  global()
  instance(scopeptr, readptr, scopebuffermax, scopebuffer, frac)
  (
    readptr   = scopeptr;
    frac      = offset - floor(offset);
    readptr  -= floor(offset);
    readptr < scopebuffer ? readptr += (scopebuffermax-scopebuffer+1);
  );
  
function readBuffer()
  local(c1, c2)
  global()
  instance(readptr, scopebuffermax, scopebuffer, frac)
  (
    c1 = readptr[];
    readptr += 1;
    readptr > scopebuffermax ? readptr = scopebuffer;
    
    c2 = readptr[];
    c2 * (1.0-frac) + c1 * frac
  );
  
function updateBuffer(M)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopeptr[] = M;
    scopeptr += 1;
    scopeptr > scopebuffermax ? scopeptr = scopebuffer;
    
    M
  );  
  
function clearBuffer()
  local()
  global(MAXBUFFERSIZE)
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    memset( scopebuffer, 0, MAXBUFFERSIZE );
    scopeptr = scopebuffer;
  );   
  


function initSpectrum(memoryOffset, fftSize, srate)
  global(newUI)
  instance(recPtr, window, rStart, rEnd, fftLoc, hzoffset, thisUI, slope)
  local()
  (
    slope     = 3;
  
    hzoffset  = 10*fftSize/srate;
    window    = memoryOffset + fftSize + (fftSize*0.5 - 1);
  
    // Start and end of the buffer
    rStart    = memoryOffset;                              // rpos
    rEnd      = window;                                      // hsize
    
    fftLoc    = window + (fftSize*0.5 + 1); // fftw
    
    recPtr    = rStart;
    thisUI    = newUI+=1;
    
    this.initWindow(3)
  );
  
  function resetBandMeter()
  local()
  global()
  instance(in, pre, post)
  (
    in = pre = post = 0;
  );
  
  function processBands()
  local(BW2)
  global( Drive1,    Drive2,    Drive3,     Drive4,     Drive5
          play1,     play2,     play3,      play4,      play5 )
  instance(b1, b2, b3, b4, b5, F1, F2, F3, F4, F5,
           g1,       g2,       g3,       g4,       g5,
           lg1,      lg2,      lg3,      lg4,      lg5 )
  (
    ( lg1 != Drive1 ) ? ( g1 = (10^(0.05*Drive1)); lg1 = Drive1; );
    ( lg2 != Drive2 ) ? ( g2 = (10^(0.05*Drive2)); lg2 = Drive2; );
    ( lg3 != Drive3 ) ? ( g3 = (10^(0.05*Drive3)); lg3 = Drive3; );
    ( lg4 != Drive4 ) ? ( g4 = (10^(0.05*Drive4)); lg4 = Drive4; );
    ( lg5 != Drive5 ) ? ( g5 = (10^(0.05*Drive5)); lg5 = Drive5; );

    b1.l = b2.l = b3.l = b4.l = b5.l = 0;
    b1.r = b2.r = b3.r = b4.r = b5.r = 0;
    play1 ? (
      b1.l = g1*b1.inL;
      b1.r = g1*b1.inR;
    );
    play2 ? (
      b2.l = g2*b2.inL;
      b2.r = g2*b2.inR;
    );
    play3 ? (
      b3.l = g3*b3.inL;
      b3.r = g3*b3.inR;
    );
    play4 ? (
      b4.l = g4*b4.inL;
      b4.r = g4*b4.inR;
    );
    play5 ? (
      b5.l = g5*b5.inL;
      b5.r = g5*b5.inR;
    );
  ); 
  
// MEMORY LAYOUT
fftSize     = 2*8192;
bufferDist  = 65536;
audioBufIn  = 0 + 2000000;
audioBufOut = bufferDist;

FIR1        = 2*bufferDist + 2000000;
FIR2        = 3*bufferDist + 2000000;
FIR3        = 4*bufferDist + 2000000;
FIR4        = 5*bufferDist + 2000000;
FIR5        = 6*bufferDist + 2000000;

F1Block1    = 7*bufferDist + 2000000;
F1Block2    = 8*bufferDist + 2000000;
F2Block1    = 9*bufferDist + 2000000;
F2Block2    = 10*bufferDist + 2000000;
F3Block1    = 11*bufferDist + 2000000;
F3Block2    = 12*bufferDist + 2000000;
F4Block1    = 13*bufferDist + 2000000;
F4Block2    = 14*bufferDist + 2000000;
F5Block1    = 15*bufferDist + 2000000;
F5Block2    = 16*bufferDist + 2000000;

specBufferLoc = 17*bufferDist + 2000000;

specBuffer.initBuffer(specBufferLoc, specBufferLoc+bufferDist-4);

// INITIALIZATION
spectrumIn.initSpectrum(audioBufIn, fftSize, srate);
spectrumOut.initSpectrum(audioBufOut, fftSize, srate);













@serialize
file_var(0, mute1);
file_var(0, mute2);
file_var(0, mute3);
file_var(0, mute4);
file_var(0, mute5);

file_var(0, solo1);
file_var(0, solo2);
file_var(0, solo3);
file_var(0, solo4);
file_var(0, solo5);

file_var(0, FIR);

file_var(0, gmem_group);



file_var(0, while_playing);
file_var(0, while_recording);
file_var(0, while_stopped);
file_var(0, link_group);
file_var(0, Exciter_VERSION);

seriloop = 0;
loop(64*16 + 27 + 16,
file_var(0, gmem[seriloop]);
seriloop += 1;
);

seriloop = 0;
loop(200*16,
file_var(0, group_generics[seriloop]);
seriloop += 1;
);













@slider
  parameters_update_on == 0 ? (
    parameters_update();
  ):(
    caller = 1;
  );

@block


csrate = ceil(srate / 44100);


(last_gmem_group != gmem_group) ||
(last_sent_cuts != Cuts) ||
(last_sent_f1 != Freq1) ||
(last_sent_f2 != Freq2) ||
(last_sent_f3 != Freq3) ||
(last_sent_f4 != Freq4) ||
(last_sent_slope != band_mode) ||
(last_sent_abs_placement != abs_placement) ? (
  last_gmem_group = gmem_group;
  last_sent_cuts = Cuts;
  last_sent_f1 = Freq1;
  last_sent_f2 = Freq2;
  last_sent_f3 = Freq3;
  last_sent_f4 = Freq4;
  last_sent_abs_placement = abs_placement;
  last_sent_slope = band_mode;

  (gmem_group > 0) ? (
    gm_ptr = 8 * (gmem_group - 1);
    gmem[gm_ptr] = time_precise();  // Identity
    gmem[gm_ptr + 1] = last_sent_cuts;
    gmem[gm_ptr + 2] = last_sent_f1;
    gmem[gm_ptr + 3] = last_sent_f2;
    gmem[gm_ptr + 4] = last_sent_f3;
    gmem[gm_ptr + 5] = last_sent_f4;
    gmem[gm_ptr + 6] = last_sent_abs_placement;
    gmem[gm_ptr + 7] = last_sent_slope;
  );
);


absolute_frequencies ? (
  //freq_max = 22050;
  //norm_freq_min = 10.0 / freq_max;
  //norm_freq_max = freq_max / srate;
  freq_max = 44100/2;//22050 * (srate/44100);
  norm_freq_min = 10.0 / (freq_max/2);
  norm_freq_max = freq_max / srate;
) : (
  freq_max = 0.5 * srate;
  norm_freq_min = 10.0 / 22050;
  norm_freq_max = 0.5;
);


!mute1 ? play1 = 1 : play1 = 0;
!mute2 ? play2 = 1 : play2 = 0;
!mute3 ? play3 = 1 : play3 = 0;
!mute4 ? play4 = 1 : play4 = 0;
!mute5 ? play5 = 1 : play5 = 0;

( solo1 || solo2 || solo3 || solo4 || solo5 ) ? ( play1 = play2 = play3 = play4 = play5 = 0; );
solo1 ? play1 = 1;
solo2 ? play2 = 1;
solo3 ? play3 = 1;
solo4 ? play4 = 1;
solo5 ? play5 = 1;


(FIR) ? (
  chunkSize = (fftCalcSize - firSize - 1);
  newPDC = chunkSize + 0.5*firSize;
) : (
  newPDC = 0;
);

bypass ? newPDC = 0;

(pdc_delay != newPDC) ? (
  pdc_top_ch = 10;
  pdc_bot_ch = 0;
  pdc_delay = newPDC;
);













@sample




 function init_LR2(freq)
    global(srate, norm_freq_max, norm_freq_min, band_mode)
    local(f0, ct, st, div)
    instance(k, a1, a2, a3)
    (
      f0 = norm_freq_max * $pi * exp( (1.0 - freq) * log(norm_freq_min) );
      k = band_mode == 0 ? sqrt(2) : 2; /* Note the different peak resonance because we're combining 2 SVFs into the Linkwitz-Riley structure */

      ct = cos(f0);
      st = sin(f0);
      div = 1.0 / (1.0 + k * st * ct);
      a1 = ct * ct * div;
      a2 = st * ct * div;
      a3 = st * st * div;
    );
  
  function reset_LR()
    global()
    local()
    instance(ic1eq, ic2eq, ic3eq, ic4eq, ic5eq, ic6eq, k, a1, a2, a3)
    (
      ic1eq = ic2eq = 0;  
    );  

  function eval_LRLP(v0)
    global()
    local(v1, v2, v3)
    instance(ic3eq, ic4eq, a1, a2, a3)
    (
      v3 = v0 - ic4eq;
      v1 = a1 * ic3eq + a2 * v3;
      v2 = ic4eq + a2 * ic3eq + a3 * v3;
      ic3eq = 2*v1 - ic3eq;
      ic4eq = 2*v2 - ic4eq;
      
      v2
    );  
 
  function eval_LRAP(v0)
    global()
    local(v1, v2, v3)
    instance(ic5eq, ic6eq, k, a1, a2, a3)
    (
      v3 = v0 - ic6eq;
      v1 = a1 * ic5eq + a2 * v3;
      v2 = ic6eq + a2 * ic5eq + a3 * v3;
      ic5eq = 2*v1 - ic5eq;
      ic6eq = 2*v2 - ic6eq;    
      
      v0 - 2*k*v1
    );
    
  function eval_LR2(v0)
    global()
    local(v1, v2, v3, all)
    instance(ic1eq, ic2eq, k, a1, a2, a3, hp, lp)
    (
      v3 = v0 - ic2eq;
      v1 = a1 * ic1eq + a2 * v3;
      v2 = ic2eq + a2 * ic1eq + a3 * v3;
      ic1eq = 2*v1 - ic1eq;
      ic2eq = 2*v2 - ic2eq;
      
      all = v0 - 2 * k * v1;
 
      lp = this.eval_LRLP(v2); 
      hp = all - lp;
    );
    
  function eval_LR1(v0)
    global()
    local(v1, v2, v3)
    instance(ic1eq, ic2eq, k, a1, a2, a3, hp, lp)
    (
      v3 = v0 - ic2eq;
      v1 = a1 * ic1eq + a2 * v3;
      v2 = ic2eq + a2 * ic1eq + a3 * v3;
      ic1eq = 2*v1 - ic1eq;
      ic2eq = 2*v2 - ic2eq;
 
      lp = v2;
      hp = v0 - k * v1 - lp;
    );
    
  function init_AP1(freq)
    global(srate, norm_freq_min, norm_freq_max)
    instance(k)
    local(f0, st)
    (
      f0 = norm_freq_max * $pi * exp((1 - freq) * log(norm_freq_min));
      st = sin(f0);
      k = st / (st + cos(f0));
    );
    
  function eval_AP1(v0)
    global()
    instance(k, state)
    local(v, y)
    (
      v = (v0 - state) * k;
      y = v + state;
      state = y + v;
      y - (v0 - y)
    );
  
  function resetBands()
  local()
  global()
  instance( b1, b2, b3, b4, b5 )
  (
    b1.r = b1.l = b2.r = b2.l = b3.r = b3.l = b4.r = b4.l = b5.l = 0;
  );
  
  function resetFilters()
  global()
  local()
  instance(
            LF1, LF2, LF3, LF4            /* Lowpass left */
            LA_F2,                        /* Allpass frequency 2 left */
            LA_F3, LA_F3_2,               /* Allpass frequency 3 left */
            LA_F4, LA_F4_2, LA_F4_3,      /* Allpass frequency 4 left */
            RF1, RF2, RF3, RF4            /* Lowpass right */
            RA_F2,                        /* Allpass frequency 2 right */
            RA_F3, RA_F3_2,               /* Allpass frequency 3 right */
            RA_F4, RA_F4_2, RA_F4_3,      /* Allpass frequency 4 right */  
  )
  (
    // LR2  => ic1eq, ic2eq, ic3eq, ic4eq
    // LPLP => ic3eq, ic4eq
    // LRAP => ic5eq, ic6eq
    
    LF1.ic1eq = LF1.ic2eq = LF1.ic3eq = LF1.ic4eq = 0;
    LF2.ic1eq = LF2.ic2eq = LF2.ic3eq = LF2.ic4eq = 0;
    LF3.ic1eq = LF3.ic2eq = LF3.ic3eq = LF3.ic4eq = 0;
    LF4.ic1eq = LF4.ic2eq = LF4.ic3eq = LF4.ic4eq = 0;

    RF1.ic1eq = RF1.ic2eq = RF1.ic3eq = RF1.ic4eq = 0;
    RF2.ic1eq = RF2.ic2eq = RF2.ic3eq = RF2.ic4eq = 0;
    RF3.ic1eq = RF3.ic2eq = RF3.ic3eq = RF3.ic4eq = 0;
    RF4.ic1eq = RF4.ic2eq = RF4.ic3eq = RF4.ic4eq = 0;
    
    LA_F4.ic5eq = LA_F4.ic6eq = LA_F3.ic5eq = LA_F3.ic6eq = LA_F2.ic5eq = LA_F2.ic6eq = 0;
    RA_F4.ic5eq = RA_F4.ic6eq = RA_F3.ic5eq = RA_F3.ic6eq = RA_F2.ic5eq = RA_F2.ic6eq = 0;

    LA_F4_2.ic5eq = LA_F4_2.ic6eq = LA_F3_2.ic5eq = LA_F3_2.ic6eq = LA_F4_3.ic5eq = LA_F4_3.ic6eq = 0;
    RA_F4_2.ic5eq = RA_F4_2.ic6eq = RA_F3_2.ic5eq = RA_F3_2.ic6eq = RA_F4_3.ic5eq = RA_F4_3.ic6eq = 0;
  );
  
  // Make sure the delay is the same on all bands (identical number of filters)
  function splitBands(sl, sr)
  local()
  global(Cuts, FIR, band_mode, lband_mode)
  instance( LF1, LF2, LF3, LF4            /* Lowpass left */
            LA_F2,                        /* Allpass frequency 2 left */
            LA_F3, LA_F3_2,               /* Allpass frequency 3 left */
            LA_F4, LA_F4_2, LA_F4_3,      /* Allpass frequency 4 left */
            RF1, RF2, RF3, RF4            /* Lowpass right */
            RA_F2,                        /* Allpass frequency 2 right */
            RA_F3, RA_F3_2,               /* Allpass frequency 3 right */
            RA_F4, RA_F4_2, RA_F4_3,      /* Allpass frequency 4 right */
            b1, b2, b3, b4, b5, lcuts )
  (
    ( lcuts != cuts ) ? (
      lcuts = cuts;
      this.resetBands();
    );
    
    band_mode == 0 ? (
      // 4p filters
      (cuts==0) ? (
        b1.inL = sl;
        b1.inR = sr;
      ) : (cuts==1) ? (
        LF1.eval_LR2(sl);
        b1.inL = LF1.lp;
        b2.inL = LF1.hp;
          
        RF1.eval_LR2(sr);
        b1.inR = RF1.lp;
        b2.inR = RF1.hp;
      ) : (cuts==2) ? (
        LF1.eval_LR2(sl);
        b1.inL   = LA_F2.eval_LRAP(LF1.lp);
          
        LF2.eval_LR2(LF1.hp);
        b2.inL   = LF2.lp;
        b3.inL   = LF2.hp;
          
        RF1.eval_LR2(sr);
        b1.inR   = RA_F2.eval_LRAP(RF1.lp);
          
        RF2.eval_LR2(RF1.hp);
        b2.inR   = RF2.lp;
        b3.inR   = RF2.hp;
      ) : (cuts == 3) ? (
        LF1.eval_LR2(sl);
        b1.inL   = LA_F3.eval_LRAP(LA_F2.eval_LRAP(LF1.lp));
          
        LF2.eval_LR2(LF1.hp);
        b2.inL   = LA_F3_2.eval_LRAP(LF2.lp);
          
        LF3.eval_LR2(LF2.hp);
        b3.inL   = LF3.lp;
        b4.inL   = LF3.hp;
          
        RF1.eval_LR2(sr);
        b1.inR   = RA_F3.eval_LRAP(RA_F2.eval_LRAP(RF1.lp));
        
        RF2.eval_LR2(RF1.hp);
        b2.inR   = RA_F3_2.eval_LRAP(RF2.lp);
        
        RF3.eval_LR2(RF2.hp);
        b3.inR   = RF3.lp;
        b4.inR   = RF3.hp;
      ) : (cuts == 4) ? (
        LF1.eval_LR2(sl);
        b1.inL   = LA_F4.eval_LRAP(LA_F3.eval_LRAP(LA_F2.eval_LRAP(LF1.lp)));
        
        LF2.eval_LR2(LF1.hp);
        b2.inL   = LA_F4_2.eval_LRAP(LA_F3_2.eval_LRAP(LF2.lp));
          
        LF3.eval_LR2(LF2.hp);
        b3.inL   = LA_F4_3.eval_LRAP(LF3.lp);
          
        LF4.eval_LR2(LF3.hp);
        b4.inL   = LF4.lp;
        b5.inL   = LF4.hp;
          
        RF1.eval_LR2(sr);
        b1.inR   = RA_F4.eval_LRAP(RA_F3.eval_LRAP(RA_F2.eval_LRAP(RF1.lp)));
          
        RF2.eval_LR2(RF1.hp);
        b2.inR   = RA_F4_2.eval_LRAP(RA_F3_2.eval_LRAP(RF2.lp));
          
        RF3.eval_LR2(RF2.hp);
        b3.inR   = RA_F4_3.eval_LRAP(RF3.lp);
          
        RF4.eval_LR2(RF3.hp);
        b4.inR   = RF4.lp;
        b5.inR   = RF4.hp;
      );
    ) : (
      // 2p filters
      (cuts==0) ? (
        b1.inL = sl;
        b1.inR = sr;
      ) : (cuts==1) ? (
        LF1.eval_LR1(sl);
        b1.inL = LF1.lp;
        b2.inL = - LF1.hp;
          
        RF1.eval_LR1(sr);
        b1.inR = RF1.lp;
        b2.inR = - RF1.hp;
      ) : (cuts==2) ? (
        LF1.eval_LR1(sl);
        b1.inL   = LA_F2.eval_AP1(LF1.lp);
          
        LF2.eval_LR1(LF1.hp);
        b2.inL   = -LF2.lp;
        b3.inL   = LF2.hp;
            
        RF1.eval_LR1(sr);
        b1.inR   = RA_F2.eval_AP1(RF1.lp);
            
        RF2.eval_LR1(RF1.hp);
        b2.inR   = -RF2.lp;
        b3.inR   = RF2.hp;
      ) : (cuts == 3) ? (
        LF1.eval_LR1(sl);
        b1.inL   = LA_F3.eval_AP1(LA_F2.eval_AP1(LF1.lp));
          
        LF2.eval_LR1(LF1.hp);
        b2.inL   = - LA_F3_2.eval_AP1(LF2.lp);
        
        LF3.eval_LR1(LF2.hp);
        b3.inL   = LF3.lp;
        b4.inL   = - LF3.hp;
          
        RF1.eval_LR1(sr);
        b1.inR   = RA_F3.eval_AP1(RA_F2.eval_AP1(RF1.lp));
        
        RF2.eval_LR1(RF1.hp);
        b2.inR   = - RA_F3_2.eval_AP1(RF2.lp);
        
        RF3.eval_LR1(RF2.hp);
        b3.inR   = RF3.lp;
        b4.inR   = - RF3.hp;
      ) : (cuts == 4) ? (
        LF1.eval_LR1(sl);
        b1.inL   = LA_F4.eval_AP1(LA_F3.eval_AP1(LA_F2.eval_AP1(LF1.lp)));
        
        LF2.eval_LR1(LF1.hp);
        b2.inL   = - LA_F4_2.eval_AP1(LA_F3_2.eval_AP1(LF2.lp));
          
        LF3.eval_LR1(LF2.hp);
        b3.inL   = LA_F4_3.eval_AP1(LF3.lp);
          
        LF4.eval_LR1(- LF3.hp);
        b4.inL   = LF4.lp;
        b5.inL   = - LF4.hp;
          
        RF1.eval_LR1(sr);
        b1.inR   = RA_F4.eval_AP1(RA_F3.eval_AP1(RA_F2.eval_AP1(RF1.lp)));
          
        RF2.eval_LR1(RF1.hp);
        b2.inR   = - RA_F4_2.eval_AP1(RA_F3_2.eval_AP1(RF2.lp));
          
        RF3.eval_LR1(RF2.hp);
        b3.inR   = RA_F4_3.eval_AP1(RF3.lp);
          
        RF4.eval_LR1(- RF3.hp);
        b4.inR   = RF4.lp;
        b5.inR   = - RF4.hp;
      );
    );
  );  
  
  // Convert to linear phase
  function linearPhase(fft_mem, fftCalcSize)
  local(fwd, r1, i1, mag1, flip, i, w)
  global()
  instance()
  (
    fwd = fft_mem;
    
    /* Making the filter linear phase involves both removing
       the phase; but then also shifting the impulse response
       to overlap with our chunk. If we just remove the phase, 
       we'd get an impulse response like this:
       \____/
       The goal is to shift it to the middle of the FIR section.
       Considering that the FIR section is at .25 of the spectrum,
       we have to shift it further than we normally would (a step of
       1.5 * pi rather than pi. */
    
    flip = 1;
    i = 0;
    loop(fftCalcSize,
      r1  = fwd[];
      i1  = fwd[1];
      
      mag1      = sqrt(sqr(r1) + sqr(i1));
            
      fwd[]     = mag1 * cos($pi*i);
      fwd[1]    = mag1 * sin($pi*i);

      i += 1.5;
      fwd += 2;
    );
    
    /*i = 0;
    loop(1,
      fft_mem[2*i] = 0;
      fft_mem[2*fftCalcSize-2*i] = 0;
      i = i + 1;
    );*/
    
  );
  
  function updateCoeffs()
  local(fptr1, fptr2, fptr3, fptr4, fptr5, middle, i, M)
  global(Cuts, Freq1, Freq2, Freq3, Freq4, FIR, FIR_quality,
         FIR1, FIR2, FIR3, FIR4, FIR5, bufferDist,
         firSize, fftCalcSize, band_mode, lband_mode, abs_placement, srate_changed)
  instance( F1,  F2,  F3,  F4
            LF1, LF2, LF3, LF4            /* Lowpass left */
            LA_F2,                        /* Allpass frequency 2 left */
            LA_F3, LA_F3_2,               /* Allpass frequency 3 left */
            LA_F4, LA_F4_2, LA_F4_3,      /* Allpass frequency 4 left */
            RF1, RF2, RF3, RF4            /* Lowpass right */
            RA_F2,                        /* Allpass frequency 2 right */
            RA_F3, RA_F3_2,               /* Allpass frequency 3 right */
            RA_F4, RA_F4_2, RA_F4_3,      /* Allpass frequency 4 right */
            lcuts, lFIR, lFIR_quality,
            lF1, lF2, lF3, lF4,
            labs_placement,
            updateRequired
            )
  (
      updateRequired = 0;
      updateRequired = (
        ( labs_placement != abs_placement ) ||
        ( lF1 != Freq1 ) ||
        ( lF2 != Freq2 ) ||
        ( lF3 != Freq3 ) ||
        ( lF4 != Freq4 ) ||
        ( cuts != lcuts ) ||
        ( FIR != lFIR ) ||
        ( FIR_quality != lFIR_quality ) ||
        srate_changed ||
        ( band_mode != lband_mode ));
        srate_changed = 0;
      updateRequired ? (
        M = 4;
        (FIR_quality > 0) ? M *= 2;
        (FIR_quality > 1) ? M *= 2;
        firSize = 512*M;
        fftCalcSize = 1024*M;
        lband_mode = band_mode;
        labs_placement = abs_placement;
      
        lF1 = Freq1;
        lF2 = Freq2;
        lF3 = Freq3;
        lF4 = Freq4;
        lFIR = FIR;
        lFIR_quality = FIR_quality;
        lcuts = cuts;
      
        abs_placement ? (
          F1 = clamp(Freq1, 0, 1);
          F2 = clamp(Freq2, F1, cuts > 2 ? F3 : 1);
          F3 = clamp(Freq3, F2, cuts > 3 ? F4 : 1);
          F4 = clamp(Freq4, F3, 1.0);
        ) : (
          F1 = Freq1;
          F2 = Freq1  + Freq2 * (1 - Freq1);
          F3 = F2     + Freq3 * (1 - F2);
          F4 = F3     + Freq4 * (1 - F3);
        );
          
        (cuts==1) ? (
          LF1.init_LR2(Freq1);
          RF1.k  = LF1.k;
          RF1.a1 = LF1.a1;
          RF1.a2 = LF1.a2;
          RF1.a3 = LF1.a3;
        ) : (cuts==2) ? (
          LF1.init_LR2(Freq1);
          RF1.k  = LF1.k;
          RF1.a1 = LF1.a1;
          RF1.a2 = LF1.a2;
          RF1.a3 = LF1.a3;
          LF2.init_LR2(F2);
          RF2.k  = LF2.k;
          RF2.a1 = LF2.a1;
          RF2.a2 = LF2.a2;
          RF2.a3 = LF2.a3;
          
          (band_mode == 0) ? (
            LA_F2.init_LR2(F2);
          ) : (
            LA_F2.init_AP1(F2);
          );
          RA_F2.k  = LA_F2.k;
          RA_F2.a1 = LA_F2.a1;
          RA_F2.a2 = LA_F2.a2;
          RA_F2.a3 = LA_F2.a3;
        ) : (cuts == 3) ? (
          LF1.init_LR2(Freq1);
          RF1.k  = LF1.k;
          RF1.a1 = LF1.a1;
          RF1.a2 = LF1.a2;
          RF1.a3 = LF1.a3;
          LF2.init_LR2(F2);
          RF2.k  = LF2.k;
          RF2.a1 = LF2.a1;
          RF2.a2 = LF2.a2;
          RF2.a3 = LF2.a3;
          LF3.init_LR2(F3);
          RF3.k  = LF3.k;
          RF3.a1 = LF3.a1;
          RF3.a2 = LF3.a2;
          RF3.a3 = LF3.a3;
          
          // All-passes for maintaining the phase relation between the bands
          (band_mode == 0) ? (
            LA_F2.init_LR2(F2);
            LA_F3.init_LR2(F3);
          ) : (
            LA_F2.init_AP1(F2);
            LA_F3.init_AP1(F3);
          );
          
          RA_F3.k   = RA_F3_2.k  = LA_F3_2.k  = LA_F3.k;
          RA_F3.a1  = RA_F3_2.a1 = LA_F3_2.a1 = LA_F3.a1;
          RA_F3.a2  = RA_F3_2.a2 = LA_F3_2.a2 = LA_F3.a2;
          RA_F3.a3  = RA_F3_2.a3 = LA_F3_2.a3 = LA_F3.a3;
    
          RA_F2.k  = LA_F2.k;
          RA_F2.a1 = LA_F2.a1;
          RA_F2.a2 = LA_F2.a2;
          RA_F2.a3 = LA_F2.a3;
        ) : (cuts == 4) ? (
          LF1.init_LR2(Freq1);
          RF1.k  = LF1.k;
          RF1.a1 = LF1.a1;
          RF1.a2 = LF1.a2;
          RF1.a3 = LF1.a3;
          LF2.init_LR2(F2);
          RF2.k  = LF2.k;
          RF2.a1 = LF2.a1;
          RF2.a2 = LF2.a2;
          RF2.a3 = LF2.a3;
          LF3.init_LR2(F3);
          RF3.k  = LF3.k;
          RF3.a1 = LF3.a1;
          RF3.a2 = LF3.a2;
          RF3.a3 = LF3.a3;
          LF4.init_LR2(F4);
          RF4.k  = LF4.k;
          RF4.a1 = LF4.a1;
          RF4.a2 = LF4.a2;
          RF4.a3 = LF4.a3;
          
          // All-passes for maintaining the phase relation between the bands
          (band_mode == 0) ? (
            LA_F2.init_LR2(F2);
            LA_F3.init_LR2(F3);
            LA_F4.init_LR2(F4);
          ) : (
            LA_F2.init_AP1(F2);
            LA_F3.init_AP1(F3);
            LA_F4.init_AP1(F4);
          );
          
          RA_F4.k  = RA_F4_2.k  = RA_F4_3.k  = LA_F4_2.k  = LA_F4_3.k  = LA_F4.k;
          RA_F4.a1 = RA_F4_2.a1 = RA_F4_3.a1 = LA_F4_2.a1 = LA_F4_3.a1 = LA_F4.a1;
          RA_F4.a2 = RA_F4_2.a2 = RA_F4_3.a2 = LA_F4_2.a2 = LA_F4_3.a2 = LA_F4.a2;
          RA_F4.a3 = RA_F4_2.a3 = RA_F4_3.a3 = LA_F4_2.a3 = LA_F4_3.a3 = LA_F4.a3;
          
          RA_F3.k   = RA_F3_2.k  = LA_F3_2.k  = LA_F3.k;
          RA_F3.a1  = RA_F3_2.a1 = LA_F3_2.a1 = LA_F3.a1;
          RA_F3.a2  = RA_F3_2.a2 = LA_F3_2.a2 = LA_F3.a2;
          RA_F3.a3  = RA_F3_2.a3 = LA_F3_2.a3 = LA_F3.a3;
    
          RA_F2.k  = LA_F2.k;
          RA_F2.a1 = LA_F2.a1;
          RA_F2.a2 = LA_F2.a2;
          RA_F2.a3 = LA_F2.a3;
        );
        
        /* Are we dealing with a FIR filter? */
        FIR ? (
          // CalcFIR
          memset(FIR1, 0, bufferDist);
          memset(FIR2, 0, bufferDist);
          memset(FIR3, 0, bufferDist);
          memset(FIR4, 0, bufferDist);
          memset(FIR5, 0, bufferDist);
          
          this.resetFilters();
        
          /* Fetch impulse response */
          fptr1 = FIR1;
          fptr2 = FIR2;
          fptr3 = FIR3;
          fptr4 = FIR4;
          fptr5 = FIR5;

          this.splitBands(1.0/fftCalcSize, 1.0/fftCalcSize);
               
          loop(firSize,
            fptr1[] = this.b1.inL; fptr1 += 2;
            fptr2[] = this.b2.inL; fptr2 += 2;
            fptr3[] = this.b3.inL; fptr3 += 2;
            fptr4[] = this.b4.inL; fptr4 += 2;
            fptr5[] = this.b5.inL; fptr5 += 2;
          
            this.splitBands(0, 0);
          );
          
          //FIR1[0]=1/fftCalcSize;
                    
          /* Transform impulse responses */
          fft(FIR1, fftCalcSize);
          fft(FIR2, fftCalcSize);
          fft(FIR3, fftCalcSize);
          fft(FIR4, fftCalcSize);
          fft(FIR5, fftCalcSize);
          
          fft_permute(FIR1, fftCalcSize);
          fft_permute(FIR2, fftCalcSize);
          fft_permute(FIR3, fftCalcSize);
          fft_permute(FIR4, fftCalcSize);
          fft_permute(FIR5, fftCalcSize);
          
          /* Remove phase information (converts to linear phase) */
          linearPhase(FIR1, fftCalcSize);
          linearPhase(FIR2, fftCalcSize);
          linearPhase(FIR3, fftCalcSize);
          linearPhase(FIR4, fftCalcSize);
          linearPhase(FIR5, fftCalcSize);
          
          fft_ipermute(FIR1, fftCalcSize);
          fft_ipermute(FIR2, fftCalcSize);
          fft_ipermute(FIR3, fftCalcSize);
          fft_ipermute(FIR4, fftCalcSize);
          fft_ipermute(FIR5, fftCalcSize);
        );
      );
    
    updateRequired
  );
  
  function doFIR(l, r, block1, block2, fftCalcSize, filterSize, filterLoc, cPos)
  instance(curBlock, lastBlock, initialized, chunkSize, chunksizeT2)
  local(tmp, cPosT2)
  global(bufferdist)
  (
    !initialized ? (
      curBlock  = block1;
      lastBlock = block2;
      
      memset(curBlock, 0, bufferdist);
      memset(lastBlock, 0, bufferdist);
      initialized = 1;
      
      chunkSize   = (fftCalcSize - filterSize - 1);
      chunkSizeT2 = chunkSize * 2;
    );
  
    cPos >= chunkSize ? 
    (
      tmp       = lastBlock;
      lastBlock = curBlock;
      curBlock  = tmp;
     
      /* Empty out the data beyond chunkSize of the block that has 
         just been filled. This used to be the carried over overlap-add
         tail of the previous one */
      memset( curBlock + chunkSizeT2, 0, (fftCalcSize-chunkSize)*2 );
    
      /* Calculate FFT of current chunk */
      fft(curBlock, fftCalcSize);
      //fft_permute(curBlock, fftCalcSize);
      
      /* Convolve with the FIR filter (already FFT'd) */
      convolve_c(curBlock, filterLoc, fftCalcSize);
      //fft_ipermute(curBlock, fftCalcSize);
      ifft(curBlock, fftCalcSize);
      
      cPos = 0;
    );
      
    /* Save sample */
    cPosT2 = cPos * 2;
    lastBlock[cPosT2]   = l;
    lastBlock[cPosT2+1] = r;
    
    this.inL = curBlock[cPosT2];
    this.inR = curBlock[cPosT2+1];
    
    /* Overlap add the previous tail */
    ( cPos < (fftCalcSize-chunkSize) ) ? 
    (
      this.inL += lastBlock[chunkSizeT2+cPosT2];
      this.inR += lastBlock[chunkSizeT2+cPosT2+1];
      1
    );
 
    cPos + 1
  );
  
  function processSample()
  (  
    FIR ? (
      filterBank.resetBands();   
      cPosNew = filterBank.b1.doFIR(inL, inR, F1Block1, F1Block2, fftCalcSize, firSize, FIR1, cPos);
      ( cuts > 0 ) ? ( filterBank.b2.doFIR(inL, inR, F2Block1, F2Block2, fftCalcSize, firSize, FIR2, cPos); );
      ( cuts > 1 ) ? ( filterBank.b3.doFIR(inL, inR, F3Block1, F3Block2, fftCalcSize, firSize, FIR3, cPos); );
      ( cuts > 2 ) ? ( filterBank.b4.doFIR(inL, inR, F4Block1, F4Block2, fftCalcSize, firSize, FIR4, cPos); );
      ( cuts > 3 ) ? ( filterBank.b5.doFIR(inL, inR, F5Block1, F5Block2, fftCalcSize, firSize, FIR5, cPos); );
      cPos = cPosNew;
    ) : (
      filterBank.splitBands(inL, inR);
    );
    
    filterBank.processBands();
  );
    
  FIR ? (
    specBuffer.updateBuffer(.5*(spl0+spl1));
    specBuffer.setOffset(newPDC+2);
    cSpec = specBuffer.readBuffer();
    spectrumIn.feedSample(cSpec);
  ) : (
    spectrumIn.feedSample(.5*(spl0+spl1));
  );



S2_sample_on = 1;

gmem[16*64 + 10 + link_group] != 1 ? link_group = 0;
group_check_smpl();
caller == 1 ? (
  parameters_update_on == 0 ? (
    parameters_update();
  );
);



playstates();


process = 0;
while_playing ? is_playing ? process = 1;
while_recording ? is_recording ? process = 1;
while_stopped ? is_stopped ? process = 1;
bypass == 1 ? process = 0;


process == 1 ? (
srate != srate_old ? (
srate_old = srate;
//resetFilters();
//re_init();
//initBands();
srate_changed = 1;
);

  // Split signal into bands
  
  filterBank.updateCoeffs();
  inL = spl0;
  inR = spl1;
 

 
 
 
 
  processSample();
  
  
  vspl0 = filterBank.b1.l;
  vspl1 = filterBank.b1.r;
  out = spl0 + spl1;
  ( cuts > 0 ) ? (
    vspl2 = filterBank.b2.l;
    vspl3 = filterBank.b2.r;
    out += spl2 + spl3;
    ( cuts > 1 ) ? (
      vspl4 = filterBank.b3.l;
      vspl5 = filterBank.b3.r;
      out += spl4 + spl5;
      ( cuts > 2 ) ? (
        vspl6 = filterBank.b4.l;
        vspl7 = filterBank.b4.r;
        out += spl6 + spl7;
        ( cuts > 3 ) ? (
          vspl8 = filterBank.b5.l;
          vspl9 = filterBank.b5.r;
          out += spl8 + spl9;
        );
      );
    );
  );
  //spectrumOut.feedSample(.5*out);

  
  
  // OCTAVER
  !Sub_bypass ? (
  ss0=vspl0;
  ss1=vspl1;
  
  hbp=bufpos&65534;
  s0r=bufsize[hbp]; // read these early
  s1r=bufsize[hbp+1];
  
  (bufpos*2)[0]=vspl0;
  (bufpos*2)[1]=vspl1;
  
  bufpos < rspos ? (
    sc=bufpos*invbs;
    vspl0=hbp[0]*sc + s0r*(1-sc);
    vspl1=hbp[1]*sc + s1r*(1-sc);
  ) : (
    vspl0=hbp[0];
    vspl1=hbp[1];
  );
  
  (bufpos+=1) >= bufsize ? bufpos=0;
  
  vspl0=vspl0*sublevel+ss0*basslevel;
  vspl1=vspl1*sublevel+ss1*basslevel;
  
  ); //Bypass
  //OCTAVER ENDE
  
  // EXCITER
  !Exc_Bypass ? (
  exc0 = (1+foo)*s0/(1+foo*abs(vspl4));
  exc1 = (1+foo)*s1/(1+foo*abs(vspl5));
  vspl4 = exc0*exclevel + vspl4 * treblelevel;
  vspl5 = exc1*exclevel + vspl5 * treblelevel;
  ); // Bypass 
  //
  
   //Uncomment for testing flatness
  //!Band1_Solo && !Band2_Solo && !Band3_Solo && !Band4_Solo && !Band5_Solo ? (
  spl0 = (vspl0 + vspl2 + vspl4 + vspl6 + vspl8)*output_level;
  spl1 = (vspl1 + vspl3 + vspl5 + vspl7 + vspl9)*output_level;
  //solo = 0;
  //):(
  //spl0 = spl1 = 0;
  //Band1_Solo ? (spl0 += vspl0; spl1 += vspl1);
  //Band2_Solo ? (spl0 += vspl2; spl1 += vspl3);
  //Band3_Solo ? (spl0 += vspl4; spl1 += vspl5);
  //Band4_Solo ? (spl0 += vspl6; spl1 += vspl7);
  //Band5_Solo ? (spl0 += vspl8; spl1 += vspl9);
  //solo = 1;
  //);
  curSample += 1;
  
 
  ); //process == 1
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
@gfx 938 200


 mouseHold = mouse_cap & 1;
 press_superkey = mouse_cap & 32;
 press_ctrl = mouse_cap & 4;
 press_shift = mouse_cap & 8;
 press_alt = mouse_cap & 16;
 superkey=ctrl=shift=alt=shift_alt=shift_ctrl=shift_superkey=ctrl_superkey = 0;
 press_superkey ? !press_ctrl ? !press_shift ? !press_alt ? superkey=press_superkey;
 !press_superkey ? press_ctrl ? !press_shift ? !press_alt ? ctrl=press_ctrl;
 !press_superkey ? !press_ctrl ? press_shift ? !press_alt ? shift=press_shift;
 !press_superkey ? !press_ctrl ? !press_shift ? press_alt ? alt=press_alt;
 !press_superkey ? !press_ctrl ? press_shift ? press_alt ? shift_alt=1;
 !press_superkey ? press_ctrl ? press_shift ? !press_alt ? shift_ctrl=1;
 press_superkey ? !press_ctrl ? press_shift ? !press_alt ? shift_superkey=1;
 press_superkey ? press_ctrl ? !press_shift ? !press_alt ? ctrl_superkey=1;
 
 mouseClick = mouseHold - lastCap;
 lastCap = mouseHold;

at_start == -1 ? atstart = gfx_ext_flags;

gfx_ext_flags == 0 ? (

s2_zoom_X = gfx_w / 938;
s2_zoom_y = gfx_h / 200;
zoom = min(s2_zoom_x, s2_zoom_y);// * gfx_ext_retina;
zoom_off == 1 ? zoom = gfx_ext_retina;

//black(); gfx_rect(0,0,gfx_w,gfx_h);
gfx_x = 0;
gfx_y = 0;
gfx_blit(0,1,0);

 
/*
 gfx_x = 5; gfx_y = 5; lightgrey();
 gfx_drawnumber(per_to_freq(freq1*100,100),0); gfx_drawstr(" ");
  gfx_drawnumber(per_to_freq(freq2*100,100),0); gfx_drawstr(" ");
   gfx_drawnumber(ratio2db(output_level),1); gfx_drawstr(" ");
  */
  
  

  
  gfx_a = 1; 
   K_Sub_Freq.knob();
   gfx_setfont(1,"Arial",12*zoom,'b');
   #klabel = "SUB FREQ"; gfx_measurestr(#klabel, klw, klh); K_Sub_Freq.knoblabelposition(klw); lightgrey(); gfx_drawstr(#klabel);
   #kmeasure = "Hz"; gfx_measurestr(#kmeasure, klw, klh); K_Sub_Freq.knobmeasureposition(klw, klh); lakeblue(); gfx_a = 0.8; gfx_drawstr(#kmeasure); gfx_a = 1;
   gfx_setfont(2,"Arial",10*zoom,'b');
   #klabel = "20"; gfx_measurestr(#klabel, klw, klh); K_Sub_Freq.labelposition(1,klw, klh); lightgrey(); gfx_drawstr(#klabel);
   #klabel = "60"; gfx_measurestr(#klabel, klw, klh); K_Sub_Freq.labelposition(3,klw, klh); lightgrey(); gfx_drawstr(#klabel);
   #klabel = "200"; gfx_measurestr(#klabel, klw, klh); K_Sub_Freq.labelposition(5,klw, klh); lightgrey(); gfx_x += 1*zoom; gfx_drawstr(#klabel); 
   #klabel = "600"; gfx_measurestr(#klabel, klw, klh); K_Sub_Freq.labelposition(7,klw, klh); lightgrey(); gfx_drawstr(#klabel); 
   #klabel = "2k"; gfx_measurestr(#klabel, klw, klh); K_Sub_Freq.labelposition(9,klw, klh); lightgrey(); gfx_drawstr(#klabel); 
   gfx_setfont(1,"Arial",12*zoom,'b');  
   
   K_Sub_Mix.knob();
   gfx_setfont(1,"Arial",12*zoom,'b');
   #klabel = "SUB MIX"; gfx_measurestr(#klabel, klw, klh); K_Sub_Mix.knoblabelposition(klw); lightgrey(); gfx_drawstr(#klabel);
   #kmeasure = "dB"; gfx_measurestr(#kmeasure, klw, klh); K_Sub_Mix.knobmeasureposition(klw, klh); lakeblue(); gfx_a = 0.8; gfx_drawstr(#kmeasure); gfx_a = 1;
   gfx_setfont(2,"Arial",10*zoom,'b');
   #klabel = "OFF"; gfx_measurestr(#klabel, klw, klh); K_Sub_Mix.labelposition(1,klw, klh); lightgrey(); gfx_drawstr(#klabel);
   #klabel = "-3"; gfx_measurestr(#klabel, klw, klh); K_Sub_Mix.labelposition(3,klw, klh); lightgrey(); gfx_drawstr(#klabel);
   #klabel = "3"; gfx_measurestr(#klabel, klw, klh); K_Sub_Mix.labelposition(5,klw, klh); lightgrey(); gfx_x += 1*zoom; gfx_drawstr(#klabel); 
   #klabel = "6.5"; gfx_measurestr(#klabel, klw, klh); K_Sub_Mix.labelposition(7,klw, klh); lightgrey(); gfx_drawstr(#klabel); 
   #klabel = "9"; gfx_measurestr(#klabel, klw, klh); K_Sub_Mix.labelposition(9,klw, klh); lightgrey(); gfx_drawstr(#klabel); 
   gfx_setfont(1,"Arial",12*zoom,'b'); 
   
   K_Exc_Freq.knob();
   gfx_setfont(1,"Arial",12*zoom,'b');
   #klabel = "EXCITER FREQ"; gfx_measurestr(#klabel, klw, klh); K_Exc_Freq.knoblabelposition(klw); lightgrey(); gfx_drawstr(#klabel);
   #kmeasure = "Hz"; gfx_measurestr(#kmeasure, klw, klh); K_Exc_Freq.knobmeasureposition(klw, klh); lakeblue(); gfx_a = 0.8; gfx_drawstr(#kmeasure); gfx_a = 1;
   gfx_setfont(2,"Arial",10*zoom,'b');
   #klabel = "1.2k"; gfx_measurestr(#klabel, klw, klh); K_Exc_Freq.labelposition(1,klw, klh); lightgrey(); gfx_drawstr(#klabel);
   #klabel = "2.6k"; gfx_measurestr(#klabel, klw, klh); K_Exc_Freq.labelposition(3,klw, klh); lightgrey(); gfx_drawstr(#klabel);
   #klabel = "5.3k"; gfx_measurestr(#klabel, klw, klh); K_Exc_Freq.labelposition(5,klw, klh); lightgrey(); gfx_x += 1*zoom; gfx_drawstr(#klabel); 
   #klabel = "10k"; gfx_measurestr(#klabel, klw, klh); K_Exc_Freq.labelposition(7,klw, klh); lightgrey(); gfx_drawstr(#klabel); 
   #klabel = "20k"; gfx_measurestr(#klabel, klw, klh); K_Exc_Freq.labelposition(9,klw, klh); lightgrey(); gfx_drawstr(#klabel); 
   gfx_setfont(1,"Arial",12*zoom,'b'); 
   
   K_Exc_Mix.knob();
   gfx_setfont(1,"Arial",12*zoom,'b');
   #klabel = "EXCITER MIX"; gfx_measurestr(#klabel, klw, klh); K_Exc_Mix.knoblabelposition(klw); lightgrey(); gfx_drawstr(#klabel);
   #kmeasure = "dB"; gfx_measurestr(#kmeasure, klw, klh); K_Exc_Mix.knobmeasureposition(klw, klh); lakeblue(); gfx_a = 0.8; gfx_drawstr(#kmeasure); gfx_a = 1;
   gfx_setfont(2,"Arial",10*zoom,'b');
   #klabel = "OFF"; gfx_measurestr(#klabel, klw, klh); K_Exc_Mix.labelposition(1,klw, klh); lightgrey(); gfx_drawstr(#klabel);
   #klabel = "-3"; gfx_measurestr(#klabel, klw, klh); K_Exc_Mix.labelposition(3,klw, klh); lightgrey(); gfx_drawstr(#klabel);
   #klabel = "3"; gfx_measurestr(#klabel, klw, klh); K_Exc_Mix.labelposition(5,klw, klh); lightgrey(); gfx_x += 1*zoom; gfx_drawstr(#klabel); 
   #klabel = "6.5"; gfx_measurestr(#klabel, klw, klh); K_Exc_Mix.labelposition(7,klw, klh); lightgrey(); gfx_drawstr(#klabel); 
   #klabel = "9"; gfx_measurestr(#klabel, klw, klh); K_Exc_Mix.labelposition(9,klw, klh); lightgrey(); gfx_drawstr(#klabel); 
   gfx_setfont(1,"Arial",12*zoom,'b'); 
   

   K_Out.knob();
   gfx_setfont(1,"Arial",12*zoom,'b');
   #klabel = "OUTPUT"; gfx_measurestr(#klabel, klw, klh); K_Out.knoblabelposition(klw); lightgrey(); gfx_drawstr(#klabel);
   #kmeasure = "dB"; gfx_measurestr(#kmeasure, klw, klh); K_Out.knobmeasureposition(klw, klh); lakeblue(); gfx_a = 0.8; gfx_drawstr(#kmeasure); gfx_a = 1;
   gfx_setfont(2,"Arial",10*zoom,'b');
   #klabel = "OFF"; gfx_measurestr(#klabel, klw, klh); K_Out.labelposition(1,klw, klh); lightgrey(); gfx_drawstr(#klabel);
   #klabel = "-6"; gfx_measurestr(#klabel, klw, klh); K_Out.labelposition(3,klw, klh); lightgrey(); gfx_drawstr(#klabel);
   #klabel = "±0"; gfx_measurestr(#klabel, klw, klh); K_Out.labelposition(5,klw, klh); lightgrey(); gfx_x += 1*zoom; gfx_drawstr(#klabel); 
   #klabel = "+3.5"; gfx_measurestr(#klabel, klw, klh); K_Out.labelposition(7,klw, klh); lightgrey(); gfx_drawstr(#klabel); 
   #klabel = "+6"; gfx_measurestr(#klabel, klw, klh); K_Out.labelposition(9,klw, klh); lightgrey(); gfx_drawstr(#klabel); 
   gfx_setfont(1,"Arial",12*zoom,'b'); 
   
   b_sub_bypass.button();
   gfx_x = B_sub_bypass.xin*zoom + 3*zoom;
   gfx_y = B_sub_bypass.yin*zoom + 35*zoom;
   gfx_drawstr("SUB");
   gfx_x = B_sub_bypass.xin*zoom + 3*zoom;
   gfx_y = B_sub_bypass.yin*zoom + 50*zoom;   
   gfx_drawstr("BYPASS");
   
   b_exc_bypass.button();
   gfx_x = B_exc_bypass.xin*zoom + 3*zoom;
   gfx_y = B_exc_bypass.yin*zoom + 35*zoom;
   gfx_drawstr("EXCITER");
   gfx_x = B_exc_bypass.xin*zoom + 3*zoom;
   gfx_y = B_exc_bypass.yin*zoom + 50*zoom;   
   gfx_drawstr("BYPASS");
   
   B_Bypass.button();
   gfx_x = B_bypass.xin*zoom - 55*zoom;
   gfx_y = B_bypass.yin*zoom + 12*zoom;
   gfx_drawstr("BYPASS");
   
   gfx_roundrect(K_Sub_freq.xIn*zoom - 30 *zoom, K_Sub_freq.yIn*zoom - 25*zoom, 350*zoom, 130*zoom, 7*zoom);
   gfx_roundrect(K_Sub_freq.xIn*zoom - 30 *zoom, K_Sub_freq.yIn*zoom + 105 *zoom, 350*zoom, 20*zoom, 7*zoom);
   gfx_x = K_Sub_freq.xIn*zoom - 30 *zoom; gfx_y = K_Sub_freq.yIn*zoom + 110 *zoom;
   gfx_drawstr("FAT BOTTOM", 0x05, gfx_x+350*zoom, gfx_y + gfx_texth);
   
   
   gfx_roundrect(K_exc_freq.xIn*zoom - 30 *zoom, K_exc_freq.yIn*zoom - 25*zoom, 350*zoom, 130*zoom, 7*zoom);
   gfx_roundrect(K_Exc_freq.xIn*zoom - 30 *zoom, K_Exc_freq.yIn*zoom + 105 *zoom, 350*zoom, 20*zoom, 7*zoom);
   gfx_x = K_Exc_freq.xIn*zoom - 30 *zoom; gfx_y = K_Exc_freq.yIn*zoom + 110 *zoom;
   gfx_drawstr("EXCITER", 0x05, gfx_x+350*zoom, gfx_y + gfx_texth);
   
   gfx_roundrect(K_exc_freq.xIn*zoom + 320 *zoom, K_exc_freq.yIn*zoom - 25*zoom, 150*zoom, 130*zoom, 7*zoom);
   gfx_roundrect(K_Exc_freq.xIn*zoom + 320 *zoom, K_Exc_freq.yIn*zoom + 105 *zoom, 150*zoom, 20*zoom, 7*zoom);
   gfx_x = K_Exc_freq.xIn*zoom + 320 *zoom; gfx_y = K_Exc_freq.yIn*zoom + 110 *zoom;
   gfx_drawstr("MASTER", 0x05, gfx_x+150*zoom, gfx_y + gfx_texth);
   
   gfx_x = 860 * zoom; gfx_y = 75*zoom; gfx_a = 0.8;
   gfx_blit(logo, zoom*0.6, 0);
   gfx_a = 1;
   
   ////////////////////////////////////////////////////////////////////////////////////////////// MAUS STEUERUNG
         !Number_input ? (
   
         mouseClick == 1 ? (
         K_Sub_Freq.k_collision() ? (K_Sub_Freq.dragstart(); NISlider = 1);
         K_Sub_Mix.k_collision() ? (K_Sub_Mix.dragstart(); NISlider = 0);
         K_Exc_Freq.k_collision() ? (K_Exc_Freq.dragstart(); NISlider = 1);
         K_Exc_Mix.k_collision() ? (K_Exc_Mix.dragstart(); NISlider = 0);
         K_Out.k_collision() ? (K_Out.dragstart(); NISlider = 0);
         
         B_Sub_Bypass.B_Collision() ? (slider(B_Sub_Bypass.slider) == 0 ? slider(B_Sub_Bypass.slider) = 1: slider(B_Sub_Bypass.slider) = 0;  B_Sub_Bypass.quicklink_button(); caller = 1);
         B_exc_Bypass.B_Collision() ?  (slider(B_exc_Bypass.slider) == 0 ? slider(B_exc_Bypass.slider) = 1 : slider(B_Exc_Bypass.slider) = 0;  B_exc_Bypass.quicklink_button(); caller = 1);
         B_Bypass.B_Collision() ?  (slider(B_Bypass.slider) == 0 ? slider(B_Bypass.slider) = 1: slider(B_Bypass.slider) = 0;  B_Bypass.quicklink_button(); caller = 1);
         );
         
         mouseclick == -1 ? (
         circle_dragging = 0;
                 K_Sub_Freq.dragstop();
                 K_Sub_Mix.dragstop();
                 K_Exc_Freq.dragstop();
                 K_Exc_Mix.dragstop();
                 K_Out.dragstop();
         );
         
         mouse_wheel ? 
             (
         K_Sub_Freq.k_collision() ? K_Sub_Freq.potwheel();
         K_Sub_Mix.k_collision() ? K_Sub_Mix.potwheel();
         K_Exc_Freq.k_collision() ? K_Exc_Freq.potwheel();
         K_Exc_Mix.k_collision() ? K_Exc_Mix.potwheel();
         K_Out.k_collision() ? K_Out.potwheel();
              mouse_wheel=0;
              caller = 1;
             );
        K_Sub_Freq.dragging ? (K_Sub_Freq.potdrag(); K_Sub_Freq.readout_f(0);caller = 1;);
        K_Sub_Mix.dragging ? (K_Sub_Mix.potdrag(); K_Sub_Mix.readout_db(1);caller = 1;);
        K_Exc_Freq.dragging ? (K_Exc_Freq.potdrag(); K_Exc_Freq.readout_f(0);caller = 1;);
        K_Exc_Mix.dragging ? (K_Exc_Mix.potdrag(); K_Exc_Mix.readout_db(1);caller = 1;);
        K_Out.dragging ? (K_Out.potdrag(); K_Out.readout_db(1);caller = 1;);
   
        ); // !number_input
        
             gfx_a=1;
             number_input ? NISlider ? number_input_show_freq() : number_input_show_db();
             //OEQ_NI == 1 ? number_input
             number_input_invalid = max(0,number_input_invalid-1);
             number_input_invalid ? ( 
             gfx_r=gfx_g=gfx_b=0;
             gfx_rect(zoom*number_input_x,number_input_y*zoom, 200*zoom, gfx_texth+5);
             gfx_r=0;gfx_g=1;gfx_b=0;
             gfx_rect(zoom*number_input_x,zoom*number_input_y, gfx_texth+5, gfx_texth+5);
             red();
             gfx_rect(zoom*number_input_x + gfx_texth+5,zoom*number_input_y, 200*zoom - (gfx_texth+5), gfx_texth+5);
             gfx_r=gfx_g=gfx_b=0.7;
             gfx_roundrect(zoom*number_input_x,zoom*number_input_y, 200*zoom, gfx_texth+5,0);
             gfx_x = zoom*number_input_x + gfx_texth+7; gfx_y = zoom*number_input_y + 2;
             white();
             gfx_drawstr("NO VALID INPUT!");
             );
             
            
             Link_Group == 0 ? (
             gmem[16*64 + 3] == 0 ? linkstart = 0;
             !mouse_cap ? (
             gmem[16*64 + 3] == 1 ? (linkstart == 0 ? link_old = slider(gmem[16*64 + 1]); linkstart = 1);
             gmem[16*64 + 3] == 1 ? (
                  tmp_val = link_old +  gmem[16*64 + 2];
             slider(gmem[16*64 + 1]) = tmp_val;
             slider_automate(slider(gmem[16*64 + 1]));
             caller = 1;
             );
             gmem[16*64 + 3] == 2 ? (
             slider(gmem[16*64 + 1]) =  gmem[16*64 + 2];
             caller = 1;
             );
             );
             );
           
           
        ////////////////////////////////////////////////////////////////////////////////////////////// ENDE MAUS STEUERUNG
        
        
        
         ////////////////////////////////////////// MENU MENU MENU ////////////////////////////////////////////////
         last_clicked_item = -1;
         Helpshow ? mouse_cap ? (helpshow = 0;last_clicked_item = -1);
         menu_x = 5; menu_y =5;
        
        gfx_x = menu_x * zoom; gfx_y = menu * zoom; gfx_a=1;
        //gfx_blit(menu,zoom/2,0);
        lightgrey(); //red();
        gfx_roundrect(menu_x * zoom, (menu_y + 5) * zoom, 20*zoom, 20*zoom, 0, 1);
        gfx_line((menu_x+3)*zoom, (menu_y + 11)*zoom, (menu_x+17)*zoom, (menu_y + 11)*zoom);
        gfx_line((menu_x+3)*zoom, (menu_y + 15)*zoom, (menu_x+17)*zoom, (menu_y + 15)*zoom);
        gfx_line((menu_x+3)*zoom, (menu_y + 19)*zoom, (menu_x+17)*zoom, (menu_y + 19)*zoom);
        
        gfx_setfont(1,"Arial",12*zoom,'b');
        lightgrey(); gfx_x = menu_x * zoom + 30*zoom;gfx_y += 4*zoom;
        gfx_drawstr("TUKAN STUDIOS  -  EXCITER WITH FAT BOTTOM "); 
        gfx_setfont(1,"Arial",12*zoom,'i');
        lakeblue(); gfx_drawstr(" SERIES 2   ");
        gfx_setfont(1,"Arial",12*zoom,'b');
        
        
        
        link_group ? (
          rgb_palette(Link_group);// gfx_a = 0.7;
          gfx_drawstr("JOINS GROUP "); gfx_drawstr(sprintf(#,"%i", link_group));
        );
        gfx_a = 1;
        
        
         mouseClick ? (
          g_collision(menu_x*zoom, (menu_y+5) * zoom, 20*zoom, 20*zoom) ? (
           gfx_x = menu_x*zoom;
           gfx_y = (menu_y+20)*zoom;
            
             #item2 =">Processing|";#allitems = #item2;
            while_playing == 1 ? (#item2 = "!On Playback|"):(#item2 = "On Playback|");#allitems += #item2;
            while_recording == 1 ? (#item2 = "!On Recording|"):(#item2 = "On Recording|");#allitems += #item2;
            while_stopped == 1 ? (#item2 = "<!On Stop|>Groups|"):(#item2 = "<On Stop|>Groups|");#allitems += #item2;
        
            mnu_grp_loop = 1;
            loop(16,
        
              mnu_grp_loop == 16 ? #item2 += "<";
              gmem[16*64 + 10 + mnu_grp_loop] == 1 ? ( //Gruppe schon an ?
                mnu_grp_loop == Link_Group ? ( //ist selbst in der gruppe
                        #item2 = "!Joins Group ";
                ):(
                    #item2 = "Add to Group ";
                );
              ):(
                #item2 = "Start Group ";
              );
            mnu_grp_loop == 1 ? #item2 += "01";
            mnu_grp_loop == 2 ? #item2 += "02";
            mnu_grp_loop == 3 ? #item2 += "03";
            mnu_grp_loop == 4 ? #item2 += "04";
            mnu_grp_loop == 5 ? #item2 += "05";
            mnu_grp_loop == 6 ? #item2 += "06";
            mnu_grp_loop == 7 ? #item2 += "07";
            mnu_grp_loop == 8 ? #item2 += "08";
            mnu_grp_loop == 9 ? #item2 += "09";
            mnu_grp_loop == 10 ? #item2 += "10";
            mnu_grp_loop == 11 ? #item2 += "11";
            mnu_grp_loop == 12 ? #item2 += "12";
            mnu_grp_loop == 13 ? #item2 += "13";
            mnu_grp_loop == 14 ? #item2 += "14";
            mnu_grp_loop == 15 ? #item2 += "15";
            mnu_grp_loop == 16 ? #item2 += "16";
            
            #item2 += "|";
            #allitems += #item2; //sprintf(#temp, '%f',3); 
            mnu_grp_loop += 1;
            );
            
            link_group ? (#allitems += "|<Delete Group ";#allitems += sprintf(#, "%d", link_group);#allitems += "|"):#allitems += "|<#Delete Group|";
        
            //#allitems += "<#MENU|";
           #allitems += ">Scaling|";
           zoom_off == 0 ? (#item2 = "!Automatic Scaling|"):(#item2 = "Automatic scaling|");#allitems += #item2;
           zoom_off == 1 ? (#item2 = "<!No scaling|"):(#item2 = "<No scaling|");#allitems += #item2;
           
           #allitems += ">Separation Filters|";
           FIR == 0 ? #allitems += "!IIR|" : #allitems += "IIR|";
           FIR == 1 ? #allitems += "<!FIR|" : #allitems += "<FIR|";
           #allitems += "|Show Info/Help";
           last_clicked_item = gfx_showmenu(#allitems);
         );
         );
        
        
        
        
         
         last_clicked_item == 1 ? (while_playing == 0 ? (while_playing = 1):(while_playing = 0);processing_update();caller=1;);
         last_clicked_item == 2 ? (while_recording == 0 ? (while_recording = 1):(while_recording = 0);processing_update();caller=1);
         last_clicked_item == 3 ? (while_stopped == 0 ? (while_stopped = 1):(while_stopped = 0);processing_update();caller=1);
        
          cgroup = last_clicked_item - 3;
         last_clicked_item > 3 && last_clicked_item < 20 ? (
            Link_Group != cgroup ? ( //eigene Linkgruppe NICHT angeklickt
                gmem[16*64 + 10 + cgroup] == 0 ? ( // Gruppe noch frei
                    //gmem[16*64 + 10 + cgroup] = 1; Link_Group = cgroup; gmem[16*64 +27 + cgruop] = 1; //Gruppe Starten!
                    gmem[16*64 + 10 + cgroup] = 1;Link_Group = cgroup;group_update();
                ):(
                    Link_Group = cgroup;// Gruppe teilnehmen
                );
            ):( //Eigene Gruppe angeklickt
                  Link_Group = 0;
            );
         
         );
         
          cgroup = last_clicked_item - 3 - 16;
         last_clicked_item == 20 ? (
           gmem[16*64 + 10 + Link_Group] = 0;Link_Group = 0;
         );
         
         
         
         last_clicked_item == 21 ? zoom_off = 0;
         last_clicked_item == 22 ? zoom_off = 1;
         
         
         last_clicked_item == 23  ? (FIR = 0; caller = 1);
         last_clicked_item == 24  ? (FIR = 1; caller = 1);

         
         last_clicked_item == 25  ? helpshow = 1;
         
         helpshow == 1 ? (
         gfx_r=0;gfx_g=0;gfx_b=0;gfx_a=0.7;
         gfx_rect(menu_x,menu_y+0,340*zoom,110*zoom);
         menu_x +=3;
         gfx_r=0.9;gfx_g=0.9;gfx_b=0.9;gfx_a=1;
         gfx_x = menu_x+3*zoom; gfx_y = menu_y+3*zoom;
         gfx_drawstr("TUKAN STUDIOS EXCITER WITH FAT BOTTOM (Series 2)");
         gfx_x = menu_x+3*zoom; gfx_y += 13*zoom;
         gfx_drawstr("Version: "); gfx_drawnumber(Exciter_VERSION,2);
         gfx_x = menu_x+3*zoom; gfx_y += 20*zoom;
         gfx_drawstr("Mouse modifier options:");
         gfx_x = menu_x+3*zoom; gfx_y += 15*zoom;
         gfx_drawstr("Fine tune knobs: [shift]");
         gfx_x = menu_x+3*zoom; gfx_y += 13*zoom;
         gfx_drawstr("Reset knobs: [ctrl] ([cmd] on mac)");
         gfx_x = menu_x+3*zoom; gfx_y += 13*zoom;
         gfx_drawstr("Link knobs on visible instances: [win] ([ctrl] on mac)");
         gfx_x = menu_x+3*zoom; gfx_y += 13*zoom;
         gfx_drawstr("Activate number typing: [alt]+[shift]");
         );
         
         
         ////////////////////////////////////////// ENDE MENU MENU MENU ////////////////////////////////////////////////
         
         
         ):gfx_ext_flags == 1 ? (
         zoom = min(gfx_w / 77, gfx_h /17);
         gfx_setfont(4,"Arial",12*zoom,'b');
         
         
         
               #mini_group = sprintf(#, "%i", Link_Group);
               gfx_measurestr(#mini_group, mini_w, mini_h);
               gfx_x = gfx_w - mini_w - 2; gfx_y = 2;
               Link_Group ? (
                 rgb_palette(Link_group);
                 gfx_drawstr(#mini_group);
               );
         
         
         
         gfx_x=0;gfx_y=0;gfx_a=1;
         Sub_bypass ? red() : green();
         gfx_drawstr("SUB", 0x05, gfx_w/2, gfx_h);
         
         gfx_x=gfx_w / 2;gfx_y=0;gfx_a=1;
         EXC_bypass ? red() : green();
         gfx_drawstr("EXC", 0x05, gfx_w, gfx_h);
         
         bypass == 1 ? (
         black(); gfx_a=0.4; gfx_rect(0,0,gfx_w,gfx_h);
         lightgrey();
         gfx_x=0;gfx_y=0;gfx_a=1;
         gfx_drawstr("BYPASS", 0x05, gfx_w, gfx_h);
         );
         
         
         
               mouseClick == 1 ? (
               mouse_x < gfx_W/2 ? (slider(B_Sub_Bypass.slider) == 0 ? slider(B_Sub_Bypass.slider) = 1: slider(B_Sub_Bypass.slider) = 0;  B_Sub_Bypass.quicklink_button(); caller = 1);
               mouse_x > gfx_W/2 ?  (slider(B_exc_Bypass.slider) == 0 ? slider(B_exc_Bypass.slider) = 1 : slider(B_Exc_Bypass.slider) = 0;  B_exc_Bypass.quicklink_button(); caller = 1);
               
               shift ? (slider(B_Bypass.slider) == 0 ? slider(B_Bypass.slider) = 1: slider(B_Bypass.slider) = 0; caller = 1);
                );
         );
         
         
         S2_sample_on == 0 ? (
         gmem[16*64 + 10 + link_group] != 1 ? link_group = 0;
         group_check_gfx();
         caller == 1 ? (
           parameters_update_on == 0 ? (
             parameters_update();
           );
         );
         );
         S2_sample_on = 0;
         
         
